
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model ExtensionSession
 * 
 */
export type ExtensionSession = $Result.DefaultSelection<Prisma.$ExtensionSessionPayload>
/**
 * Model UsageMetrics
 * 
 */
export type UsageMetrics = $Result.DefaultSelection<Prisma.$UsageMetricsPayload>
/**
 * Model UsageAnalytics
 * 
 */
export type UsageAnalytics = $Result.DefaultSelection<Prisma.$UsageAnalyticsPayload>
/**
 * Model AutocompleteAnalytics
 * 
 */
export type AutocompleteAnalytics = $Result.DefaultSelection<Prisma.$AutocompleteAnalyticsPayload>
/**
 * Model AutocompleteMetrics
 * 
 */
export type AutocompleteMetrics = $Result.DefaultSelection<Prisma.$AutocompleteMetricsPayload>
/**
 * Model ApiKey
 * 
 */
export type ApiKey = $Result.DefaultSelection<Prisma.$ApiKeyPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model PendingLogin
 * 
 */
export type PendingLogin = $Result.DefaultSelection<Prisma.$PendingLoginPayload>
/**
 * Model Page
 * 
 */
export type Page = $Result.DefaultSelection<Prisma.$PagePayload>
/**
 * Model UserPreferences
 * 
 */
export type UserPreferences = $Result.DefaultSelection<Prisma.$UserPreferencesPayload>
/**
 * Model FlightRecommendation
 * 
 */
export type FlightRecommendation = $Result.DefaultSelection<Prisma.$FlightRecommendationPayload>
/**
 * Model StripeSubscription
 * 
 */
export type StripeSubscription = $Result.DefaultSelection<Prisma.$StripeSubscriptionPayload>
/**
 * Model EmailNotification
 * 
 */
export type EmailNotification = $Result.DefaultSelection<Prisma.$EmailNotificationPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.extensionSession`: Exposes CRUD operations for the **ExtensionSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExtensionSessions
    * const extensionSessions = await prisma.extensionSession.findMany()
    * ```
    */
  get extensionSession(): Prisma.ExtensionSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageMetrics`: Exposes CRUD operations for the **UsageMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageMetrics
    * const usageMetrics = await prisma.usageMetrics.findMany()
    * ```
    */
  get usageMetrics(): Prisma.UsageMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageAnalytics`: Exposes CRUD operations for the **UsageAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageAnalytics
    * const usageAnalytics = await prisma.usageAnalytics.findMany()
    * ```
    */
  get usageAnalytics(): Prisma.UsageAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autocompleteAnalytics`: Exposes CRUD operations for the **AutocompleteAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutocompleteAnalytics
    * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findMany()
    * ```
    */
  get autocompleteAnalytics(): Prisma.AutocompleteAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.autocompleteMetrics`: Exposes CRUD operations for the **AutocompleteMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AutocompleteMetrics
    * const autocompleteMetrics = await prisma.autocompleteMetrics.findMany()
    * ```
    */
  get autocompleteMetrics(): Prisma.AutocompleteMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.apiKey`: Exposes CRUD operations for the **ApiKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ApiKeys
    * const apiKeys = await prisma.apiKey.findMany()
    * ```
    */
  get apiKey(): Prisma.ApiKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pendingLogin`: Exposes CRUD operations for the **PendingLogin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PendingLogins
    * const pendingLogins = await prisma.pendingLogin.findMany()
    * ```
    */
  get pendingLogin(): Prisma.PendingLoginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.page`: Exposes CRUD operations for the **Page** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pages
    * const pages = await prisma.page.findMany()
    * ```
    */
  get page(): Prisma.PageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPreferences`: Exposes CRUD operations for the **UserPreferences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPreferences
    * const userPreferences = await prisma.userPreferences.findMany()
    * ```
    */
  get userPreferences(): Prisma.UserPreferencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.flightRecommendation`: Exposes CRUD operations for the **FlightRecommendation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FlightRecommendations
    * const flightRecommendations = await prisma.flightRecommendation.findMany()
    * ```
    */
  get flightRecommendation(): Prisma.FlightRecommendationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stripeSubscription`: Exposes CRUD operations for the **StripeSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StripeSubscriptions
    * const stripeSubscriptions = await prisma.stripeSubscription.findMany()
    * ```
    */
  get stripeSubscription(): Prisma.StripeSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailNotification`: Exposes CRUD operations for the **EmailNotification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailNotifications
    * const emailNotifications = await prisma.emailNotification.findMany()
    * ```
    */
  get emailNotification(): Prisma.EmailNotificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.4.1
   * Query Engine version: a9055b89e58b4b5bfb59600785423b1db3d0e75d
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    ExtensionSession: 'ExtensionSession',
    UsageMetrics: 'UsageMetrics',
    UsageAnalytics: 'UsageAnalytics',
    AutocompleteAnalytics: 'AutocompleteAnalytics',
    AutocompleteMetrics: 'AutocompleteMetrics',
    ApiKey: 'ApiKey',
    UserProfile: 'UserProfile',
    PendingLogin: 'PendingLogin',
    Page: 'Page',
    UserPreferences: 'UserPreferences',
    FlightRecommendation: 'FlightRecommendation',
    StripeSubscription: 'StripeSubscription',
    EmailNotification: 'EmailNotification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "extensionSession" | "usageMetrics" | "usageAnalytics" | "autocompleteAnalytics" | "autocompleteMetrics" | "apiKey" | "userProfile" | "pendingLogin" | "page" | "userPreferences" | "flightRecommendation" | "stripeSubscription" | "emailNotification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      ExtensionSession: {
        payload: Prisma.$ExtensionSessionPayload<ExtArgs>
        fields: Prisma.ExtensionSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExtensionSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExtensionSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          findFirst: {
            args: Prisma.ExtensionSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExtensionSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          findMany: {
            args: Prisma.ExtensionSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>[]
          }
          create: {
            args: Prisma.ExtensionSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          createMany: {
            args: Prisma.ExtensionSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExtensionSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>[]
          }
          delete: {
            args: Prisma.ExtensionSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          update: {
            args: Prisma.ExtensionSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          deleteMany: {
            args: Prisma.ExtensionSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExtensionSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ExtensionSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>[]
          }
          upsert: {
            args: Prisma.ExtensionSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExtensionSessionPayload>
          }
          aggregate: {
            args: Prisma.ExtensionSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExtensionSession>
          }
          groupBy: {
            args: Prisma.ExtensionSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExtensionSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExtensionSessionCountArgs<ExtArgs>
            result: $Utils.Optional<ExtensionSessionCountAggregateOutputType> | number
          }
        }
      }
      UsageMetrics: {
        payload: Prisma.$UsageMetricsPayload<ExtArgs>
        fields: Prisma.UsageMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          findFirst: {
            args: Prisma.UsageMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          findMany: {
            args: Prisma.UsageMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>[]
          }
          create: {
            args: Prisma.UsageMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          createMany: {
            args: Prisma.UsageMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>[]
          }
          delete: {
            args: Prisma.UsageMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          update: {
            args: Prisma.UsageMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          deleteMany: {
            args: Prisma.UsageMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>[]
          }
          upsert: {
            args: Prisma.UsageMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageMetricsPayload>
          }
          aggregate: {
            args: Prisma.UsageMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageMetrics>
          }
          groupBy: {
            args: Prisma.UsageMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<UsageMetricsCountAggregateOutputType> | number
          }
        }
      }
      UsageAnalytics: {
        payload: Prisma.$UsageAnalyticsPayload<ExtArgs>
        fields: Prisma.UsageAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.UsageAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          findMany: {
            args: Prisma.UsageAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>[]
          }
          create: {
            args: Prisma.UsageAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          createMany: {
            args: Prisma.UsageAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.UsageAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          update: {
            args: Prisma.UsageAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.UsageAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.UsageAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.UsageAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageAnalytics>
          }
          groupBy: {
            args: Prisma.UsageAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<UsageAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      AutocompleteAnalytics: {
        payload: Prisma.$AutocompleteAnalyticsPayload<ExtArgs>
        fields: Prisma.AutocompleteAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutocompleteAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutocompleteAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.AutocompleteAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutocompleteAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          findMany: {
            args: Prisma.AutocompleteAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>[]
          }
          create: {
            args: Prisma.AutocompleteAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          createMany: {
            args: Prisma.AutocompleteAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutocompleteAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.AutocompleteAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          update: {
            args: Prisma.AutocompleteAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.AutocompleteAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutocompleteAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutocompleteAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.AutocompleteAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.AutocompleteAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutocompleteAnalytics>
          }
          groupBy: {
            args: Prisma.AutocompleteAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutocompleteAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutocompleteAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<AutocompleteAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      AutocompleteMetrics: {
        payload: Prisma.$AutocompleteMetricsPayload<ExtArgs>
        fields: Prisma.AutocompleteMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AutocompleteMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AutocompleteMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          findFirst: {
            args: Prisma.AutocompleteMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AutocompleteMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          findMany: {
            args: Prisma.AutocompleteMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>[]
          }
          create: {
            args: Prisma.AutocompleteMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          createMany: {
            args: Prisma.AutocompleteMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AutocompleteMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>[]
          }
          delete: {
            args: Prisma.AutocompleteMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          update: {
            args: Prisma.AutocompleteMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          deleteMany: {
            args: Prisma.AutocompleteMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AutocompleteMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AutocompleteMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>[]
          }
          upsert: {
            args: Prisma.AutocompleteMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AutocompleteMetricsPayload>
          }
          aggregate: {
            args: Prisma.AutocompleteMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAutocompleteMetrics>
          }
          groupBy: {
            args: Prisma.AutocompleteMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AutocompleteMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.AutocompleteMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<AutocompleteMetricsCountAggregateOutputType> | number
          }
        }
      }
      ApiKey: {
        payload: Prisma.$ApiKeyPayload<ExtArgs>
        fields: Prisma.ApiKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApiKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApiKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findFirst: {
            args: Prisma.ApiKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApiKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          findMany: {
            args: Prisma.ApiKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          create: {
            args: Prisma.ApiKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          createMany: {
            args: Prisma.ApiKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ApiKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          delete: {
            args: Prisma.ApiKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          update: {
            args: Prisma.ApiKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          deleteMany: {
            args: Prisma.ApiKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApiKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ApiKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>[]
          }
          upsert: {
            args: Prisma.ApiKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApiKeyPayload>
          }
          aggregate: {
            args: Prisma.ApiKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApiKey>
          }
          groupBy: {
            args: Prisma.ApiKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApiKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ApiKeyCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      PendingLogin: {
        payload: Prisma.$PendingLoginPayload<ExtArgs>
        fields: Prisma.PendingLoginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PendingLoginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PendingLoginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          findFirst: {
            args: Prisma.PendingLoginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PendingLoginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          findMany: {
            args: Prisma.PendingLoginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>[]
          }
          create: {
            args: Prisma.PendingLoginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          createMany: {
            args: Prisma.PendingLoginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PendingLoginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>[]
          }
          delete: {
            args: Prisma.PendingLoginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          update: {
            args: Prisma.PendingLoginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          deleteMany: {
            args: Prisma.PendingLoginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PendingLoginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PendingLoginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>[]
          }
          upsert: {
            args: Prisma.PendingLoginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PendingLoginPayload>
          }
          aggregate: {
            args: Prisma.PendingLoginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePendingLogin>
          }
          groupBy: {
            args: Prisma.PendingLoginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PendingLoginGroupByOutputType>[]
          }
          count: {
            args: Prisma.PendingLoginCountArgs<ExtArgs>
            result: $Utils.Optional<PendingLoginCountAggregateOutputType> | number
          }
        }
      }
      Page: {
        payload: Prisma.$PagePayload<ExtArgs>
        fields: Prisma.PageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findFirst: {
            args: Prisma.PageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          findMany: {
            args: Prisma.PageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          create: {
            args: Prisma.PageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          createMany: {
            args: Prisma.PageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          delete: {
            args: Prisma.PageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          update: {
            args: Prisma.PageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          deleteMany: {
            args: Prisma.PageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>[]
          }
          upsert: {
            args: Prisma.PageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PagePayload>
          }
          aggregate: {
            args: Prisma.PageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePage>
          }
          groupBy: {
            args: Prisma.PageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PageCountArgs<ExtArgs>
            result: $Utils.Optional<PageCountAggregateOutputType> | number
          }
        }
      }
      UserPreferences: {
        payload: Prisma.$UserPreferencesPayload<ExtArgs>
        fields: Prisma.UserPreferencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPreferencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPreferencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findFirst: {
            args: Prisma.UserPreferencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPreferencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          findMany: {
            args: Prisma.UserPreferencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          create: {
            args: Prisma.UserPreferencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          createMany: {
            args: Prisma.UserPreferencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPreferencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          delete: {
            args: Prisma.UserPreferencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          update: {
            args: Prisma.UserPreferencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          deleteMany: {
            args: Prisma.UserPreferencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPreferencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPreferencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>[]
          }
          upsert: {
            args: Prisma.UserPreferencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPreferencesPayload>
          }
          aggregate: {
            args: Prisma.UserPreferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPreferences>
          }
          groupBy: {
            args: Prisma.UserPreferencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPreferencesCountArgs<ExtArgs>
            result: $Utils.Optional<UserPreferencesCountAggregateOutputType> | number
          }
        }
      }
      FlightRecommendation: {
        payload: Prisma.$FlightRecommendationPayload<ExtArgs>
        fields: Prisma.FlightRecommendationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlightRecommendationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlightRecommendationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          findFirst: {
            args: Prisma.FlightRecommendationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlightRecommendationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          findMany: {
            args: Prisma.FlightRecommendationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>[]
          }
          create: {
            args: Prisma.FlightRecommendationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          createMany: {
            args: Prisma.FlightRecommendationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlightRecommendationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>[]
          }
          delete: {
            args: Prisma.FlightRecommendationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          update: {
            args: Prisma.FlightRecommendationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          deleteMany: {
            args: Prisma.FlightRecommendationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlightRecommendationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FlightRecommendationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>[]
          }
          upsert: {
            args: Prisma.FlightRecommendationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlightRecommendationPayload>
          }
          aggregate: {
            args: Prisma.FlightRecommendationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlightRecommendation>
          }
          groupBy: {
            args: Prisma.FlightRecommendationGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlightRecommendationGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlightRecommendationCountArgs<ExtArgs>
            result: $Utils.Optional<FlightRecommendationCountAggregateOutputType> | number
          }
        }
      }
      StripeSubscription: {
        payload: Prisma.$StripeSubscriptionPayload<ExtArgs>
        fields: Prisma.StripeSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StripeSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.StripeSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StripeSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          findMany: {
            args: Prisma.StripeSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>[]
          }
          create: {
            args: Prisma.StripeSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          createMany: {
            args: Prisma.StripeSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StripeSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.StripeSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          update: {
            args: Prisma.StripeSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.StripeSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StripeSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StripeSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.StripeSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StripeSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.StripeSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStripeSubscription>
          }
          groupBy: {
            args: Prisma.StripeSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<StripeSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.StripeSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<StripeSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      EmailNotification: {
        payload: Prisma.$EmailNotificationPayload<ExtArgs>
        fields: Prisma.EmailNotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailNotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailNotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findFirst: {
            args: Prisma.EmailNotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailNotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          findMany: {
            args: Prisma.EmailNotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          create: {
            args: Prisma.EmailNotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          createMany: {
            args: Prisma.EmailNotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailNotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          delete: {
            args: Prisma.EmailNotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          update: {
            args: Prisma.EmailNotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          deleteMany: {
            args: Prisma.EmailNotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailNotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailNotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>[]
          }
          upsert: {
            args: Prisma.EmailNotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailNotificationPayload>
          }
          aggregate: {
            args: Prisma.EmailNotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailNotification>
          }
          groupBy: {
            args: Prisma.EmailNotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailNotificationCountArgs<ExtArgs>
            result: $Utils.Optional<EmailNotificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.DriverAdapter | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    extensionSession?: ExtensionSessionOmit
    usageMetrics?: UsageMetricsOmit
    usageAnalytics?: UsageAnalyticsOmit
    autocompleteAnalytics?: AutocompleteAnalyticsOmit
    autocompleteMetrics?: AutocompleteMetricsOmit
    apiKey?: ApiKeyOmit
    userProfile?: UserProfileOmit
    pendingLogin?: PendingLoginOmit
    page?: PageOmit
    userPreferences?: UserPreferencesOmit
    flightRecommendation?: FlightRecommendationOmit
    stripeSubscription?: StripeSubscriptionOmit
    emailNotification?: EmailNotificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    extensionSessions: number
    usageMetrics: number
    apiKeys: number
    usageAnalytics: number
    autocompleteAnalytics: number
    autocompleteMetrics: number
    flightRecommendations: number
    emailNotifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extensionSessions?: boolean | UserCountOutputTypeCountExtensionSessionsArgs
    usageMetrics?: boolean | UserCountOutputTypeCountUsageMetricsArgs
    apiKeys?: boolean | UserCountOutputTypeCountApiKeysArgs
    usageAnalytics?: boolean | UserCountOutputTypeCountUsageAnalyticsArgs
    autocompleteAnalytics?: boolean | UserCountOutputTypeCountAutocompleteAnalyticsArgs
    autocompleteMetrics?: boolean | UserCountOutputTypeCountAutocompleteMetricsArgs
    flightRecommendations?: boolean | UserCountOutputTypeCountFlightRecommendationsArgs
    emailNotifications?: boolean | UserCountOutputTypeCountEmailNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExtensionSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtensionSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUsageAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageAnalyticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutocompleteAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutocompleteAnalyticsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAutocompleteMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutocompleteMetricsWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlightRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightRecommendationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailNotificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    cubentUnitsUsed: number | null
    cubentUnitsLimit: number | null
  }

  export type UserSumAggregateOutputType = {
    cubentUnitsUsed: number | null
    cubentUnitsLimit: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    clerkId: string | null
    email: string | null
    name: string | null
    picture: string | null
    extensionApiKey: string | null
    sessionToken: string | null
    lastExtensionSync: Date | null
    lastSettingsSync: Date | null
    extensionEnabled: boolean | null
    lastActiveAt: Date | null
    termsAccepted: boolean | null
    termsAcceptedAt: Date | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    cubentUnitsUsed: number | null
    cubentUnitsLimit: number | null
    unitsResetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    clerkId: string | null
    email: string | null
    name: string | null
    picture: string | null
    extensionApiKey: string | null
    sessionToken: string | null
    lastExtensionSync: Date | null
    lastSettingsSync: Date | null
    extensionEnabled: boolean | null
    lastActiveAt: Date | null
    termsAccepted: boolean | null
    termsAcceptedAt: Date | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    cubentUnitsUsed: number | null
    cubentUnitsLimit: number | null
    unitsResetDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    clerkId: number
    email: number
    name: number
    picture: number
    extensionApiKey: number
    sessionToken: number
    lastExtensionSync: number
    lastSettingsSync: number
    extensionEnabled: number
    lastActiveAt: number
    termsAccepted: number
    termsAcceptedAt: number
    subscriptionTier: number
    subscriptionStatus: number
    cubentUnitsUsed: number
    cubentUnitsLimit: number
    unitsResetDate: number
    extensionSettings: number
    preferences: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    cubentUnitsUsed?: true
    cubentUnitsLimit?: true
  }

  export type UserSumAggregateInputType = {
    cubentUnitsUsed?: true
    cubentUnitsLimit?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    name?: true
    picture?: true
    extensionApiKey?: true
    sessionToken?: true
    lastExtensionSync?: true
    lastSettingsSync?: true
    extensionEnabled?: true
    lastActiveAt?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    cubentUnitsUsed?: true
    cubentUnitsLimit?: true
    unitsResetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    name?: true
    picture?: true
    extensionApiKey?: true
    sessionToken?: true
    lastExtensionSync?: true
    lastSettingsSync?: true
    extensionEnabled?: true
    lastActiveAt?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    cubentUnitsUsed?: true
    cubentUnitsLimit?: true
    unitsResetDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    clerkId?: true
    email?: true
    name?: true
    picture?: true
    extensionApiKey?: true
    sessionToken?: true
    lastExtensionSync?: true
    lastSettingsSync?: true
    extensionEnabled?: true
    lastActiveAt?: true
    termsAccepted?: true
    termsAcceptedAt?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    cubentUnitsUsed?: true
    cubentUnitsLimit?: true
    unitsResetDate?: true
    extensionSettings?: true
    preferences?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    clerkId: string
    email: string
    name: string | null
    picture: string | null
    extensionApiKey: string | null
    sessionToken: string | null
    lastExtensionSync: Date | null
    lastSettingsSync: Date | null
    extensionEnabled: boolean
    lastActiveAt: Date | null
    termsAccepted: boolean
    termsAcceptedAt: Date | null
    subscriptionTier: string
    subscriptionStatus: string
    cubentUnitsUsed: number
    cubentUnitsLimit: number
    unitsResetDate: Date | null
    extensionSettings: JsonValue | null
    preferences: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    email?: boolean
    name?: boolean
    picture?: boolean
    extensionApiKey?: boolean
    sessionToken?: boolean
    lastExtensionSync?: boolean
    lastSettingsSync?: boolean
    extensionEnabled?: boolean
    lastActiveAt?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    cubentUnitsUsed?: boolean
    cubentUnitsLimit?: boolean
    unitsResetDate?: boolean
    extensionSettings?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    extensionSessions?: boolean | User$extensionSessionsArgs<ExtArgs>
    usageMetrics?: boolean | User$usageMetricsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    usageAnalytics?: boolean | User$usageAnalyticsArgs<ExtArgs>
    autocompleteAnalytics?: boolean | User$autocompleteAnalyticsArgs<ExtArgs>
    autocompleteMetrics?: boolean | User$autocompleteMetricsArgs<ExtArgs>
    travelPreferences?: boolean | User$travelPreferencesArgs<ExtArgs>
    flightRecommendations?: boolean | User$flightRecommendationsArgs<ExtArgs>
    stripeSubscription?: boolean | User$stripeSubscriptionArgs<ExtArgs>
    emailNotifications?: boolean | User$emailNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    email?: boolean
    name?: boolean
    picture?: boolean
    extensionApiKey?: boolean
    sessionToken?: boolean
    lastExtensionSync?: boolean
    lastSettingsSync?: boolean
    extensionEnabled?: boolean
    lastActiveAt?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    cubentUnitsUsed?: boolean
    cubentUnitsLimit?: boolean
    unitsResetDate?: boolean
    extensionSettings?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clerkId?: boolean
    email?: boolean
    name?: boolean
    picture?: boolean
    extensionApiKey?: boolean
    sessionToken?: boolean
    lastExtensionSync?: boolean
    lastSettingsSync?: boolean
    extensionEnabled?: boolean
    lastActiveAt?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    cubentUnitsUsed?: boolean
    cubentUnitsLimit?: boolean
    unitsResetDate?: boolean
    extensionSettings?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    clerkId?: boolean
    email?: boolean
    name?: boolean
    picture?: boolean
    extensionApiKey?: boolean
    sessionToken?: boolean
    lastExtensionSync?: boolean
    lastSettingsSync?: boolean
    extensionEnabled?: boolean
    lastActiveAt?: boolean
    termsAccepted?: boolean
    termsAcceptedAt?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    cubentUnitsUsed?: boolean
    cubentUnitsLimit?: boolean
    unitsResetDate?: boolean
    extensionSettings?: boolean
    preferences?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clerkId" | "email" | "name" | "picture" | "extensionApiKey" | "sessionToken" | "lastExtensionSync" | "lastSettingsSync" | "extensionEnabled" | "lastActiveAt" | "termsAccepted" | "termsAcceptedAt" | "subscriptionTier" | "subscriptionStatus" | "cubentUnitsUsed" | "cubentUnitsLimit" | "unitsResetDate" | "extensionSettings" | "preferences" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    extensionSessions?: boolean | User$extensionSessionsArgs<ExtArgs>
    usageMetrics?: boolean | User$usageMetricsArgs<ExtArgs>
    apiKeys?: boolean | User$apiKeysArgs<ExtArgs>
    usageAnalytics?: boolean | User$usageAnalyticsArgs<ExtArgs>
    autocompleteAnalytics?: boolean | User$autocompleteAnalyticsArgs<ExtArgs>
    autocompleteMetrics?: boolean | User$autocompleteMetricsArgs<ExtArgs>
    travelPreferences?: boolean | User$travelPreferencesArgs<ExtArgs>
    flightRecommendations?: boolean | User$flightRecommendationsArgs<ExtArgs>
    stripeSubscription?: boolean | User$stripeSubscriptionArgs<ExtArgs>
    emailNotifications?: boolean | User$emailNotificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      extensionSessions: Prisma.$ExtensionSessionPayload<ExtArgs>[]
      usageMetrics: Prisma.$UsageMetricsPayload<ExtArgs>[]
      apiKeys: Prisma.$ApiKeyPayload<ExtArgs>[]
      usageAnalytics: Prisma.$UsageAnalyticsPayload<ExtArgs>[]
      autocompleteAnalytics: Prisma.$AutocompleteAnalyticsPayload<ExtArgs>[]
      autocompleteMetrics: Prisma.$AutocompleteMetricsPayload<ExtArgs>[]
      travelPreferences: Prisma.$UserPreferencesPayload<ExtArgs> | null
      flightRecommendations: Prisma.$FlightRecommendationPayload<ExtArgs>[]
      stripeSubscription: Prisma.$StripeSubscriptionPayload<ExtArgs> | null
      emailNotifications: Prisma.$EmailNotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clerkId: string
      email: string
      name: string | null
      picture: string | null
      extensionApiKey: string | null
      sessionToken: string | null
      lastExtensionSync: Date | null
      lastSettingsSync: Date | null
      extensionEnabled: boolean
      lastActiveAt: Date | null
      termsAccepted: boolean
      termsAcceptedAt: Date | null
      subscriptionTier: string
      subscriptionStatus: string
      cubentUnitsUsed: number
      cubentUnitsLimit: number
      unitsResetDate: Date | null
      extensionSettings: Prisma.JsonValue | null
      preferences: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    extensionSessions<T extends User$extensionSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$extensionSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    usageMetrics<T extends User$usageMetricsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    apiKeys<T extends User$apiKeysArgs<ExtArgs> = {}>(args?: Subset<T, User$apiKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    usageAnalytics<T extends User$usageAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$usageAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    autocompleteAnalytics<T extends User$autocompleteAnalyticsArgs<ExtArgs> = {}>(args?: Subset<T, User$autocompleteAnalyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    autocompleteMetrics<T extends User$autocompleteMetricsArgs<ExtArgs> = {}>(args?: Subset<T, User$autocompleteMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    travelPreferences<T extends User$travelPreferencesArgs<ExtArgs> = {}>(args?: Subset<T, User$travelPreferencesArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    flightRecommendations<T extends User$flightRecommendationsArgs<ExtArgs> = {}>(args?: Subset<T, User$flightRecommendationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    stripeSubscription<T extends User$stripeSubscriptionArgs<ExtArgs> = {}>(args?: Subset<T, User$stripeSubscriptionArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    emailNotifications<T extends User$emailNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly clerkId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly picture: FieldRef<"User", 'String'>
    readonly extensionApiKey: FieldRef<"User", 'String'>
    readonly sessionToken: FieldRef<"User", 'String'>
    readonly lastExtensionSync: FieldRef<"User", 'DateTime'>
    readonly lastSettingsSync: FieldRef<"User", 'DateTime'>
    readonly extensionEnabled: FieldRef<"User", 'Boolean'>
    readonly lastActiveAt: FieldRef<"User", 'DateTime'>
    readonly termsAccepted: FieldRef<"User", 'Boolean'>
    readonly termsAcceptedAt: FieldRef<"User", 'DateTime'>
    readonly subscriptionTier: FieldRef<"User", 'String'>
    readonly subscriptionStatus: FieldRef<"User", 'String'>
    readonly cubentUnitsUsed: FieldRef<"User", 'Float'>
    readonly cubentUnitsLimit: FieldRef<"User", 'Float'>
    readonly unitsResetDate: FieldRef<"User", 'DateTime'>
    readonly extensionSettings: FieldRef<"User", 'Json'>
    readonly preferences: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.extensionSessions
   */
  export type User$extensionSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    where?: ExtensionSessionWhereInput
    orderBy?: ExtensionSessionOrderByWithRelationInput | ExtensionSessionOrderByWithRelationInput[]
    cursor?: ExtensionSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExtensionSessionScalarFieldEnum | ExtensionSessionScalarFieldEnum[]
  }

  /**
   * User.usageMetrics
   */
  export type User$usageMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    where?: UsageMetricsWhereInput
    orderBy?: UsageMetricsOrderByWithRelationInput | UsageMetricsOrderByWithRelationInput[]
    cursor?: UsageMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageMetricsScalarFieldEnum | UsageMetricsScalarFieldEnum[]
  }

  /**
   * User.apiKeys
   */
  export type User$apiKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    cursor?: ApiKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * User.usageAnalytics
   */
  export type User$usageAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    where?: UsageAnalyticsWhereInput
    orderBy?: UsageAnalyticsOrderByWithRelationInput | UsageAnalyticsOrderByWithRelationInput[]
    cursor?: UsageAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsageAnalyticsScalarFieldEnum | UsageAnalyticsScalarFieldEnum[]
  }

  /**
   * User.autocompleteAnalytics
   */
  export type User$autocompleteAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    where?: AutocompleteAnalyticsWhereInput
    orderBy?: AutocompleteAnalyticsOrderByWithRelationInput | AutocompleteAnalyticsOrderByWithRelationInput[]
    cursor?: AutocompleteAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutocompleteAnalyticsScalarFieldEnum | AutocompleteAnalyticsScalarFieldEnum[]
  }

  /**
   * User.autocompleteMetrics
   */
  export type User$autocompleteMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    where?: AutocompleteMetricsWhereInput
    orderBy?: AutocompleteMetricsOrderByWithRelationInput | AutocompleteMetricsOrderByWithRelationInput[]
    cursor?: AutocompleteMetricsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AutocompleteMetricsScalarFieldEnum | AutocompleteMetricsScalarFieldEnum[]
  }

  /**
   * User.travelPreferences
   */
  export type User$travelPreferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    where?: UserPreferencesWhereInput
  }

  /**
   * User.flightRecommendations
   */
  export type User$flightRecommendationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    where?: FlightRecommendationWhereInput
    orderBy?: FlightRecommendationOrderByWithRelationInput | FlightRecommendationOrderByWithRelationInput[]
    cursor?: FlightRecommendationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlightRecommendationScalarFieldEnum | FlightRecommendationScalarFieldEnum[]
  }

  /**
   * User.stripeSubscription
   */
  export type User$stripeSubscriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    where?: StripeSubscriptionWhereInput
  }

  /**
   * User.emailNotifications
   */
  export type User$emailNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    where?: EmailNotificationWhereInput
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    cursor?: EmailNotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model ExtensionSession
   */

  export type AggregateExtensionSession = {
    _count: ExtensionSessionCountAggregateOutputType | null
    _avg: ExtensionSessionAvgAggregateOutputType | null
    _sum: ExtensionSessionSumAggregateOutputType | null
    _min: ExtensionSessionMinAggregateOutputType | null
    _max: ExtensionSessionMaxAggregateOutputType | null
  }

  export type ExtensionSessionAvgAggregateOutputType = {
    tokensUsed: number | null
    requestsMade: number | null
  }

  export type ExtensionSessionSumAggregateOutputType = {
    tokensUsed: number | null
    requestsMade: number | null
  }

  export type ExtensionSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    isActive: boolean | null
    lastActiveAt: Date | null
    extensionVersion: string | null
    vscodeVersion: string | null
    platform: string | null
    tokensUsed: number | null
    requestsMade: number | null
    createdAt: Date | null
  }

  export type ExtensionSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    sessionId: string | null
    isActive: boolean | null
    lastActiveAt: Date | null
    extensionVersion: string | null
    vscodeVersion: string | null
    platform: string | null
    tokensUsed: number | null
    requestsMade: number | null
    createdAt: Date | null
  }

  export type ExtensionSessionCountAggregateOutputType = {
    id: number
    userId: number
    sessionId: number
    isActive: number
    lastActiveAt: number
    extensionVersion: number
    vscodeVersion: number
    platform: number
    metadata: number
    tokensUsed: number
    requestsMade: number
    createdAt: number
    _all: number
  }


  export type ExtensionSessionAvgAggregateInputType = {
    tokensUsed?: true
    requestsMade?: true
  }

  export type ExtensionSessionSumAggregateInputType = {
    tokensUsed?: true
    requestsMade?: true
  }

  export type ExtensionSessionMinAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    isActive?: true
    lastActiveAt?: true
    extensionVersion?: true
    vscodeVersion?: true
    platform?: true
    tokensUsed?: true
    requestsMade?: true
    createdAt?: true
  }

  export type ExtensionSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    isActive?: true
    lastActiveAt?: true
    extensionVersion?: true
    vscodeVersion?: true
    platform?: true
    tokensUsed?: true
    requestsMade?: true
    createdAt?: true
  }

  export type ExtensionSessionCountAggregateInputType = {
    id?: true
    userId?: true
    sessionId?: true
    isActive?: true
    lastActiveAt?: true
    extensionVersion?: true
    vscodeVersion?: true
    platform?: true
    metadata?: true
    tokensUsed?: true
    requestsMade?: true
    createdAt?: true
    _all?: true
  }

  export type ExtensionSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtensionSession to aggregate.
     */
    where?: ExtensionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtensionSessions to fetch.
     */
    orderBy?: ExtensionSessionOrderByWithRelationInput | ExtensionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExtensionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtensionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtensionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExtensionSessions
    **/
    _count?: true | ExtensionSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExtensionSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExtensionSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExtensionSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExtensionSessionMaxAggregateInputType
  }

  export type GetExtensionSessionAggregateType<T extends ExtensionSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateExtensionSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExtensionSession[P]>
      : GetScalarType<T[P], AggregateExtensionSession[P]>
  }




  export type ExtensionSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExtensionSessionWhereInput
    orderBy?: ExtensionSessionOrderByWithAggregationInput | ExtensionSessionOrderByWithAggregationInput[]
    by: ExtensionSessionScalarFieldEnum[] | ExtensionSessionScalarFieldEnum
    having?: ExtensionSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExtensionSessionCountAggregateInputType | true
    _avg?: ExtensionSessionAvgAggregateInputType
    _sum?: ExtensionSessionSumAggregateInputType
    _min?: ExtensionSessionMinAggregateInputType
    _max?: ExtensionSessionMaxAggregateInputType
  }

  export type ExtensionSessionGroupByOutputType = {
    id: string
    userId: string
    sessionId: string
    isActive: boolean
    lastActiveAt: Date
    extensionVersion: string | null
    vscodeVersion: string | null
    platform: string | null
    metadata: JsonValue | null
    tokensUsed: number
    requestsMade: number
    createdAt: Date
    _count: ExtensionSessionCountAggregateOutputType | null
    _avg: ExtensionSessionAvgAggregateOutputType | null
    _sum: ExtensionSessionSumAggregateOutputType | null
    _min: ExtensionSessionMinAggregateOutputType | null
    _max: ExtensionSessionMaxAggregateOutputType | null
  }

  type GetExtensionSessionGroupByPayload<T extends ExtensionSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExtensionSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExtensionSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExtensionSessionGroupByOutputType[P]>
            : GetScalarType<T[P], ExtensionSessionGroupByOutputType[P]>
        }
      >
    >


  export type ExtensionSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    isActive?: boolean
    lastActiveAt?: boolean
    extensionVersion?: boolean
    vscodeVersion?: boolean
    platform?: boolean
    metadata?: boolean
    tokensUsed?: boolean
    requestsMade?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extensionSession"]>

  export type ExtensionSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    isActive?: boolean
    lastActiveAt?: boolean
    extensionVersion?: boolean
    vscodeVersion?: boolean
    platform?: boolean
    metadata?: boolean
    tokensUsed?: boolean
    requestsMade?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extensionSession"]>

  export type ExtensionSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    isActive?: boolean
    lastActiveAt?: boolean
    extensionVersion?: boolean
    vscodeVersion?: boolean
    platform?: boolean
    metadata?: boolean
    tokensUsed?: boolean
    requestsMade?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["extensionSession"]>

  export type ExtensionSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    sessionId?: boolean
    isActive?: boolean
    lastActiveAt?: boolean
    extensionVersion?: boolean
    vscodeVersion?: boolean
    platform?: boolean
    metadata?: boolean
    tokensUsed?: boolean
    requestsMade?: boolean
    createdAt?: boolean
  }

  export type ExtensionSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "sessionId" | "isActive" | "lastActiveAt" | "extensionVersion" | "vscodeVersion" | "platform" | "metadata" | "tokensUsed" | "requestsMade" | "createdAt", ExtArgs["result"]["extensionSession"]>
  export type ExtensionSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExtensionSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ExtensionSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ExtensionSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExtensionSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      sessionId: string
      isActive: boolean
      lastActiveAt: Date
      extensionVersion: string | null
      vscodeVersion: string | null
      platform: string | null
      metadata: Prisma.JsonValue | null
      tokensUsed: number
      requestsMade: number
      createdAt: Date
    }, ExtArgs["result"]["extensionSession"]>
    composites: {}
  }

  type ExtensionSessionGetPayload<S extends boolean | null | undefined | ExtensionSessionDefaultArgs> = $Result.GetResult<Prisma.$ExtensionSessionPayload, S>

  type ExtensionSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ExtensionSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExtensionSessionCountAggregateInputType | true
    }

  export interface ExtensionSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExtensionSession'], meta: { name: 'ExtensionSession' } }
    /**
     * Find zero or one ExtensionSession that matches the filter.
     * @param {ExtensionSessionFindUniqueArgs} args - Arguments to find a ExtensionSession
     * @example
     * // Get one ExtensionSession
     * const extensionSession = await prisma.extensionSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExtensionSessionFindUniqueArgs>(args: SelectSubset<T, ExtensionSessionFindUniqueArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ExtensionSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ExtensionSessionFindUniqueOrThrowArgs} args - Arguments to find a ExtensionSession
     * @example
     * // Get one ExtensionSession
     * const extensionSession = await prisma.extensionSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExtensionSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExtensionSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ExtensionSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionFindFirstArgs} args - Arguments to find a ExtensionSession
     * @example
     * // Get one ExtensionSession
     * const extensionSession = await prisma.extensionSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExtensionSessionFindFirstArgs>(args?: SelectSubset<T, ExtensionSessionFindFirstArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ExtensionSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionFindFirstOrThrowArgs} args - Arguments to find a ExtensionSession
     * @example
     * // Get one ExtensionSession
     * const extensionSession = await prisma.extensionSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExtensionSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExtensionSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ExtensionSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExtensionSessions
     * const extensionSessions = await prisma.extensionSession.findMany()
     * 
     * // Get first 10 ExtensionSessions
     * const extensionSessions = await prisma.extensionSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const extensionSessionWithIdOnly = await prisma.extensionSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExtensionSessionFindManyArgs>(args?: SelectSubset<T, ExtensionSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ExtensionSession.
     * @param {ExtensionSessionCreateArgs} args - Arguments to create a ExtensionSession.
     * @example
     * // Create one ExtensionSession
     * const ExtensionSession = await prisma.extensionSession.create({
     *   data: {
     *     // ... data to create a ExtensionSession
     *   }
     * })
     * 
     */
    create<T extends ExtensionSessionCreateArgs>(args: SelectSubset<T, ExtensionSessionCreateArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ExtensionSessions.
     * @param {ExtensionSessionCreateManyArgs} args - Arguments to create many ExtensionSessions.
     * @example
     * // Create many ExtensionSessions
     * const extensionSession = await prisma.extensionSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExtensionSessionCreateManyArgs>(args?: SelectSubset<T, ExtensionSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExtensionSessions and returns the data saved in the database.
     * @param {ExtensionSessionCreateManyAndReturnArgs} args - Arguments to create many ExtensionSessions.
     * @example
     * // Create many ExtensionSessions
     * const extensionSession = await prisma.extensionSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExtensionSessions and only return the `id`
     * const extensionSessionWithIdOnly = await prisma.extensionSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExtensionSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExtensionSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ExtensionSession.
     * @param {ExtensionSessionDeleteArgs} args - Arguments to delete one ExtensionSession.
     * @example
     * // Delete one ExtensionSession
     * const ExtensionSession = await prisma.extensionSession.delete({
     *   where: {
     *     // ... filter to delete one ExtensionSession
     *   }
     * })
     * 
     */
    delete<T extends ExtensionSessionDeleteArgs>(args: SelectSubset<T, ExtensionSessionDeleteArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ExtensionSession.
     * @param {ExtensionSessionUpdateArgs} args - Arguments to update one ExtensionSession.
     * @example
     * // Update one ExtensionSession
     * const extensionSession = await prisma.extensionSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExtensionSessionUpdateArgs>(args: SelectSubset<T, ExtensionSessionUpdateArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ExtensionSessions.
     * @param {ExtensionSessionDeleteManyArgs} args - Arguments to filter ExtensionSessions to delete.
     * @example
     * // Delete a few ExtensionSessions
     * const { count } = await prisma.extensionSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExtensionSessionDeleteManyArgs>(args?: SelectSubset<T, ExtensionSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtensionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExtensionSessions
     * const extensionSession = await prisma.extensionSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExtensionSessionUpdateManyArgs>(args: SelectSubset<T, ExtensionSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExtensionSessions and returns the data updated in the database.
     * @param {ExtensionSessionUpdateManyAndReturnArgs} args - Arguments to update many ExtensionSessions.
     * @example
     * // Update many ExtensionSessions
     * const extensionSession = await prisma.extensionSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ExtensionSessions and only return the `id`
     * const extensionSessionWithIdOnly = await prisma.extensionSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ExtensionSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExtensionSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ExtensionSession.
     * @param {ExtensionSessionUpsertArgs} args - Arguments to update or create a ExtensionSession.
     * @example
     * // Update or create a ExtensionSession
     * const extensionSession = await prisma.extensionSession.upsert({
     *   create: {
     *     // ... data to create a ExtensionSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExtensionSession we want to update
     *   }
     * })
     */
    upsert<T extends ExtensionSessionUpsertArgs>(args: SelectSubset<T, ExtensionSessionUpsertArgs<ExtArgs>>): Prisma__ExtensionSessionClient<$Result.GetResult<Prisma.$ExtensionSessionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ExtensionSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionCountArgs} args - Arguments to filter ExtensionSessions to count.
     * @example
     * // Count the number of ExtensionSessions
     * const count = await prisma.extensionSession.count({
     *   where: {
     *     // ... the filter for the ExtensionSessions we want to count
     *   }
     * })
    **/
    count<T extends ExtensionSessionCountArgs>(
      args?: Subset<T, ExtensionSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExtensionSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExtensionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExtensionSessionAggregateArgs>(args: Subset<T, ExtensionSessionAggregateArgs>): Prisma.PrismaPromise<GetExtensionSessionAggregateType<T>>

    /**
     * Group by ExtensionSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExtensionSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExtensionSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExtensionSessionGroupByArgs['orderBy'] }
        : { orderBy?: ExtensionSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExtensionSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExtensionSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExtensionSession model
   */
  readonly fields: ExtensionSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExtensionSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExtensionSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExtensionSession model
   */ 
  interface ExtensionSessionFieldRefs {
    readonly id: FieldRef<"ExtensionSession", 'String'>
    readonly userId: FieldRef<"ExtensionSession", 'String'>
    readonly sessionId: FieldRef<"ExtensionSession", 'String'>
    readonly isActive: FieldRef<"ExtensionSession", 'Boolean'>
    readonly lastActiveAt: FieldRef<"ExtensionSession", 'DateTime'>
    readonly extensionVersion: FieldRef<"ExtensionSession", 'String'>
    readonly vscodeVersion: FieldRef<"ExtensionSession", 'String'>
    readonly platform: FieldRef<"ExtensionSession", 'String'>
    readonly metadata: FieldRef<"ExtensionSession", 'Json'>
    readonly tokensUsed: FieldRef<"ExtensionSession", 'Int'>
    readonly requestsMade: FieldRef<"ExtensionSession", 'Int'>
    readonly createdAt: FieldRef<"ExtensionSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExtensionSession findUnique
   */
  export type ExtensionSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExtensionSession to fetch.
     */
    where: ExtensionSessionWhereUniqueInput
  }

  /**
   * ExtensionSession findUniqueOrThrow
   */
  export type ExtensionSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExtensionSession to fetch.
     */
    where: ExtensionSessionWhereUniqueInput
  }

  /**
   * ExtensionSession findFirst
   */
  export type ExtensionSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExtensionSession to fetch.
     */
    where?: ExtensionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtensionSessions to fetch.
     */
    orderBy?: ExtensionSessionOrderByWithRelationInput | ExtensionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtensionSessions.
     */
    cursor?: ExtensionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtensionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtensionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtensionSessions.
     */
    distinct?: ExtensionSessionScalarFieldEnum | ExtensionSessionScalarFieldEnum[]
  }

  /**
   * ExtensionSession findFirstOrThrow
   */
  export type ExtensionSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExtensionSession to fetch.
     */
    where?: ExtensionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtensionSessions to fetch.
     */
    orderBy?: ExtensionSessionOrderByWithRelationInput | ExtensionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExtensionSessions.
     */
    cursor?: ExtensionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtensionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtensionSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExtensionSessions.
     */
    distinct?: ExtensionSessionScalarFieldEnum | ExtensionSessionScalarFieldEnum[]
  }

  /**
   * ExtensionSession findMany
   */
  export type ExtensionSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter, which ExtensionSessions to fetch.
     */
    where?: ExtensionSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExtensionSessions to fetch.
     */
    orderBy?: ExtensionSessionOrderByWithRelationInput | ExtensionSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExtensionSessions.
     */
    cursor?: ExtensionSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExtensionSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExtensionSessions.
     */
    skip?: number
    distinct?: ExtensionSessionScalarFieldEnum | ExtensionSessionScalarFieldEnum[]
  }

  /**
   * ExtensionSession create
   */
  export type ExtensionSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a ExtensionSession.
     */
    data: XOR<ExtensionSessionCreateInput, ExtensionSessionUncheckedCreateInput>
  }

  /**
   * ExtensionSession createMany
   */
  export type ExtensionSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExtensionSessions.
     */
    data: ExtensionSessionCreateManyInput | ExtensionSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExtensionSession createManyAndReturn
   */
  export type ExtensionSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * The data used to create many ExtensionSessions.
     */
    data: ExtensionSessionCreateManyInput | ExtensionSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtensionSession update
   */
  export type ExtensionSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a ExtensionSession.
     */
    data: XOR<ExtensionSessionUpdateInput, ExtensionSessionUncheckedUpdateInput>
    /**
     * Choose, which ExtensionSession to update.
     */
    where: ExtensionSessionWhereUniqueInput
  }

  /**
   * ExtensionSession updateMany
   */
  export type ExtensionSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExtensionSessions.
     */
    data: XOR<ExtensionSessionUpdateManyMutationInput, ExtensionSessionUncheckedUpdateManyInput>
    /**
     * Filter which ExtensionSessions to update
     */
    where?: ExtensionSessionWhereInput
    /**
     * Limit how many ExtensionSessions to update.
     */
    limit?: number
  }

  /**
   * ExtensionSession updateManyAndReturn
   */
  export type ExtensionSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * The data used to update ExtensionSessions.
     */
    data: XOR<ExtensionSessionUpdateManyMutationInput, ExtensionSessionUncheckedUpdateManyInput>
    /**
     * Filter which ExtensionSessions to update
     */
    where?: ExtensionSessionWhereInput
    /**
     * Limit how many ExtensionSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ExtensionSession upsert
   */
  export type ExtensionSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the ExtensionSession to update in case it exists.
     */
    where: ExtensionSessionWhereUniqueInput
    /**
     * In case the ExtensionSession found by the `where` argument doesn't exist, create a new ExtensionSession with this data.
     */
    create: XOR<ExtensionSessionCreateInput, ExtensionSessionUncheckedCreateInput>
    /**
     * In case the ExtensionSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExtensionSessionUpdateInput, ExtensionSessionUncheckedUpdateInput>
  }

  /**
   * ExtensionSession delete
   */
  export type ExtensionSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
    /**
     * Filter which ExtensionSession to delete.
     */
    where: ExtensionSessionWhereUniqueInput
  }

  /**
   * ExtensionSession deleteMany
   */
  export type ExtensionSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExtensionSessions to delete
     */
    where?: ExtensionSessionWhereInput
    /**
     * Limit how many ExtensionSessions to delete.
     */
    limit?: number
  }

  /**
   * ExtensionSession without action
   */
  export type ExtensionSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExtensionSession
     */
    select?: ExtensionSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ExtensionSession
     */
    omit?: ExtensionSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExtensionSessionInclude<ExtArgs> | null
  }


  /**
   * Model UsageMetrics
   */

  export type AggregateUsageMetrics = {
    _count: UsageMetricsCountAggregateOutputType | null
    _avg: UsageMetricsAvgAggregateOutputType | null
    _sum: UsageMetricsSumAggregateOutputType | null
    _min: UsageMetricsMinAggregateOutputType | null
    _max: UsageMetricsMaxAggregateOutputType | null
  }

  export type UsageMetricsAvgAggregateOutputType = {
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
  }

  export type UsageMetricsSumAggregateOutputType = {
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
  }

  export type UsageMetricsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
    date: Date | null
  }

  export type UsageMetricsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
    date: Date | null
  }

  export type UsageMetricsCountAggregateOutputType = {
    id: number
    userId: number
    tokensUsed: number
    inputTokens: number
    outputTokens: number
    cacheReadTokens: number
    cacheWriteTokens: number
    cubentUnitsUsed: number
    requestsMade: number
    costAccrued: number
    date: number
    _all: number
  }


  export type UsageMetricsAvgAggregateInputType = {
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
  }

  export type UsageMetricsSumAggregateInputType = {
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
  }

  export type UsageMetricsMinAggregateInputType = {
    id?: true
    userId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    date?: true
  }

  export type UsageMetricsMaxAggregateInputType = {
    id?: true
    userId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    date?: true
  }

  export type UsageMetricsCountAggregateInputType = {
    id?: true
    userId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    date?: true
    _all?: true
  }

  export type UsageMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetrics to aggregate.
     */
    where?: UsageMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricsOrderByWithRelationInput | UsageMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageMetrics
    **/
    _count?: true | UsageMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageMetricsMaxAggregateInputType
  }

  export type GetUsageMetricsAggregateType<T extends UsageMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageMetrics[P]>
      : GetScalarType<T[P], AggregateUsageMetrics[P]>
  }




  export type UsageMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageMetricsWhereInput
    orderBy?: UsageMetricsOrderByWithAggregationInput | UsageMetricsOrderByWithAggregationInput[]
    by: UsageMetricsScalarFieldEnum[] | UsageMetricsScalarFieldEnum
    having?: UsageMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageMetricsCountAggregateInputType | true
    _avg?: UsageMetricsAvgAggregateInputType
    _sum?: UsageMetricsSumAggregateInputType
    _min?: UsageMetricsMinAggregateInputType
    _max?: UsageMetricsMaxAggregateInputType
  }

  export type UsageMetricsGroupByOutputType = {
    id: string
    userId: string
    tokensUsed: number
    inputTokens: number
    outputTokens: number
    cacheReadTokens: number
    cacheWriteTokens: number
    cubentUnitsUsed: number
    requestsMade: number
    costAccrued: number
    date: Date
    _count: UsageMetricsCountAggregateOutputType | null
    _avg: UsageMetricsAvgAggregateOutputType | null
    _sum: UsageMetricsSumAggregateOutputType | null
    _min: UsageMetricsMinAggregateOutputType | null
    _max: UsageMetricsMaxAggregateOutputType | null
  }

  type GetUsageMetricsGroupByPayload<T extends UsageMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], UsageMetricsGroupByOutputType[P]>
        }
      >
    >


  export type UsageMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMetrics"]>

  export type UsageMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMetrics"]>

  export type UsageMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageMetrics"]>

  export type UsageMetricsSelectScalar = {
    id?: boolean
    userId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    date?: boolean
  }

  export type UsageMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tokensUsed" | "inputTokens" | "outputTokens" | "cacheReadTokens" | "cacheWriteTokens" | "cubentUnitsUsed" | "requestsMade" | "costAccrued" | "date", ExtArgs["result"]["usageMetrics"]>
  export type UsageMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageMetrics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tokensUsed: number
      inputTokens: number
      outputTokens: number
      cacheReadTokens: number
      cacheWriteTokens: number
      cubentUnitsUsed: number
      requestsMade: number
      costAccrued: number
      date: Date
    }, ExtArgs["result"]["usageMetrics"]>
    composites: {}
  }

  type UsageMetricsGetPayload<S extends boolean | null | undefined | UsageMetricsDefaultArgs> = $Result.GetResult<Prisma.$UsageMetricsPayload, S>

  type UsageMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageMetricsCountAggregateInputType | true
    }

  export interface UsageMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageMetrics'], meta: { name: 'UsageMetrics' } }
    /**
     * Find zero or one UsageMetrics that matches the filter.
     * @param {UsageMetricsFindUniqueArgs} args - Arguments to find a UsageMetrics
     * @example
     * // Get one UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageMetricsFindUniqueArgs>(args: SelectSubset<T, UsageMetricsFindUniqueArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UsageMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageMetricsFindUniqueOrThrowArgs} args - Arguments to find a UsageMetrics
     * @example
     * // Get one UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsFindFirstArgs} args - Arguments to find a UsageMetrics
     * @example
     * // Get one UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageMetricsFindFirstArgs>(args?: SelectSubset<T, UsageMetricsFindFirstArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UsageMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsFindFirstOrThrowArgs} args - Arguments to find a UsageMetrics
     * @example
     * // Get one UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UsageMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findMany()
     * 
     * // Get first 10 UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageMetricsWithIdOnly = await prisma.usageMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageMetricsFindManyArgs>(args?: SelectSubset<T, UsageMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UsageMetrics.
     * @param {UsageMetricsCreateArgs} args - Arguments to create a UsageMetrics.
     * @example
     * // Create one UsageMetrics
     * const UsageMetrics = await prisma.usageMetrics.create({
     *   data: {
     *     // ... data to create a UsageMetrics
     *   }
     * })
     * 
     */
    create<T extends UsageMetricsCreateArgs>(args: SelectSubset<T, UsageMetricsCreateArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UsageMetrics.
     * @param {UsageMetricsCreateManyArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageMetricsCreateManyArgs>(args?: SelectSubset<T, UsageMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageMetrics and returns the data saved in the database.
     * @param {UsageMetricsCreateManyAndReturnArgs} args - Arguments to create many UsageMetrics.
     * @example
     * // Create many UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageMetrics and only return the `id`
     * const usageMetricsWithIdOnly = await prisma.usageMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UsageMetrics.
     * @param {UsageMetricsDeleteArgs} args - Arguments to delete one UsageMetrics.
     * @example
     * // Delete one UsageMetrics
     * const UsageMetrics = await prisma.usageMetrics.delete({
     *   where: {
     *     // ... filter to delete one UsageMetrics
     *   }
     * })
     * 
     */
    delete<T extends UsageMetricsDeleteArgs>(args: SelectSubset<T, UsageMetricsDeleteArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UsageMetrics.
     * @param {UsageMetricsUpdateArgs} args - Arguments to update one UsageMetrics.
     * @example
     * // Update one UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageMetricsUpdateArgs>(args: SelectSubset<T, UsageMetricsUpdateArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UsageMetrics.
     * @param {UsageMetricsDeleteManyArgs} args - Arguments to filter UsageMetrics to delete.
     * @example
     * // Delete a few UsageMetrics
     * const { count } = await prisma.usageMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageMetricsDeleteManyArgs>(args?: SelectSubset<T, UsageMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageMetricsUpdateManyArgs>(args: SelectSubset<T, UsageMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageMetrics and returns the data updated in the database.
     * @param {UsageMetricsUpdateManyAndReturnArgs} args - Arguments to update many UsageMetrics.
     * @example
     * // Update many UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageMetrics and only return the `id`
     * const usageMetricsWithIdOnly = await prisma.usageMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UsageMetrics.
     * @param {UsageMetricsUpsertArgs} args - Arguments to update or create a UsageMetrics.
     * @example
     * // Update or create a UsageMetrics
     * const usageMetrics = await prisma.usageMetrics.upsert({
     *   create: {
     *     // ... data to create a UsageMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageMetrics we want to update
     *   }
     * })
     */
    upsert<T extends UsageMetricsUpsertArgs>(args: SelectSubset<T, UsageMetricsUpsertArgs<ExtArgs>>): Prisma__UsageMetricsClient<$Result.GetResult<Prisma.$UsageMetricsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsCountArgs} args - Arguments to filter UsageMetrics to count.
     * @example
     * // Count the number of UsageMetrics
     * const count = await prisma.usageMetrics.count({
     *   where: {
     *     // ... the filter for the UsageMetrics we want to count
     *   }
     * })
    **/
    count<T extends UsageMetricsCountArgs>(
      args?: Subset<T, UsageMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageMetricsAggregateArgs>(args: Subset<T, UsageMetricsAggregateArgs>): Prisma.PrismaPromise<GetUsageMetricsAggregateType<T>>

    /**
     * Group by UsageMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageMetricsGroupByArgs['orderBy'] }
        : { orderBy?: UsageMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageMetrics model
   */
  readonly fields: UsageMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageMetrics model
   */ 
  interface UsageMetricsFieldRefs {
    readonly id: FieldRef<"UsageMetrics", 'String'>
    readonly userId: FieldRef<"UsageMetrics", 'String'>
    readonly tokensUsed: FieldRef<"UsageMetrics", 'Int'>
    readonly inputTokens: FieldRef<"UsageMetrics", 'Int'>
    readonly outputTokens: FieldRef<"UsageMetrics", 'Int'>
    readonly cacheReadTokens: FieldRef<"UsageMetrics", 'Int'>
    readonly cacheWriteTokens: FieldRef<"UsageMetrics", 'Int'>
    readonly cubentUnitsUsed: FieldRef<"UsageMetrics", 'Float'>
    readonly requestsMade: FieldRef<"UsageMetrics", 'Int'>
    readonly costAccrued: FieldRef<"UsageMetrics", 'Float'>
    readonly date: FieldRef<"UsageMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageMetrics findUnique
   */
  export type UsageMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where: UsageMetricsWhereUniqueInput
  }

  /**
   * UsageMetrics findUniqueOrThrow
   */
  export type UsageMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where: UsageMetricsWhereUniqueInput
  }

  /**
   * UsageMetrics findFirst
   */
  export type UsageMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricsOrderByWithRelationInput | UsageMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricsScalarFieldEnum | UsageMetricsScalarFieldEnum[]
  }

  /**
   * UsageMetrics findFirstOrThrow
   */
  export type UsageMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricsOrderByWithRelationInput | UsageMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageMetrics.
     */
    cursor?: UsageMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageMetrics.
     */
    distinct?: UsageMetricsScalarFieldEnum | UsageMetricsScalarFieldEnum[]
  }

  /**
   * UsageMetrics findMany
   */
  export type UsageMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter, which UsageMetrics to fetch.
     */
    where?: UsageMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageMetrics to fetch.
     */
    orderBy?: UsageMetricsOrderByWithRelationInput | UsageMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageMetrics.
     */
    cursor?: UsageMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageMetrics.
     */
    skip?: number
    distinct?: UsageMetricsScalarFieldEnum | UsageMetricsScalarFieldEnum[]
  }

  /**
   * UsageMetrics create
   */
  export type UsageMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageMetrics.
     */
    data: XOR<UsageMetricsCreateInput, UsageMetricsUncheckedCreateInput>
  }

  /**
   * UsageMetrics createMany
   */
  export type UsageMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricsCreateManyInput | UsageMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageMetrics createManyAndReturn
   */
  export type UsageMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many UsageMetrics.
     */
    data: UsageMetricsCreateManyInput | UsageMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageMetrics update
   */
  export type UsageMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageMetrics.
     */
    data: XOR<UsageMetricsUpdateInput, UsageMetricsUncheckedUpdateInput>
    /**
     * Choose, which UsageMetrics to update.
     */
    where: UsageMetricsWhereUniqueInput
  }

  /**
   * UsageMetrics updateMany
   */
  export type UsageMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricsUpdateManyMutationInput, UsageMetricsUncheckedUpdateManyInput>
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricsWhereInput
    /**
     * Limit how many UsageMetrics to update.
     */
    limit?: number
  }

  /**
   * UsageMetrics updateManyAndReturn
   */
  export type UsageMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * The data used to update UsageMetrics.
     */
    data: XOR<UsageMetricsUpdateManyMutationInput, UsageMetricsUncheckedUpdateManyInput>
    /**
     * Filter which UsageMetrics to update
     */
    where?: UsageMetricsWhereInput
    /**
     * Limit how many UsageMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageMetrics upsert
   */
  export type UsageMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageMetrics to update in case it exists.
     */
    where: UsageMetricsWhereUniqueInput
    /**
     * In case the UsageMetrics found by the `where` argument doesn't exist, create a new UsageMetrics with this data.
     */
    create: XOR<UsageMetricsCreateInput, UsageMetricsUncheckedCreateInput>
    /**
     * In case the UsageMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageMetricsUpdateInput, UsageMetricsUncheckedUpdateInput>
  }

  /**
   * UsageMetrics delete
   */
  export type UsageMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
    /**
     * Filter which UsageMetrics to delete.
     */
    where: UsageMetricsWhereUniqueInput
  }

  /**
   * UsageMetrics deleteMany
   */
  export type UsageMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageMetrics to delete
     */
    where?: UsageMetricsWhereInput
    /**
     * Limit how many UsageMetrics to delete.
     */
    limit?: number
  }

  /**
   * UsageMetrics without action
   */
  export type UsageMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageMetrics
     */
    select?: UsageMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageMetrics
     */
    omit?: UsageMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageMetricsInclude<ExtArgs> | null
  }


  /**
   * Model UsageAnalytics
   */

  export type AggregateUsageAnalytics = {
    _count: UsageAnalyticsCountAggregateOutputType | null
    _avg: UsageAnalyticsAvgAggregateOutputType | null
    _sum: UsageAnalyticsSumAggregateOutputType | null
    _min: UsageAnalyticsMinAggregateOutputType | null
    _max: UsageAnalyticsMaxAggregateOutputType | null
  }

  export type UsageAnalyticsAvgAggregateOutputType = {
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
  }

  export type UsageAnalyticsSumAggregateOutputType = {
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
  }

  export type UsageAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    modelId: string | null
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type UsageAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    modelId: string | null
    tokensUsed: number | null
    inputTokens: number | null
    outputTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    cubentUnitsUsed: number | null
    requestsMade: number | null
    costAccrued: number | null
    sessionId: string | null
    createdAt: Date | null
  }

  export type UsageAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    modelId: number
    tokensUsed: number
    inputTokens: number
    outputTokens: number
    cacheReadTokens: number
    cacheWriteTokens: number
    cubentUnitsUsed: number
    requestsMade: number
    costAccrued: number
    sessionId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type UsageAnalyticsAvgAggregateInputType = {
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
  }

  export type UsageAnalyticsSumAggregateInputType = {
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
  }

  export type UsageAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    sessionId?: true
    createdAt?: true
  }

  export type UsageAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    sessionId?: true
    createdAt?: true
  }

  export type UsageAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    tokensUsed?: true
    inputTokens?: true
    outputTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    cubentUnitsUsed?: true
    requestsMade?: true
    costAccrued?: true
    sessionId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type UsageAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageAnalytics to aggregate.
     */
    where?: UsageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageAnalytics to fetch.
     */
    orderBy?: UsageAnalyticsOrderByWithRelationInput | UsageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageAnalytics
    **/
    _count?: true | UsageAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageAnalyticsMaxAggregateInputType
  }

  export type GetUsageAnalyticsAggregateType<T extends UsageAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageAnalytics[P]>
      : GetScalarType<T[P], AggregateUsageAnalytics[P]>
  }




  export type UsageAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageAnalyticsWhereInput
    orderBy?: UsageAnalyticsOrderByWithAggregationInput | UsageAnalyticsOrderByWithAggregationInput[]
    by: UsageAnalyticsScalarFieldEnum[] | UsageAnalyticsScalarFieldEnum
    having?: UsageAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageAnalyticsCountAggregateInputType | true
    _avg?: UsageAnalyticsAvgAggregateInputType
    _sum?: UsageAnalyticsSumAggregateInputType
    _min?: UsageAnalyticsMinAggregateInputType
    _max?: UsageAnalyticsMaxAggregateInputType
  }

  export type UsageAnalyticsGroupByOutputType = {
    id: string
    userId: string
    modelId: string
    tokensUsed: number
    inputTokens: number
    outputTokens: number
    cacheReadTokens: number
    cacheWriteTokens: number
    cubentUnitsUsed: number
    requestsMade: number
    costAccrued: number
    sessionId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: UsageAnalyticsCountAggregateOutputType | null
    _avg: UsageAnalyticsAvgAggregateOutputType | null
    _sum: UsageAnalyticsSumAggregateOutputType | null
    _min: UsageAnalyticsMinAggregateOutputType | null
    _max: UsageAnalyticsMaxAggregateOutputType | null
  }

  type GetUsageAnalyticsGroupByPayload<T extends UsageAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], UsageAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type UsageAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    sessionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageAnalytics"]>

  export type UsageAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    sessionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageAnalytics"]>

  export type UsageAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    sessionId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageAnalytics"]>

  export type UsageAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    modelId?: boolean
    tokensUsed?: boolean
    inputTokens?: boolean
    outputTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    cubentUnitsUsed?: boolean
    requestsMade?: boolean
    costAccrued?: boolean
    sessionId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type UsageAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "modelId" | "tokensUsed" | "inputTokens" | "outputTokens" | "cacheReadTokens" | "cacheWriteTokens" | "cubentUnitsUsed" | "requestsMade" | "costAccrued" | "sessionId" | "metadata" | "createdAt", ExtArgs["result"]["usageAnalytics"]>
  export type UsageAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UsageAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UsageAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      modelId: string
      tokensUsed: number
      inputTokens: number
      outputTokens: number
      cacheReadTokens: number
      cacheWriteTokens: number
      cubentUnitsUsed: number
      requestsMade: number
      costAccrued: number
      sessionId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["usageAnalytics"]>
    composites: {}
  }

  type UsageAnalyticsGetPayload<S extends boolean | null | undefined | UsageAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$UsageAnalyticsPayload, S>

  type UsageAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageAnalyticsCountAggregateInputType | true
    }

  export interface UsageAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageAnalytics'], meta: { name: 'UsageAnalytics' } }
    /**
     * Find zero or one UsageAnalytics that matches the filter.
     * @param {UsageAnalyticsFindUniqueArgs} args - Arguments to find a UsageAnalytics
     * @example
     * // Get one UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageAnalyticsFindUniqueArgs>(args: SelectSubset<T, UsageAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UsageAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a UsageAnalytics
     * @example
     * // Get one UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UsageAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsFindFirstArgs} args - Arguments to find a UsageAnalytics
     * @example
     * // Get one UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageAnalyticsFindFirstArgs>(args?: SelectSubset<T, UsageAnalyticsFindFirstArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UsageAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsFindFirstOrThrowArgs} args - Arguments to find a UsageAnalytics
     * @example
     * // Get one UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UsageAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findMany()
     * 
     * // Get first 10 UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageAnalyticsWithIdOnly = await prisma.usageAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageAnalyticsFindManyArgs>(args?: SelectSubset<T, UsageAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UsageAnalytics.
     * @param {UsageAnalyticsCreateArgs} args - Arguments to create a UsageAnalytics.
     * @example
     * // Create one UsageAnalytics
     * const UsageAnalytics = await prisma.usageAnalytics.create({
     *   data: {
     *     // ... data to create a UsageAnalytics
     *   }
     * })
     * 
     */
    create<T extends UsageAnalyticsCreateArgs>(args: SelectSubset<T, UsageAnalyticsCreateArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UsageAnalytics.
     * @param {UsageAnalyticsCreateManyArgs} args - Arguments to create many UsageAnalytics.
     * @example
     * // Create many UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageAnalyticsCreateManyArgs>(args?: SelectSubset<T, UsageAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageAnalytics and returns the data saved in the database.
     * @param {UsageAnalyticsCreateManyAndReturnArgs} args - Arguments to create many UsageAnalytics.
     * @example
     * // Create many UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageAnalytics and only return the `id`
     * const usageAnalyticsWithIdOnly = await prisma.usageAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UsageAnalytics.
     * @param {UsageAnalyticsDeleteArgs} args - Arguments to delete one UsageAnalytics.
     * @example
     * // Delete one UsageAnalytics
     * const UsageAnalytics = await prisma.usageAnalytics.delete({
     *   where: {
     *     // ... filter to delete one UsageAnalytics
     *   }
     * })
     * 
     */
    delete<T extends UsageAnalyticsDeleteArgs>(args: SelectSubset<T, UsageAnalyticsDeleteArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UsageAnalytics.
     * @param {UsageAnalyticsUpdateArgs} args - Arguments to update one UsageAnalytics.
     * @example
     * // Update one UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageAnalyticsUpdateArgs>(args: SelectSubset<T, UsageAnalyticsUpdateArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UsageAnalytics.
     * @param {UsageAnalyticsDeleteManyArgs} args - Arguments to filter UsageAnalytics to delete.
     * @example
     * // Delete a few UsageAnalytics
     * const { count } = await prisma.usageAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageAnalyticsDeleteManyArgs>(args?: SelectSubset<T, UsageAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageAnalyticsUpdateManyArgs>(args: SelectSubset<T, UsageAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageAnalytics and returns the data updated in the database.
     * @param {UsageAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many UsageAnalytics.
     * @example
     * // Update many UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageAnalytics and only return the `id`
     * const usageAnalyticsWithIdOnly = await prisma.usageAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UsageAnalytics.
     * @param {UsageAnalyticsUpsertArgs} args - Arguments to update or create a UsageAnalytics.
     * @example
     * // Update or create a UsageAnalytics
     * const usageAnalytics = await prisma.usageAnalytics.upsert({
     *   create: {
     *     // ... data to create a UsageAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends UsageAnalyticsUpsertArgs>(args: SelectSubset<T, UsageAnalyticsUpsertArgs<ExtArgs>>): Prisma__UsageAnalyticsClient<$Result.GetResult<Prisma.$UsageAnalyticsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UsageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsCountArgs} args - Arguments to filter UsageAnalytics to count.
     * @example
     * // Count the number of UsageAnalytics
     * const count = await prisma.usageAnalytics.count({
     *   where: {
     *     // ... the filter for the UsageAnalytics we want to count
     *   }
     * })
    **/
    count<T extends UsageAnalyticsCountArgs>(
      args?: Subset<T, UsageAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageAnalyticsAggregateArgs>(args: Subset<T, UsageAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetUsageAnalyticsAggregateType<T>>

    /**
     * Group by UsageAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: UsageAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageAnalytics model
   */
  readonly fields: UsageAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageAnalytics model
   */ 
  interface UsageAnalyticsFieldRefs {
    readonly id: FieldRef<"UsageAnalytics", 'String'>
    readonly userId: FieldRef<"UsageAnalytics", 'String'>
    readonly modelId: FieldRef<"UsageAnalytics", 'String'>
    readonly tokensUsed: FieldRef<"UsageAnalytics", 'Int'>
    readonly inputTokens: FieldRef<"UsageAnalytics", 'Int'>
    readonly outputTokens: FieldRef<"UsageAnalytics", 'Int'>
    readonly cacheReadTokens: FieldRef<"UsageAnalytics", 'Int'>
    readonly cacheWriteTokens: FieldRef<"UsageAnalytics", 'Int'>
    readonly cubentUnitsUsed: FieldRef<"UsageAnalytics", 'Float'>
    readonly requestsMade: FieldRef<"UsageAnalytics", 'Int'>
    readonly costAccrued: FieldRef<"UsageAnalytics", 'Float'>
    readonly sessionId: FieldRef<"UsageAnalytics", 'String'>
    readonly metadata: FieldRef<"UsageAnalytics", 'Json'>
    readonly createdAt: FieldRef<"UsageAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageAnalytics findUnique
   */
  export type UsageAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UsageAnalytics to fetch.
     */
    where: UsageAnalyticsWhereUniqueInput
  }

  /**
   * UsageAnalytics findUniqueOrThrow
   */
  export type UsageAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UsageAnalytics to fetch.
     */
    where: UsageAnalyticsWhereUniqueInput
  }

  /**
   * UsageAnalytics findFirst
   */
  export type UsageAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UsageAnalytics to fetch.
     */
    where?: UsageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageAnalytics to fetch.
     */
    orderBy?: UsageAnalyticsOrderByWithRelationInput | UsageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageAnalytics.
     */
    cursor?: UsageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageAnalytics.
     */
    distinct?: UsageAnalyticsScalarFieldEnum | UsageAnalyticsScalarFieldEnum[]
  }

  /**
   * UsageAnalytics findFirstOrThrow
   */
  export type UsageAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UsageAnalytics to fetch.
     */
    where?: UsageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageAnalytics to fetch.
     */
    orderBy?: UsageAnalyticsOrderByWithRelationInput | UsageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageAnalytics.
     */
    cursor?: UsageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageAnalytics.
     */
    distinct?: UsageAnalyticsScalarFieldEnum | UsageAnalyticsScalarFieldEnum[]
  }

  /**
   * UsageAnalytics findMany
   */
  export type UsageAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which UsageAnalytics to fetch.
     */
    where?: UsageAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageAnalytics to fetch.
     */
    orderBy?: UsageAnalyticsOrderByWithRelationInput | UsageAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageAnalytics.
     */
    cursor?: UsageAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageAnalytics.
     */
    skip?: number
    distinct?: UsageAnalyticsScalarFieldEnum | UsageAnalyticsScalarFieldEnum[]
  }

  /**
   * UsageAnalytics create
   */
  export type UsageAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageAnalytics.
     */
    data: XOR<UsageAnalyticsCreateInput, UsageAnalyticsUncheckedCreateInput>
  }

  /**
   * UsageAnalytics createMany
   */
  export type UsageAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageAnalytics.
     */
    data: UsageAnalyticsCreateManyInput | UsageAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageAnalytics createManyAndReturn
   */
  export type UsageAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many UsageAnalytics.
     */
    data: UsageAnalyticsCreateManyInput | UsageAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageAnalytics update
   */
  export type UsageAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageAnalytics.
     */
    data: XOR<UsageAnalyticsUpdateInput, UsageAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which UsageAnalytics to update.
     */
    where: UsageAnalyticsWhereUniqueInput
  }

  /**
   * UsageAnalytics updateMany
   */
  export type UsageAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageAnalytics.
     */
    data: XOR<UsageAnalyticsUpdateManyMutationInput, UsageAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UsageAnalytics to update
     */
    where?: UsageAnalyticsWhereInput
    /**
     * Limit how many UsageAnalytics to update.
     */
    limit?: number
  }

  /**
   * UsageAnalytics updateManyAndReturn
   */
  export type UsageAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update UsageAnalytics.
     */
    data: XOR<UsageAnalyticsUpdateManyMutationInput, UsageAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which UsageAnalytics to update
     */
    where?: UsageAnalyticsWhereInput
    /**
     * Limit how many UsageAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageAnalytics upsert
   */
  export type UsageAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageAnalytics to update in case it exists.
     */
    where: UsageAnalyticsWhereUniqueInput
    /**
     * In case the UsageAnalytics found by the `where` argument doesn't exist, create a new UsageAnalytics with this data.
     */
    create: XOR<UsageAnalyticsCreateInput, UsageAnalyticsUncheckedCreateInput>
    /**
     * In case the UsageAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageAnalyticsUpdateInput, UsageAnalyticsUncheckedUpdateInput>
  }

  /**
   * UsageAnalytics delete
   */
  export type UsageAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which UsageAnalytics to delete.
     */
    where: UsageAnalyticsWhereUniqueInput
  }

  /**
   * UsageAnalytics deleteMany
   */
  export type UsageAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageAnalytics to delete
     */
    where?: UsageAnalyticsWhereInput
    /**
     * Limit how many UsageAnalytics to delete.
     */
    limit?: number
  }

  /**
   * UsageAnalytics without action
   */
  export type UsageAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageAnalytics
     */
    select?: UsageAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageAnalytics
     */
    omit?: UsageAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model AutocompleteAnalytics
   */

  export type AggregateAutocompleteAnalytics = {
    _count: AutocompleteAnalyticsCountAggregateOutputType | null
    _avg: AutocompleteAnalyticsAvgAggregateOutputType | null
    _sum: AutocompleteAnalyticsSumAggregateOutputType | null
    _min: AutocompleteAnalyticsMinAggregateOutputType | null
    _max: AutocompleteAnalyticsMaxAggregateOutputType | null
  }

  export type AutocompleteAnalyticsAvgAggregateOutputType = {
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    successRate: number | null
    acceptanceRate: number | null
  }

  export type AutocompleteAnalyticsSumAggregateOutputType = {
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    successRate: number | null
    acceptanceRate: number | null
  }

  export type AutocompleteAnalyticsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    modelId: string | null
    provider: string | null
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    language: string | null
    filepath: string | null
    sessionId: string | null
    avgLatency: number | null
    successRate: number | null
    acceptanceRate: number | null
    createdAt: Date | null
  }

  export type AutocompleteAnalyticsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    modelId: string | null
    provider: string | null
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    language: string | null
    filepath: string | null
    sessionId: string | null
    avgLatency: number | null
    successRate: number | null
    acceptanceRate: number | null
    createdAt: Date | null
  }

  export type AutocompleteAnalyticsCountAggregateOutputType = {
    id: number
    userId: number
    modelId: number
    provider: number
    completionsGenerated: number
    completionsAccepted: number
    linesAdded: number
    charactersAdded: number
    language: number
    filepath: number
    sessionId: number
    avgLatency: number
    successRate: number
    acceptanceRate: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AutocompleteAnalyticsAvgAggregateInputType = {
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    successRate?: true
    acceptanceRate?: true
  }

  export type AutocompleteAnalyticsSumAggregateInputType = {
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    successRate?: true
    acceptanceRate?: true
  }

  export type AutocompleteAnalyticsMinAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    provider?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    language?: true
    filepath?: true
    sessionId?: true
    avgLatency?: true
    successRate?: true
    acceptanceRate?: true
    createdAt?: true
  }

  export type AutocompleteAnalyticsMaxAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    provider?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    language?: true
    filepath?: true
    sessionId?: true
    avgLatency?: true
    successRate?: true
    acceptanceRate?: true
    createdAt?: true
  }

  export type AutocompleteAnalyticsCountAggregateInputType = {
    id?: true
    userId?: true
    modelId?: true
    provider?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    language?: true
    filepath?: true
    sessionId?: true
    avgLatency?: true
    successRate?: true
    acceptanceRate?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AutocompleteAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutocompleteAnalytics to aggregate.
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteAnalytics to fetch.
     */
    orderBy?: AutocompleteAnalyticsOrderByWithRelationInput | AutocompleteAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutocompleteAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutocompleteAnalytics
    **/
    _count?: true | AutocompleteAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutocompleteAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutocompleteAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutocompleteAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutocompleteAnalyticsMaxAggregateInputType
  }

  export type GetAutocompleteAnalyticsAggregateType<T extends AutocompleteAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregateAutocompleteAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutocompleteAnalytics[P]>
      : GetScalarType<T[P], AggregateAutocompleteAnalytics[P]>
  }




  export type AutocompleteAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutocompleteAnalyticsWhereInput
    orderBy?: AutocompleteAnalyticsOrderByWithAggregationInput | AutocompleteAnalyticsOrderByWithAggregationInput[]
    by: AutocompleteAnalyticsScalarFieldEnum[] | AutocompleteAnalyticsScalarFieldEnum
    having?: AutocompleteAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutocompleteAnalyticsCountAggregateInputType | true
    _avg?: AutocompleteAnalyticsAvgAggregateInputType
    _sum?: AutocompleteAnalyticsSumAggregateInputType
    _min?: AutocompleteAnalyticsMinAggregateInputType
    _max?: AutocompleteAnalyticsMaxAggregateInputType
  }

  export type AutocompleteAnalyticsGroupByOutputType = {
    id: string
    userId: string
    modelId: string
    provider: string
    completionsGenerated: number
    completionsAccepted: number
    linesAdded: number
    charactersAdded: number
    language: string | null
    filepath: string | null
    sessionId: string | null
    avgLatency: number | null
    successRate: number | null
    acceptanceRate: number | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AutocompleteAnalyticsCountAggregateOutputType | null
    _avg: AutocompleteAnalyticsAvgAggregateOutputType | null
    _sum: AutocompleteAnalyticsSumAggregateOutputType | null
    _min: AutocompleteAnalyticsMinAggregateOutputType | null
    _max: AutocompleteAnalyticsMaxAggregateOutputType | null
  }

  type GetAutocompleteAnalyticsGroupByPayload<T extends AutocompleteAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutocompleteAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutocompleteAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutocompleteAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], AutocompleteAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type AutocompleteAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    provider?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    language?: boolean
    filepath?: boolean
    sessionId?: boolean
    avgLatency?: boolean
    successRate?: boolean
    acceptanceRate?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteAnalytics"]>

  export type AutocompleteAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    provider?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    language?: boolean
    filepath?: boolean
    sessionId?: boolean
    avgLatency?: boolean
    successRate?: boolean
    acceptanceRate?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteAnalytics"]>

  export type AutocompleteAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    modelId?: boolean
    provider?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    language?: boolean
    filepath?: boolean
    sessionId?: boolean
    avgLatency?: boolean
    successRate?: boolean
    acceptanceRate?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteAnalytics"]>

  export type AutocompleteAnalyticsSelectScalar = {
    id?: boolean
    userId?: boolean
    modelId?: boolean
    provider?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    language?: boolean
    filepath?: boolean
    sessionId?: boolean
    avgLatency?: boolean
    successRate?: boolean
    acceptanceRate?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AutocompleteAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "modelId" | "provider" | "completionsGenerated" | "completionsAccepted" | "linesAdded" | "charactersAdded" | "language" | "filepath" | "sessionId" | "avgLatency" | "successRate" | "acceptanceRate" | "metadata" | "createdAt", ExtArgs["result"]["autocompleteAnalytics"]>
  export type AutocompleteAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutocompleteAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutocompleteAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutocompleteAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutocompleteAnalytics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      modelId: string
      provider: string
      completionsGenerated: number
      completionsAccepted: number
      linesAdded: number
      charactersAdded: number
      language: string | null
      filepath: string | null
      sessionId: string | null
      avgLatency: number | null
      successRate: number | null
      acceptanceRate: number | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["autocompleteAnalytics"]>
    composites: {}
  }

  type AutocompleteAnalyticsGetPayload<S extends boolean | null | undefined | AutocompleteAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$AutocompleteAnalyticsPayload, S>

  type AutocompleteAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutocompleteAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutocompleteAnalyticsCountAggregateInputType | true
    }

  export interface AutocompleteAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutocompleteAnalytics'], meta: { name: 'AutocompleteAnalytics' } }
    /**
     * Find zero or one AutocompleteAnalytics that matches the filter.
     * @param {AutocompleteAnalyticsFindUniqueArgs} args - Arguments to find a AutocompleteAnalytics
     * @example
     * // Get one AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutocompleteAnalyticsFindUniqueArgs>(args: SelectSubset<T, AutocompleteAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AutocompleteAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutocompleteAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a AutocompleteAnalytics
     * @example
     * // Get one AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutocompleteAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, AutocompleteAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AutocompleteAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsFindFirstArgs} args - Arguments to find a AutocompleteAnalytics
     * @example
     * // Get one AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutocompleteAnalyticsFindFirstArgs>(args?: SelectSubset<T, AutocompleteAnalyticsFindFirstArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AutocompleteAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsFindFirstOrThrowArgs} args - Arguments to find a AutocompleteAnalytics
     * @example
     * // Get one AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutocompleteAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, AutocompleteAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AutocompleteAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findMany()
     * 
     * // Get first 10 AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autocompleteAnalyticsWithIdOnly = await prisma.autocompleteAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutocompleteAnalyticsFindManyArgs>(args?: SelectSubset<T, AutocompleteAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsCreateArgs} args - Arguments to create a AutocompleteAnalytics.
     * @example
     * // Create one AutocompleteAnalytics
     * const AutocompleteAnalytics = await prisma.autocompleteAnalytics.create({
     *   data: {
     *     // ... data to create a AutocompleteAnalytics
     *   }
     * })
     * 
     */
    create<T extends AutocompleteAnalyticsCreateArgs>(args: SelectSubset<T, AutocompleteAnalyticsCreateArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsCreateManyArgs} args - Arguments to create many AutocompleteAnalytics.
     * @example
     * // Create many AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutocompleteAnalyticsCreateManyArgs>(args?: SelectSubset<T, AutocompleteAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutocompleteAnalytics and returns the data saved in the database.
     * @param {AutocompleteAnalyticsCreateManyAndReturnArgs} args - Arguments to create many AutocompleteAnalytics.
     * @example
     * // Create many AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutocompleteAnalytics and only return the `id`
     * const autocompleteAnalyticsWithIdOnly = await prisma.autocompleteAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutocompleteAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, AutocompleteAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsDeleteArgs} args - Arguments to delete one AutocompleteAnalytics.
     * @example
     * // Delete one AutocompleteAnalytics
     * const AutocompleteAnalytics = await prisma.autocompleteAnalytics.delete({
     *   where: {
     *     // ... filter to delete one AutocompleteAnalytics
     *   }
     * })
     * 
     */
    delete<T extends AutocompleteAnalyticsDeleteArgs>(args: SelectSubset<T, AutocompleteAnalyticsDeleteArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsUpdateArgs} args - Arguments to update one AutocompleteAnalytics.
     * @example
     * // Update one AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutocompleteAnalyticsUpdateArgs>(args: SelectSubset<T, AutocompleteAnalyticsUpdateArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsDeleteManyArgs} args - Arguments to filter AutocompleteAnalytics to delete.
     * @example
     * // Delete a few AutocompleteAnalytics
     * const { count } = await prisma.autocompleteAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutocompleteAnalyticsDeleteManyArgs>(args?: SelectSubset<T, AutocompleteAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutocompleteAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutocompleteAnalyticsUpdateManyArgs>(args: SelectSubset<T, AutocompleteAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutocompleteAnalytics and returns the data updated in the database.
     * @param {AutocompleteAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many AutocompleteAnalytics.
     * @example
     * // Update many AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutocompleteAnalytics and only return the `id`
     * const autocompleteAnalyticsWithIdOnly = await prisma.autocompleteAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutocompleteAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, AutocompleteAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AutocompleteAnalytics.
     * @param {AutocompleteAnalyticsUpsertArgs} args - Arguments to update or create a AutocompleteAnalytics.
     * @example
     * // Update or create a AutocompleteAnalytics
     * const autocompleteAnalytics = await prisma.autocompleteAnalytics.upsert({
     *   create: {
     *     // ... data to create a AutocompleteAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutocompleteAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends AutocompleteAnalyticsUpsertArgs>(args: SelectSubset<T, AutocompleteAnalyticsUpsertArgs<ExtArgs>>): Prisma__AutocompleteAnalyticsClient<$Result.GetResult<Prisma.$AutocompleteAnalyticsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AutocompleteAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsCountArgs} args - Arguments to filter AutocompleteAnalytics to count.
     * @example
     * // Count the number of AutocompleteAnalytics
     * const count = await prisma.autocompleteAnalytics.count({
     *   where: {
     *     // ... the filter for the AutocompleteAnalytics we want to count
     *   }
     * })
    **/
    count<T extends AutocompleteAnalyticsCountArgs>(
      args?: Subset<T, AutocompleteAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutocompleteAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutocompleteAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutocompleteAnalyticsAggregateArgs>(args: Subset<T, AutocompleteAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetAutocompleteAnalyticsAggregateType<T>>

    /**
     * Group by AutocompleteAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutocompleteAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutocompleteAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: AutocompleteAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutocompleteAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutocompleteAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutocompleteAnalytics model
   */
  readonly fields: AutocompleteAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutocompleteAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutocompleteAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutocompleteAnalytics model
   */ 
  interface AutocompleteAnalyticsFieldRefs {
    readonly id: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly userId: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly modelId: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly provider: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly completionsGenerated: FieldRef<"AutocompleteAnalytics", 'Int'>
    readonly completionsAccepted: FieldRef<"AutocompleteAnalytics", 'Int'>
    readonly linesAdded: FieldRef<"AutocompleteAnalytics", 'Int'>
    readonly charactersAdded: FieldRef<"AutocompleteAnalytics", 'Int'>
    readonly language: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly filepath: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly sessionId: FieldRef<"AutocompleteAnalytics", 'String'>
    readonly avgLatency: FieldRef<"AutocompleteAnalytics", 'Float'>
    readonly successRate: FieldRef<"AutocompleteAnalytics", 'Float'>
    readonly acceptanceRate: FieldRef<"AutocompleteAnalytics", 'Float'>
    readonly metadata: FieldRef<"AutocompleteAnalytics", 'Json'>
    readonly createdAt: FieldRef<"AutocompleteAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutocompleteAnalytics findUnique
   */
  export type AutocompleteAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteAnalytics to fetch.
     */
    where: AutocompleteAnalyticsWhereUniqueInput
  }

  /**
   * AutocompleteAnalytics findUniqueOrThrow
   */
  export type AutocompleteAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteAnalytics to fetch.
     */
    where: AutocompleteAnalyticsWhereUniqueInput
  }

  /**
   * AutocompleteAnalytics findFirst
   */
  export type AutocompleteAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteAnalytics to fetch.
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteAnalytics to fetch.
     */
    orderBy?: AutocompleteAnalyticsOrderByWithRelationInput | AutocompleteAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutocompleteAnalytics.
     */
    cursor?: AutocompleteAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutocompleteAnalytics.
     */
    distinct?: AutocompleteAnalyticsScalarFieldEnum | AutocompleteAnalyticsScalarFieldEnum[]
  }

  /**
   * AutocompleteAnalytics findFirstOrThrow
   */
  export type AutocompleteAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteAnalytics to fetch.
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteAnalytics to fetch.
     */
    orderBy?: AutocompleteAnalyticsOrderByWithRelationInput | AutocompleteAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutocompleteAnalytics.
     */
    cursor?: AutocompleteAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutocompleteAnalytics.
     */
    distinct?: AutocompleteAnalyticsScalarFieldEnum | AutocompleteAnalyticsScalarFieldEnum[]
  }

  /**
   * AutocompleteAnalytics findMany
   */
  export type AutocompleteAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteAnalytics to fetch.
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteAnalytics to fetch.
     */
    orderBy?: AutocompleteAnalyticsOrderByWithRelationInput | AutocompleteAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutocompleteAnalytics.
     */
    cursor?: AutocompleteAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteAnalytics.
     */
    skip?: number
    distinct?: AutocompleteAnalyticsScalarFieldEnum | AutocompleteAnalyticsScalarFieldEnum[]
  }

  /**
   * AutocompleteAnalytics create
   */
  export type AutocompleteAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a AutocompleteAnalytics.
     */
    data: XOR<AutocompleteAnalyticsCreateInput, AutocompleteAnalyticsUncheckedCreateInput>
  }

  /**
   * AutocompleteAnalytics createMany
   */
  export type AutocompleteAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutocompleteAnalytics.
     */
    data: AutocompleteAnalyticsCreateManyInput | AutocompleteAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutocompleteAnalytics createManyAndReturn
   */
  export type AutocompleteAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many AutocompleteAnalytics.
     */
    data: AutocompleteAnalyticsCreateManyInput | AutocompleteAnalyticsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutocompleteAnalytics update
   */
  export type AutocompleteAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a AutocompleteAnalytics.
     */
    data: XOR<AutocompleteAnalyticsUpdateInput, AutocompleteAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which AutocompleteAnalytics to update.
     */
    where: AutocompleteAnalyticsWhereUniqueInput
  }

  /**
   * AutocompleteAnalytics updateMany
   */
  export type AutocompleteAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutocompleteAnalytics.
     */
    data: XOR<AutocompleteAnalyticsUpdateManyMutationInput, AutocompleteAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which AutocompleteAnalytics to update
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * Limit how many AutocompleteAnalytics to update.
     */
    limit?: number
  }

  /**
   * AutocompleteAnalytics updateManyAndReturn
   */
  export type AutocompleteAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update AutocompleteAnalytics.
     */
    data: XOR<AutocompleteAnalyticsUpdateManyMutationInput, AutocompleteAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which AutocompleteAnalytics to update
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * Limit how many AutocompleteAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutocompleteAnalytics upsert
   */
  export type AutocompleteAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the AutocompleteAnalytics to update in case it exists.
     */
    where: AutocompleteAnalyticsWhereUniqueInput
    /**
     * In case the AutocompleteAnalytics found by the `where` argument doesn't exist, create a new AutocompleteAnalytics with this data.
     */
    create: XOR<AutocompleteAnalyticsCreateInput, AutocompleteAnalyticsUncheckedCreateInput>
    /**
     * In case the AutocompleteAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutocompleteAnalyticsUpdateInput, AutocompleteAnalyticsUncheckedUpdateInput>
  }

  /**
   * AutocompleteAnalytics delete
   */
  export type AutocompleteAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which AutocompleteAnalytics to delete.
     */
    where: AutocompleteAnalyticsWhereUniqueInput
  }

  /**
   * AutocompleteAnalytics deleteMany
   */
  export type AutocompleteAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutocompleteAnalytics to delete
     */
    where?: AutocompleteAnalyticsWhereInput
    /**
     * Limit how many AutocompleteAnalytics to delete.
     */
    limit?: number
  }

  /**
   * AutocompleteAnalytics without action
   */
  export type AutocompleteAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteAnalytics
     */
    select?: AutocompleteAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteAnalytics
     */
    omit?: AutocompleteAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model AutocompleteMetrics
   */

  export type AggregateAutocompleteMetrics = {
    _count: AutocompleteMetricsCountAggregateOutputType | null
    _avg: AutocompleteMetricsAvgAggregateOutputType | null
    _sum: AutocompleteMetricsSumAggregateOutputType | null
    _min: AutocompleteMetricsMinAggregateOutputType | null
    _max: AutocompleteMetricsMaxAggregateOutputType | null
  }

  export type AutocompleteMetricsAvgAggregateOutputType = {
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    avgSuccessRate: number | null
    avgAcceptanceRate: number | null
  }

  export type AutocompleteMetricsSumAggregateOutputType = {
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    avgSuccessRate: number | null
    avgAcceptanceRate: number | null
  }

  export type AutocompleteMetricsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    avgSuccessRate: number | null
    avgAcceptanceRate: number | null
    date: Date | null
  }

  export type AutocompleteMetricsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    completionsGenerated: number | null
    completionsAccepted: number | null
    linesAdded: number | null
    charactersAdded: number | null
    avgLatency: number | null
    avgSuccessRate: number | null
    avgAcceptanceRate: number | null
    date: Date | null
  }

  export type AutocompleteMetricsCountAggregateOutputType = {
    id: number
    userId: number
    completionsGenerated: number
    completionsAccepted: number
    linesAdded: number
    charactersAdded: number
    avgLatency: number
    avgSuccessRate: number
    avgAcceptanceRate: number
    modelBreakdown: number
    date: number
    _all: number
  }


  export type AutocompleteMetricsAvgAggregateInputType = {
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    avgSuccessRate?: true
    avgAcceptanceRate?: true
  }

  export type AutocompleteMetricsSumAggregateInputType = {
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    avgSuccessRate?: true
    avgAcceptanceRate?: true
  }

  export type AutocompleteMetricsMinAggregateInputType = {
    id?: true
    userId?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    avgSuccessRate?: true
    avgAcceptanceRate?: true
    date?: true
  }

  export type AutocompleteMetricsMaxAggregateInputType = {
    id?: true
    userId?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    avgSuccessRate?: true
    avgAcceptanceRate?: true
    date?: true
  }

  export type AutocompleteMetricsCountAggregateInputType = {
    id?: true
    userId?: true
    completionsGenerated?: true
    completionsAccepted?: true
    linesAdded?: true
    charactersAdded?: true
    avgLatency?: true
    avgSuccessRate?: true
    avgAcceptanceRate?: true
    modelBreakdown?: true
    date?: true
    _all?: true
  }

  export type AutocompleteMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutocompleteMetrics to aggregate.
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteMetrics to fetch.
     */
    orderBy?: AutocompleteMetricsOrderByWithRelationInput | AutocompleteMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AutocompleteMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AutocompleteMetrics
    **/
    _count?: true | AutocompleteMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AutocompleteMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AutocompleteMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AutocompleteMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AutocompleteMetricsMaxAggregateInputType
  }

  export type GetAutocompleteMetricsAggregateType<T extends AutocompleteMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateAutocompleteMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAutocompleteMetrics[P]>
      : GetScalarType<T[P], AggregateAutocompleteMetrics[P]>
  }




  export type AutocompleteMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AutocompleteMetricsWhereInput
    orderBy?: AutocompleteMetricsOrderByWithAggregationInput | AutocompleteMetricsOrderByWithAggregationInput[]
    by: AutocompleteMetricsScalarFieldEnum[] | AutocompleteMetricsScalarFieldEnum
    having?: AutocompleteMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AutocompleteMetricsCountAggregateInputType | true
    _avg?: AutocompleteMetricsAvgAggregateInputType
    _sum?: AutocompleteMetricsSumAggregateInputType
    _min?: AutocompleteMetricsMinAggregateInputType
    _max?: AutocompleteMetricsMaxAggregateInputType
  }

  export type AutocompleteMetricsGroupByOutputType = {
    id: string
    userId: string
    completionsGenerated: number
    completionsAccepted: number
    linesAdded: number
    charactersAdded: number
    avgLatency: number
    avgSuccessRate: number
    avgAcceptanceRate: number
    modelBreakdown: JsonValue | null
    date: Date
    _count: AutocompleteMetricsCountAggregateOutputType | null
    _avg: AutocompleteMetricsAvgAggregateOutputType | null
    _sum: AutocompleteMetricsSumAggregateOutputType | null
    _min: AutocompleteMetricsMinAggregateOutputType | null
    _max: AutocompleteMetricsMaxAggregateOutputType | null
  }

  type GetAutocompleteMetricsGroupByPayload<T extends AutocompleteMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AutocompleteMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AutocompleteMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AutocompleteMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], AutocompleteMetricsGroupByOutputType[P]>
        }
      >
    >


  export type AutocompleteMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    avgLatency?: boolean
    avgSuccessRate?: boolean
    avgAcceptanceRate?: boolean
    modelBreakdown?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteMetrics"]>

  export type AutocompleteMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    avgLatency?: boolean
    avgSuccessRate?: boolean
    avgAcceptanceRate?: boolean
    modelBreakdown?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteMetrics"]>

  export type AutocompleteMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    avgLatency?: boolean
    avgSuccessRate?: boolean
    avgAcceptanceRate?: boolean
    modelBreakdown?: boolean
    date?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["autocompleteMetrics"]>

  export type AutocompleteMetricsSelectScalar = {
    id?: boolean
    userId?: boolean
    completionsGenerated?: boolean
    completionsAccepted?: boolean
    linesAdded?: boolean
    charactersAdded?: boolean
    avgLatency?: boolean
    avgSuccessRate?: boolean
    avgAcceptanceRate?: boolean
    modelBreakdown?: boolean
    date?: boolean
  }

  export type AutocompleteMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "completionsGenerated" | "completionsAccepted" | "linesAdded" | "charactersAdded" | "avgLatency" | "avgSuccessRate" | "avgAcceptanceRate" | "modelBreakdown" | "date", ExtArgs["result"]["autocompleteMetrics"]>
  export type AutocompleteMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutocompleteMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AutocompleteMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AutocompleteMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AutocompleteMetrics"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      completionsGenerated: number
      completionsAccepted: number
      linesAdded: number
      charactersAdded: number
      avgLatency: number
      avgSuccessRate: number
      avgAcceptanceRate: number
      modelBreakdown: Prisma.JsonValue | null
      date: Date
    }, ExtArgs["result"]["autocompleteMetrics"]>
    composites: {}
  }

  type AutocompleteMetricsGetPayload<S extends boolean | null | undefined | AutocompleteMetricsDefaultArgs> = $Result.GetResult<Prisma.$AutocompleteMetricsPayload, S>

  type AutocompleteMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AutocompleteMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AutocompleteMetricsCountAggregateInputType | true
    }

  export interface AutocompleteMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AutocompleteMetrics'], meta: { name: 'AutocompleteMetrics' } }
    /**
     * Find zero or one AutocompleteMetrics that matches the filter.
     * @param {AutocompleteMetricsFindUniqueArgs} args - Arguments to find a AutocompleteMetrics
     * @example
     * // Get one AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AutocompleteMetricsFindUniqueArgs>(args: SelectSubset<T, AutocompleteMetricsFindUniqueArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one AutocompleteMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AutocompleteMetricsFindUniqueOrThrowArgs} args - Arguments to find a AutocompleteMetrics
     * @example
     * // Get one AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AutocompleteMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, AutocompleteMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first AutocompleteMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsFindFirstArgs} args - Arguments to find a AutocompleteMetrics
     * @example
     * // Get one AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AutocompleteMetricsFindFirstArgs>(args?: SelectSubset<T, AutocompleteMetricsFindFirstArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first AutocompleteMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsFindFirstOrThrowArgs} args - Arguments to find a AutocompleteMetrics
     * @example
     * // Get one AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AutocompleteMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, AutocompleteMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more AutocompleteMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findMany()
     * 
     * // Get first 10 AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const autocompleteMetricsWithIdOnly = await prisma.autocompleteMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AutocompleteMetricsFindManyArgs>(args?: SelectSubset<T, AutocompleteMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a AutocompleteMetrics.
     * @param {AutocompleteMetricsCreateArgs} args - Arguments to create a AutocompleteMetrics.
     * @example
     * // Create one AutocompleteMetrics
     * const AutocompleteMetrics = await prisma.autocompleteMetrics.create({
     *   data: {
     *     // ... data to create a AutocompleteMetrics
     *   }
     * })
     * 
     */
    create<T extends AutocompleteMetricsCreateArgs>(args: SelectSubset<T, AutocompleteMetricsCreateArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many AutocompleteMetrics.
     * @param {AutocompleteMetricsCreateManyArgs} args - Arguments to create many AutocompleteMetrics.
     * @example
     * // Create many AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AutocompleteMetricsCreateManyArgs>(args?: SelectSubset<T, AutocompleteMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AutocompleteMetrics and returns the data saved in the database.
     * @param {AutocompleteMetricsCreateManyAndReturnArgs} args - Arguments to create many AutocompleteMetrics.
     * @example
     * // Create many AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AutocompleteMetrics and only return the `id`
     * const autocompleteMetricsWithIdOnly = await prisma.autocompleteMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AutocompleteMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, AutocompleteMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a AutocompleteMetrics.
     * @param {AutocompleteMetricsDeleteArgs} args - Arguments to delete one AutocompleteMetrics.
     * @example
     * // Delete one AutocompleteMetrics
     * const AutocompleteMetrics = await prisma.autocompleteMetrics.delete({
     *   where: {
     *     // ... filter to delete one AutocompleteMetrics
     *   }
     * })
     * 
     */
    delete<T extends AutocompleteMetricsDeleteArgs>(args: SelectSubset<T, AutocompleteMetricsDeleteArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one AutocompleteMetrics.
     * @param {AutocompleteMetricsUpdateArgs} args - Arguments to update one AutocompleteMetrics.
     * @example
     * // Update one AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AutocompleteMetricsUpdateArgs>(args: SelectSubset<T, AutocompleteMetricsUpdateArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more AutocompleteMetrics.
     * @param {AutocompleteMetricsDeleteManyArgs} args - Arguments to filter AutocompleteMetrics to delete.
     * @example
     * // Delete a few AutocompleteMetrics
     * const { count } = await prisma.autocompleteMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AutocompleteMetricsDeleteManyArgs>(args?: SelectSubset<T, AutocompleteMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutocompleteMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AutocompleteMetricsUpdateManyArgs>(args: SelectSubset<T, AutocompleteMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AutocompleteMetrics and returns the data updated in the database.
     * @param {AutocompleteMetricsUpdateManyAndReturnArgs} args - Arguments to update many AutocompleteMetrics.
     * @example
     * // Update many AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AutocompleteMetrics and only return the `id`
     * const autocompleteMetricsWithIdOnly = await prisma.autocompleteMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AutocompleteMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, AutocompleteMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one AutocompleteMetrics.
     * @param {AutocompleteMetricsUpsertArgs} args - Arguments to update or create a AutocompleteMetrics.
     * @example
     * // Update or create a AutocompleteMetrics
     * const autocompleteMetrics = await prisma.autocompleteMetrics.upsert({
     *   create: {
     *     // ... data to create a AutocompleteMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AutocompleteMetrics we want to update
     *   }
     * })
     */
    upsert<T extends AutocompleteMetricsUpsertArgs>(args: SelectSubset<T, AutocompleteMetricsUpsertArgs<ExtArgs>>): Prisma__AutocompleteMetricsClient<$Result.GetResult<Prisma.$AutocompleteMetricsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of AutocompleteMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsCountArgs} args - Arguments to filter AutocompleteMetrics to count.
     * @example
     * // Count the number of AutocompleteMetrics
     * const count = await prisma.autocompleteMetrics.count({
     *   where: {
     *     // ... the filter for the AutocompleteMetrics we want to count
     *   }
     * })
    **/
    count<T extends AutocompleteMetricsCountArgs>(
      args?: Subset<T, AutocompleteMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AutocompleteMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AutocompleteMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AutocompleteMetricsAggregateArgs>(args: Subset<T, AutocompleteMetricsAggregateArgs>): Prisma.PrismaPromise<GetAutocompleteMetricsAggregateType<T>>

    /**
     * Group by AutocompleteMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AutocompleteMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AutocompleteMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AutocompleteMetricsGroupByArgs['orderBy'] }
        : { orderBy?: AutocompleteMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AutocompleteMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAutocompleteMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AutocompleteMetrics model
   */
  readonly fields: AutocompleteMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AutocompleteMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AutocompleteMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AutocompleteMetrics model
   */ 
  interface AutocompleteMetricsFieldRefs {
    readonly id: FieldRef<"AutocompleteMetrics", 'String'>
    readonly userId: FieldRef<"AutocompleteMetrics", 'String'>
    readonly completionsGenerated: FieldRef<"AutocompleteMetrics", 'Int'>
    readonly completionsAccepted: FieldRef<"AutocompleteMetrics", 'Int'>
    readonly linesAdded: FieldRef<"AutocompleteMetrics", 'Int'>
    readonly charactersAdded: FieldRef<"AutocompleteMetrics", 'Int'>
    readonly avgLatency: FieldRef<"AutocompleteMetrics", 'Float'>
    readonly avgSuccessRate: FieldRef<"AutocompleteMetrics", 'Float'>
    readonly avgAcceptanceRate: FieldRef<"AutocompleteMetrics", 'Float'>
    readonly modelBreakdown: FieldRef<"AutocompleteMetrics", 'Json'>
    readonly date: FieldRef<"AutocompleteMetrics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AutocompleteMetrics findUnique
   */
  export type AutocompleteMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteMetrics to fetch.
     */
    where: AutocompleteMetricsWhereUniqueInput
  }

  /**
   * AutocompleteMetrics findUniqueOrThrow
   */
  export type AutocompleteMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteMetrics to fetch.
     */
    where: AutocompleteMetricsWhereUniqueInput
  }

  /**
   * AutocompleteMetrics findFirst
   */
  export type AutocompleteMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteMetrics to fetch.
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteMetrics to fetch.
     */
    orderBy?: AutocompleteMetricsOrderByWithRelationInput | AutocompleteMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutocompleteMetrics.
     */
    cursor?: AutocompleteMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutocompleteMetrics.
     */
    distinct?: AutocompleteMetricsScalarFieldEnum | AutocompleteMetricsScalarFieldEnum[]
  }

  /**
   * AutocompleteMetrics findFirstOrThrow
   */
  export type AutocompleteMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteMetrics to fetch.
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteMetrics to fetch.
     */
    orderBy?: AutocompleteMetricsOrderByWithRelationInput | AutocompleteMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AutocompleteMetrics.
     */
    cursor?: AutocompleteMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AutocompleteMetrics.
     */
    distinct?: AutocompleteMetricsScalarFieldEnum | AutocompleteMetricsScalarFieldEnum[]
  }

  /**
   * AutocompleteMetrics findMany
   */
  export type AutocompleteMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter, which AutocompleteMetrics to fetch.
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AutocompleteMetrics to fetch.
     */
    orderBy?: AutocompleteMetricsOrderByWithRelationInput | AutocompleteMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AutocompleteMetrics.
     */
    cursor?: AutocompleteMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AutocompleteMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AutocompleteMetrics.
     */
    skip?: number
    distinct?: AutocompleteMetricsScalarFieldEnum | AutocompleteMetricsScalarFieldEnum[]
  }

  /**
   * AutocompleteMetrics create
   */
  export type AutocompleteMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a AutocompleteMetrics.
     */
    data: XOR<AutocompleteMetricsCreateInput, AutocompleteMetricsUncheckedCreateInput>
  }

  /**
   * AutocompleteMetrics createMany
   */
  export type AutocompleteMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AutocompleteMetrics.
     */
    data: AutocompleteMetricsCreateManyInput | AutocompleteMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AutocompleteMetrics createManyAndReturn
   */
  export type AutocompleteMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many AutocompleteMetrics.
     */
    data: AutocompleteMetricsCreateManyInput | AutocompleteMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutocompleteMetrics update
   */
  export type AutocompleteMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a AutocompleteMetrics.
     */
    data: XOR<AutocompleteMetricsUpdateInput, AutocompleteMetricsUncheckedUpdateInput>
    /**
     * Choose, which AutocompleteMetrics to update.
     */
    where: AutocompleteMetricsWhereUniqueInput
  }

  /**
   * AutocompleteMetrics updateMany
   */
  export type AutocompleteMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AutocompleteMetrics.
     */
    data: XOR<AutocompleteMetricsUpdateManyMutationInput, AutocompleteMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AutocompleteMetrics to update
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * Limit how many AutocompleteMetrics to update.
     */
    limit?: number
  }

  /**
   * AutocompleteMetrics updateManyAndReturn
   */
  export type AutocompleteMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * The data used to update AutocompleteMetrics.
     */
    data: XOR<AutocompleteMetricsUpdateManyMutationInput, AutocompleteMetricsUncheckedUpdateManyInput>
    /**
     * Filter which AutocompleteMetrics to update
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * Limit how many AutocompleteMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AutocompleteMetrics upsert
   */
  export type AutocompleteMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the AutocompleteMetrics to update in case it exists.
     */
    where: AutocompleteMetricsWhereUniqueInput
    /**
     * In case the AutocompleteMetrics found by the `where` argument doesn't exist, create a new AutocompleteMetrics with this data.
     */
    create: XOR<AutocompleteMetricsCreateInput, AutocompleteMetricsUncheckedCreateInput>
    /**
     * In case the AutocompleteMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AutocompleteMetricsUpdateInput, AutocompleteMetricsUncheckedUpdateInput>
  }

  /**
   * AutocompleteMetrics delete
   */
  export type AutocompleteMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
    /**
     * Filter which AutocompleteMetrics to delete.
     */
    where: AutocompleteMetricsWhereUniqueInput
  }

  /**
   * AutocompleteMetrics deleteMany
   */
  export type AutocompleteMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AutocompleteMetrics to delete
     */
    where?: AutocompleteMetricsWhereInput
    /**
     * Limit how many AutocompleteMetrics to delete.
     */
    limit?: number
  }

  /**
   * AutocompleteMetrics without action
   */
  export type AutocompleteMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AutocompleteMetrics
     */
    select?: AutocompleteMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AutocompleteMetrics
     */
    omit?: AutocompleteMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AutocompleteMetricsInclude<ExtArgs> | null
  }


  /**
   * Model ApiKey
   */

  export type AggregateApiKey = {
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  export type ApiKeyAvgAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeySumAggregateOutputType = {
    usageCount: number | null
  }

  export type ApiKeyMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    keyHash: string | null
    isActive: boolean | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    description: string | null
    keyHash: string | null
    isActive: boolean | null
    expiresAt: Date | null
    lastUsedAt: Date | null
    usageCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ApiKeyCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    description: number
    keyHash: number
    permissions: number
    isActive: number
    expiresAt: number
    lastUsedAt: number
    usageCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ApiKeyAvgAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeySumAggregateInputType = {
    usageCount?: true
  }

  export type ApiKeyMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    keyHash?: true
    isActive?: true
    expiresAt?: true
    lastUsedAt?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    keyHash?: true
    isActive?: true
    expiresAt?: true
    lastUsedAt?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ApiKeyCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    description?: true
    keyHash?: true
    permissions?: true
    isActive?: true
    expiresAt?: true
    lastUsedAt?: true
    usageCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ApiKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKey to aggregate.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ApiKeys
    **/
    _count?: true | ApiKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApiKeyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApiKeySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApiKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApiKeyMaxAggregateInputType
  }

  export type GetApiKeyAggregateType<T extends ApiKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateApiKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApiKey[P]>
      : GetScalarType<T[P], AggregateApiKey[P]>
  }




  export type ApiKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApiKeyWhereInput
    orderBy?: ApiKeyOrderByWithAggregationInput | ApiKeyOrderByWithAggregationInput[]
    by: ApiKeyScalarFieldEnum[] | ApiKeyScalarFieldEnum
    having?: ApiKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApiKeyCountAggregateInputType | true
    _avg?: ApiKeyAvgAggregateInputType
    _sum?: ApiKeySumAggregateInputType
    _min?: ApiKeyMinAggregateInputType
    _max?: ApiKeyMaxAggregateInputType
  }

  export type ApiKeyGroupByOutputType = {
    id: string
    userId: string
    name: string
    description: string | null
    keyHash: string
    permissions: JsonValue
    isActive: boolean
    expiresAt: Date | null
    lastUsedAt: Date | null
    usageCount: number
    createdAt: Date
    updatedAt: Date
    _count: ApiKeyCountAggregateOutputType | null
    _avg: ApiKeyAvgAggregateOutputType | null
    _sum: ApiKeySumAggregateOutputType | null
    _min: ApiKeyMinAggregateOutputType | null
    _max: ApiKeyMaxAggregateOutputType | null
  }

  type GetApiKeyGroupByPayload<T extends ApiKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApiKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApiKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ApiKeyGroupByOutputType[P]>
        }
      >
    >


  export type ApiKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    keyHash?: boolean
    permissions?: boolean
    isActive?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    keyHash?: boolean
    permissions?: boolean
    isActive?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    keyHash?: boolean
    permissions?: boolean
    isActive?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["apiKey"]>

  export type ApiKeySelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    description?: boolean
    keyHash?: boolean
    permissions?: boolean
    isActive?: boolean
    expiresAt?: boolean
    lastUsedAt?: boolean
    usageCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ApiKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "name" | "description" | "keyHash" | "permissions" | "isActive" | "expiresAt" | "lastUsedAt" | "usageCount" | "createdAt" | "updatedAt", ExtArgs["result"]["apiKey"]>
  export type ApiKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ApiKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ApiKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ApiKey"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      description: string | null
      keyHash: string
      permissions: Prisma.JsonValue
      isActive: boolean
      expiresAt: Date | null
      lastUsedAt: Date | null
      usageCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["apiKey"]>
    composites: {}
  }

  type ApiKeyGetPayload<S extends boolean | null | undefined | ApiKeyDefaultArgs> = $Result.GetResult<Prisma.$ApiKeyPayload, S>

  type ApiKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApiKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApiKeyCountAggregateInputType | true
    }

  export interface ApiKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ApiKey'], meta: { name: 'ApiKey' } }
    /**
     * Find zero or one ApiKey that matches the filter.
     * @param {ApiKeyFindUniqueArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApiKeyFindUniqueArgs>(args: SelectSubset<T, ApiKeyFindUniqueArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ApiKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApiKeyFindUniqueOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApiKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ApiKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ApiKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApiKeyFindFirstArgs>(args?: SelectSubset<T, ApiKeyFindFirstArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ApiKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindFirstOrThrowArgs} args - Arguments to find a ApiKey
     * @example
     * // Get one ApiKey
     * const apiKey = await prisma.apiKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApiKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ApiKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ApiKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApiKeys
     * const apiKeys = await prisma.apiKey.findMany()
     * 
     * // Get first 10 ApiKeys
     * const apiKeys = await prisma.apiKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ApiKeyFindManyArgs>(args?: SelectSubset<T, ApiKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ApiKey.
     * @param {ApiKeyCreateArgs} args - Arguments to create a ApiKey.
     * @example
     * // Create one ApiKey
     * const ApiKey = await prisma.apiKey.create({
     *   data: {
     *     // ... data to create a ApiKey
     *   }
     * })
     * 
     */
    create<T extends ApiKeyCreateArgs>(args: SelectSubset<T, ApiKeyCreateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ApiKeys.
     * @param {ApiKeyCreateManyArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApiKeyCreateManyArgs>(args?: SelectSubset<T, ApiKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ApiKeys and returns the data saved in the database.
     * @param {ApiKeyCreateManyAndReturnArgs} args - Arguments to create many ApiKeys.
     * @example
     * // Create many ApiKeys
     * const apiKey = await prisma.apiKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ApiKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ApiKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ApiKey.
     * @param {ApiKeyDeleteArgs} args - Arguments to delete one ApiKey.
     * @example
     * // Delete one ApiKey
     * const ApiKey = await prisma.apiKey.delete({
     *   where: {
     *     // ... filter to delete one ApiKey
     *   }
     * })
     * 
     */
    delete<T extends ApiKeyDeleteArgs>(args: SelectSubset<T, ApiKeyDeleteArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ApiKey.
     * @param {ApiKeyUpdateArgs} args - Arguments to update one ApiKey.
     * @example
     * // Update one ApiKey
     * const apiKey = await prisma.apiKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApiKeyUpdateArgs>(args: SelectSubset<T, ApiKeyUpdateArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ApiKeys.
     * @param {ApiKeyDeleteManyArgs} args - Arguments to filter ApiKeys to delete.
     * @example
     * // Delete a few ApiKeys
     * const { count } = await prisma.apiKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApiKeyDeleteManyArgs>(args?: SelectSubset<T, ApiKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApiKeyUpdateManyArgs>(args: SelectSubset<T, ApiKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ApiKeys and returns the data updated in the database.
     * @param {ApiKeyUpdateManyAndReturnArgs} args - Arguments to update many ApiKeys.
     * @example
     * // Update many ApiKeys
     * const apiKey = await prisma.apiKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ApiKeys and only return the `id`
     * const apiKeyWithIdOnly = await prisma.apiKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ApiKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ApiKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ApiKey.
     * @param {ApiKeyUpsertArgs} args - Arguments to update or create a ApiKey.
     * @example
     * // Update or create a ApiKey
     * const apiKey = await prisma.apiKey.upsert({
     *   create: {
     *     // ... data to create a ApiKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApiKey we want to update
     *   }
     * })
     */
    upsert<T extends ApiKeyUpsertArgs>(args: SelectSubset<T, ApiKeyUpsertArgs<ExtArgs>>): Prisma__ApiKeyClient<$Result.GetResult<Prisma.$ApiKeyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ApiKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyCountArgs} args - Arguments to filter ApiKeys to count.
     * @example
     * // Count the number of ApiKeys
     * const count = await prisma.apiKey.count({
     *   where: {
     *     // ... the filter for the ApiKeys we want to count
     *   }
     * })
    **/
    count<T extends ApiKeyCountArgs>(
      args?: Subset<T, ApiKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApiKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApiKeyAggregateArgs>(args: Subset<T, ApiKeyAggregateArgs>): Prisma.PrismaPromise<GetApiKeyAggregateType<T>>

    /**
     * Group by ApiKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApiKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApiKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApiKeyGroupByArgs['orderBy'] }
        : { orderBy?: ApiKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApiKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApiKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ApiKey model
   */
  readonly fields: ApiKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApiKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApiKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ApiKey model
   */ 
  interface ApiKeyFieldRefs {
    readonly id: FieldRef<"ApiKey", 'String'>
    readonly userId: FieldRef<"ApiKey", 'String'>
    readonly name: FieldRef<"ApiKey", 'String'>
    readonly description: FieldRef<"ApiKey", 'String'>
    readonly keyHash: FieldRef<"ApiKey", 'String'>
    readonly permissions: FieldRef<"ApiKey", 'Json'>
    readonly isActive: FieldRef<"ApiKey", 'Boolean'>
    readonly expiresAt: FieldRef<"ApiKey", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ApiKey", 'DateTime'>
    readonly usageCount: FieldRef<"ApiKey", 'Int'>
    readonly createdAt: FieldRef<"ApiKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ApiKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ApiKey findUnique
   */
  export type ApiKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findUniqueOrThrow
   */
  export type ApiKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey findFirst
   */
  export type ApiKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findFirstOrThrow
   */
  export type ApiKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKey to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ApiKeys.
     */
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey findMany
   */
  export type ApiKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter, which ApiKeys to fetch.
     */
    where?: ApiKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ApiKeys to fetch.
     */
    orderBy?: ApiKeyOrderByWithRelationInput | ApiKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ApiKeys.
     */
    cursor?: ApiKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ApiKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ApiKeys.
     */
    skip?: number
    distinct?: ApiKeyScalarFieldEnum | ApiKeyScalarFieldEnum[]
  }

  /**
   * ApiKey create
   */
  export type ApiKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ApiKey.
     */
    data: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
  }

  /**
   * ApiKey createMany
   */
  export type ApiKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ApiKey createManyAndReturn
   */
  export type ApiKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ApiKeys.
     */
    data: ApiKeyCreateManyInput | ApiKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey update
   */
  export type ApiKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ApiKey.
     */
    data: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
    /**
     * Choose, which ApiKey to update.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey updateMany
   */
  export type ApiKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
  }

  /**
   * ApiKey updateManyAndReturn
   */
  export type ApiKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * The data used to update ApiKeys.
     */
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyInput>
    /**
     * Filter which ApiKeys to update
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ApiKey upsert
   */
  export type ApiKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ApiKey to update in case it exists.
     */
    where: ApiKeyWhereUniqueInput
    /**
     * In case the ApiKey found by the `where` argument doesn't exist, create a new ApiKey with this data.
     */
    create: XOR<ApiKeyCreateInput, ApiKeyUncheckedCreateInput>
    /**
     * In case the ApiKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApiKeyUpdateInput, ApiKeyUncheckedUpdateInput>
  }

  /**
   * ApiKey delete
   */
  export type ApiKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
    /**
     * Filter which ApiKey to delete.
     */
    where: ApiKeyWhereUniqueInput
  }

  /**
   * ApiKey deleteMany
   */
  export type ApiKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ApiKeys to delete
     */
    where?: ApiKeyWhereInput
    /**
     * Limit how many ApiKeys to delete.
     */
    limit?: number
  }

  /**
   * ApiKey without action
   */
  export type ApiKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApiKey
     */
    select?: ApiKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ApiKey
     */
    omit?: ApiKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApiKeyInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    termsAccepted: boolean | null
    extensionEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    name: string | null
    subscriptionTier: string | null
    subscriptionStatus: string | null
    termsAccepted: boolean | null
    extensionEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    name: number
    subscriptionTier: number
    subscriptionStatus: number
    termsAccepted: number
    extensionEnabled: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    termsAccepted?: true
    extensionEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    termsAccepted?: true
    extensionEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    name?: true
    subscriptionTier?: true
    subscriptionStatus?: true
    termsAccepted?: true
    extensionEnabled?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    email: string
    name: string | null
    subscriptionTier: string
    subscriptionStatus: string
    termsAccepted: boolean
    extensionEnabled: boolean
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    name?: boolean
    subscriptionTier?: boolean
    subscriptionStatus?: boolean
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "email" | "name" | "subscriptionTier" | "subscriptionStatus" | "termsAccepted" | "extensionEnabled" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["userProfile"]>

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      email: string
      name: string | null
      subscriptionTier: string
      subscriptionStatus: string
      termsAccepted: boolean
      extensionEnabled: boolean
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles and returns the data updated in the database.
     * @param {UserProfileUpdateManyAndReturnArgs} args - Arguments to update many UserProfiles.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, UserProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly email: FieldRef<"UserProfile", 'String'>
    readonly name: FieldRef<"UserProfile", 'String'>
    readonly subscriptionTier: FieldRef<"UserProfile", 'String'>
    readonly subscriptionStatus: FieldRef<"UserProfile", 'String'>
    readonly termsAccepted: FieldRef<"UserProfile", 'Boolean'>
    readonly extensionEnabled: FieldRef<"UserProfile", 'Boolean'>
    readonly settings: FieldRef<"UserProfile", 'Json'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile updateManyAndReturn
   */
  export type UserProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to update.
     */
    limit?: number
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
    /**
     * Limit how many UserProfiles to delete.
     */
    limit?: number
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserProfile
     */
    omit?: UserProfileOmit<ExtArgs> | null
  }


  /**
   * Model PendingLogin
   */

  export type AggregatePendingLogin = {
    _count: PendingLoginCountAggregateOutputType | null
    _min: PendingLoginMinAggregateOutputType | null
    _max: PendingLoginMaxAggregateOutputType | null
  }

  export type PendingLoginMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    state: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PendingLoginMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    state: string | null
    token: string | null
    userId: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type PendingLoginCountAggregateOutputType = {
    id: number
    deviceId: number
    state: number
    token: number
    userId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type PendingLoginMinAggregateInputType = {
    id?: true
    deviceId?: true
    state?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PendingLoginMaxAggregateInputType = {
    id?: true
    deviceId?: true
    state?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type PendingLoginCountAggregateInputType = {
    id?: true
    deviceId?: true
    state?: true
    token?: true
    userId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type PendingLoginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingLogin to aggregate.
     */
    where?: PendingLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingLogins to fetch.
     */
    orderBy?: PendingLoginOrderByWithRelationInput | PendingLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PendingLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PendingLogins
    **/
    _count?: true | PendingLoginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PendingLoginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PendingLoginMaxAggregateInputType
  }

  export type GetPendingLoginAggregateType<T extends PendingLoginAggregateArgs> = {
        [P in keyof T & keyof AggregatePendingLogin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePendingLogin[P]>
      : GetScalarType<T[P], AggregatePendingLogin[P]>
  }




  export type PendingLoginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PendingLoginWhereInput
    orderBy?: PendingLoginOrderByWithAggregationInput | PendingLoginOrderByWithAggregationInput[]
    by: PendingLoginScalarFieldEnum[] | PendingLoginScalarFieldEnum
    having?: PendingLoginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PendingLoginCountAggregateInputType | true
    _min?: PendingLoginMinAggregateInputType
    _max?: PendingLoginMaxAggregateInputType
  }

  export type PendingLoginGroupByOutputType = {
    id: string
    deviceId: string
    state: string
    token: string
    userId: string
    createdAt: Date
    expiresAt: Date
    _count: PendingLoginCountAggregateOutputType | null
    _min: PendingLoginMinAggregateOutputType | null
    _max: PendingLoginMaxAggregateOutputType | null
  }

  type GetPendingLoginGroupByPayload<T extends PendingLoginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PendingLoginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PendingLoginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PendingLoginGroupByOutputType[P]>
            : GetScalarType<T[P], PendingLoginGroupByOutputType[P]>
        }
      >
    >


  export type PendingLoginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    state?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["pendingLogin"]>

  export type PendingLoginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    state?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["pendingLogin"]>

  export type PendingLoginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    state?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["pendingLogin"]>

  export type PendingLoginSelectScalar = {
    id?: boolean
    deviceId?: boolean
    state?: boolean
    token?: boolean
    userId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type PendingLoginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "deviceId" | "state" | "token" | "userId" | "createdAt" | "expiresAt", ExtArgs["result"]["pendingLogin"]>

  export type $PendingLoginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PendingLogin"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      state: string
      token: string
      userId: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["pendingLogin"]>
    composites: {}
  }

  type PendingLoginGetPayload<S extends boolean | null | undefined | PendingLoginDefaultArgs> = $Result.GetResult<Prisma.$PendingLoginPayload, S>

  type PendingLoginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PendingLoginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PendingLoginCountAggregateInputType | true
    }

  export interface PendingLoginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PendingLogin'], meta: { name: 'PendingLogin' } }
    /**
     * Find zero or one PendingLogin that matches the filter.
     * @param {PendingLoginFindUniqueArgs} args - Arguments to find a PendingLogin
     * @example
     * // Get one PendingLogin
     * const pendingLogin = await prisma.pendingLogin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PendingLoginFindUniqueArgs>(args: SelectSubset<T, PendingLoginFindUniqueArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one PendingLogin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PendingLoginFindUniqueOrThrowArgs} args - Arguments to find a PendingLogin
     * @example
     * // Get one PendingLogin
     * const pendingLogin = await prisma.pendingLogin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PendingLoginFindUniqueOrThrowArgs>(args: SelectSubset<T, PendingLoginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first PendingLogin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginFindFirstArgs} args - Arguments to find a PendingLogin
     * @example
     * // Get one PendingLogin
     * const pendingLogin = await prisma.pendingLogin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PendingLoginFindFirstArgs>(args?: SelectSubset<T, PendingLoginFindFirstArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first PendingLogin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginFindFirstOrThrowArgs} args - Arguments to find a PendingLogin
     * @example
     * // Get one PendingLogin
     * const pendingLogin = await prisma.pendingLogin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PendingLoginFindFirstOrThrowArgs>(args?: SelectSubset<T, PendingLoginFindFirstOrThrowArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more PendingLogins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PendingLogins
     * const pendingLogins = await prisma.pendingLogin.findMany()
     * 
     * // Get first 10 PendingLogins
     * const pendingLogins = await prisma.pendingLogin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pendingLoginWithIdOnly = await prisma.pendingLogin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PendingLoginFindManyArgs>(args?: SelectSubset<T, PendingLoginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a PendingLogin.
     * @param {PendingLoginCreateArgs} args - Arguments to create a PendingLogin.
     * @example
     * // Create one PendingLogin
     * const PendingLogin = await prisma.pendingLogin.create({
     *   data: {
     *     // ... data to create a PendingLogin
     *   }
     * })
     * 
     */
    create<T extends PendingLoginCreateArgs>(args: SelectSubset<T, PendingLoginCreateArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many PendingLogins.
     * @param {PendingLoginCreateManyArgs} args - Arguments to create many PendingLogins.
     * @example
     * // Create many PendingLogins
     * const pendingLogin = await prisma.pendingLogin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PendingLoginCreateManyArgs>(args?: SelectSubset<T, PendingLoginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PendingLogins and returns the data saved in the database.
     * @param {PendingLoginCreateManyAndReturnArgs} args - Arguments to create many PendingLogins.
     * @example
     * // Create many PendingLogins
     * const pendingLogin = await prisma.pendingLogin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PendingLogins and only return the `id`
     * const pendingLoginWithIdOnly = await prisma.pendingLogin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PendingLoginCreateManyAndReturnArgs>(args?: SelectSubset<T, PendingLoginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a PendingLogin.
     * @param {PendingLoginDeleteArgs} args - Arguments to delete one PendingLogin.
     * @example
     * // Delete one PendingLogin
     * const PendingLogin = await prisma.pendingLogin.delete({
     *   where: {
     *     // ... filter to delete one PendingLogin
     *   }
     * })
     * 
     */
    delete<T extends PendingLoginDeleteArgs>(args: SelectSubset<T, PendingLoginDeleteArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one PendingLogin.
     * @param {PendingLoginUpdateArgs} args - Arguments to update one PendingLogin.
     * @example
     * // Update one PendingLogin
     * const pendingLogin = await prisma.pendingLogin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PendingLoginUpdateArgs>(args: SelectSubset<T, PendingLoginUpdateArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more PendingLogins.
     * @param {PendingLoginDeleteManyArgs} args - Arguments to filter PendingLogins to delete.
     * @example
     * // Delete a few PendingLogins
     * const { count } = await prisma.pendingLogin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PendingLoginDeleteManyArgs>(args?: SelectSubset<T, PendingLoginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PendingLogins
     * const pendingLogin = await prisma.pendingLogin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PendingLoginUpdateManyArgs>(args: SelectSubset<T, PendingLoginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PendingLogins and returns the data updated in the database.
     * @param {PendingLoginUpdateManyAndReturnArgs} args - Arguments to update many PendingLogins.
     * @example
     * // Update many PendingLogins
     * const pendingLogin = await prisma.pendingLogin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PendingLogins and only return the `id`
     * const pendingLoginWithIdOnly = await prisma.pendingLogin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PendingLoginUpdateManyAndReturnArgs>(args: SelectSubset<T, PendingLoginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one PendingLogin.
     * @param {PendingLoginUpsertArgs} args - Arguments to update or create a PendingLogin.
     * @example
     * // Update or create a PendingLogin
     * const pendingLogin = await prisma.pendingLogin.upsert({
     *   create: {
     *     // ... data to create a PendingLogin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PendingLogin we want to update
     *   }
     * })
     */
    upsert<T extends PendingLoginUpsertArgs>(args: SelectSubset<T, PendingLoginUpsertArgs<ExtArgs>>): Prisma__PendingLoginClient<$Result.GetResult<Prisma.$PendingLoginPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of PendingLogins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginCountArgs} args - Arguments to filter PendingLogins to count.
     * @example
     * // Count the number of PendingLogins
     * const count = await prisma.pendingLogin.count({
     *   where: {
     *     // ... the filter for the PendingLogins we want to count
     *   }
     * })
    **/
    count<T extends PendingLoginCountArgs>(
      args?: Subset<T, PendingLoginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PendingLoginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PendingLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PendingLoginAggregateArgs>(args: Subset<T, PendingLoginAggregateArgs>): Prisma.PrismaPromise<GetPendingLoginAggregateType<T>>

    /**
     * Group by PendingLogin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PendingLoginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PendingLoginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PendingLoginGroupByArgs['orderBy'] }
        : { orderBy?: PendingLoginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PendingLoginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPendingLoginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PendingLogin model
   */
  readonly fields: PendingLoginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PendingLogin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PendingLoginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PendingLogin model
   */ 
  interface PendingLoginFieldRefs {
    readonly id: FieldRef<"PendingLogin", 'String'>
    readonly deviceId: FieldRef<"PendingLogin", 'String'>
    readonly state: FieldRef<"PendingLogin", 'String'>
    readonly token: FieldRef<"PendingLogin", 'String'>
    readonly userId: FieldRef<"PendingLogin", 'String'>
    readonly createdAt: FieldRef<"PendingLogin", 'DateTime'>
    readonly expiresAt: FieldRef<"PendingLogin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PendingLogin findUnique
   */
  export type PendingLoginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter, which PendingLogin to fetch.
     */
    where: PendingLoginWhereUniqueInput
  }

  /**
   * PendingLogin findUniqueOrThrow
   */
  export type PendingLoginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter, which PendingLogin to fetch.
     */
    where: PendingLoginWhereUniqueInput
  }

  /**
   * PendingLogin findFirst
   */
  export type PendingLoginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter, which PendingLogin to fetch.
     */
    where?: PendingLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingLogins to fetch.
     */
    orderBy?: PendingLoginOrderByWithRelationInput | PendingLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingLogins.
     */
    cursor?: PendingLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingLogins.
     */
    distinct?: PendingLoginScalarFieldEnum | PendingLoginScalarFieldEnum[]
  }

  /**
   * PendingLogin findFirstOrThrow
   */
  export type PendingLoginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter, which PendingLogin to fetch.
     */
    where?: PendingLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingLogins to fetch.
     */
    orderBy?: PendingLoginOrderByWithRelationInput | PendingLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PendingLogins.
     */
    cursor?: PendingLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingLogins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PendingLogins.
     */
    distinct?: PendingLoginScalarFieldEnum | PendingLoginScalarFieldEnum[]
  }

  /**
   * PendingLogin findMany
   */
  export type PendingLoginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter, which PendingLogins to fetch.
     */
    where?: PendingLoginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PendingLogins to fetch.
     */
    orderBy?: PendingLoginOrderByWithRelationInput | PendingLoginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PendingLogins.
     */
    cursor?: PendingLoginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PendingLogins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PendingLogins.
     */
    skip?: number
    distinct?: PendingLoginScalarFieldEnum | PendingLoginScalarFieldEnum[]
  }

  /**
   * PendingLogin create
   */
  export type PendingLoginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * The data needed to create a PendingLogin.
     */
    data: XOR<PendingLoginCreateInput, PendingLoginUncheckedCreateInput>
  }

  /**
   * PendingLogin createMany
   */
  export type PendingLoginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PendingLogins.
     */
    data: PendingLoginCreateManyInput | PendingLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingLogin createManyAndReturn
   */
  export type PendingLoginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * The data used to create many PendingLogins.
     */
    data: PendingLoginCreateManyInput | PendingLoginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PendingLogin update
   */
  export type PendingLoginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * The data needed to update a PendingLogin.
     */
    data: XOR<PendingLoginUpdateInput, PendingLoginUncheckedUpdateInput>
    /**
     * Choose, which PendingLogin to update.
     */
    where: PendingLoginWhereUniqueInput
  }

  /**
   * PendingLogin updateMany
   */
  export type PendingLoginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PendingLogins.
     */
    data: XOR<PendingLoginUpdateManyMutationInput, PendingLoginUncheckedUpdateManyInput>
    /**
     * Filter which PendingLogins to update
     */
    where?: PendingLoginWhereInput
    /**
     * Limit how many PendingLogins to update.
     */
    limit?: number
  }

  /**
   * PendingLogin updateManyAndReturn
   */
  export type PendingLoginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * The data used to update PendingLogins.
     */
    data: XOR<PendingLoginUpdateManyMutationInput, PendingLoginUncheckedUpdateManyInput>
    /**
     * Filter which PendingLogins to update
     */
    where?: PendingLoginWhereInput
    /**
     * Limit how many PendingLogins to update.
     */
    limit?: number
  }

  /**
   * PendingLogin upsert
   */
  export type PendingLoginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * The filter to search for the PendingLogin to update in case it exists.
     */
    where: PendingLoginWhereUniqueInput
    /**
     * In case the PendingLogin found by the `where` argument doesn't exist, create a new PendingLogin with this data.
     */
    create: XOR<PendingLoginCreateInput, PendingLoginUncheckedCreateInput>
    /**
     * In case the PendingLogin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PendingLoginUpdateInput, PendingLoginUncheckedUpdateInput>
  }

  /**
   * PendingLogin delete
   */
  export type PendingLoginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
    /**
     * Filter which PendingLogin to delete.
     */
    where: PendingLoginWhereUniqueInput
  }

  /**
   * PendingLogin deleteMany
   */
  export type PendingLoginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PendingLogins to delete
     */
    where?: PendingLoginWhereInput
    /**
     * Limit how many PendingLogins to delete.
     */
    limit?: number
  }

  /**
   * PendingLogin without action
   */
  export type PendingLoginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PendingLogin
     */
    select?: PendingLoginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PendingLogin
     */
    omit?: PendingLoginOmit<ExtArgs> | null
  }


  /**
   * Model Page
   */

  export type AggregatePage = {
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  export type PageAvgAggregateOutputType = {
    id: number | null
  }

  export type PageSumAggregateOutputType = {
    id: number | null
  }

  export type PageMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PageMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type PageCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type PageAvgAggregateInputType = {
    id?: true
  }

  export type PageSumAggregateInputType = {
    id?: true
  }

  export type PageMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type PageMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type PageCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type PageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Page to aggregate.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pages
    **/
    _count?: true | PageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PageMaxAggregateInputType
  }

  export type GetPageAggregateType<T extends PageAggregateArgs> = {
        [P in keyof T & keyof AggregatePage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePage[P]>
      : GetScalarType<T[P], AggregatePage[P]>
  }




  export type PageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PageWhereInput
    orderBy?: PageOrderByWithAggregationInput | PageOrderByWithAggregationInput[]
    by: PageScalarFieldEnum[] | PageScalarFieldEnum
    having?: PageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PageCountAggregateInputType | true
    _avg?: PageAvgAggregateInputType
    _sum?: PageSumAggregateInputType
    _min?: PageMinAggregateInputType
    _max?: PageMaxAggregateInputType
  }

  export type PageGroupByOutputType = {
    id: number
    name: string
    _count: PageCountAggregateOutputType | null
    _avg: PageAvgAggregateOutputType | null
    _sum: PageSumAggregateOutputType | null
    _min: PageMinAggregateOutputType | null
    _max: PageMaxAggregateOutputType | null
  }

  type GetPageGroupByPayload<T extends PageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PageGroupByOutputType[P]>
            : GetScalarType<T[P], PageGroupByOutputType[P]>
        }
      >
    >


  export type PageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["page"]>

  export type PageSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type PageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["page"]>

  export type $PagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Page"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["page"]>
    composites: {}
  }

  type PageGetPayload<S extends boolean | null | undefined | PageDefaultArgs> = $Result.GetResult<Prisma.$PagePayload, S>

  type PageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PageCountAggregateInputType | true
    }

  export interface PageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Page'], meta: { name: 'Page' } }
    /**
     * Find zero or one Page that matches the filter.
     * @param {PageFindUniqueArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PageFindUniqueArgs>(args: SelectSubset<T, PageFindUniqueArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Page that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PageFindUniqueOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PageFindUniqueOrThrowArgs>(args: SelectSubset<T, PageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Page that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PageFindFirstArgs>(args?: SelectSubset<T, PageFindFirstArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Page that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindFirstOrThrowArgs} args - Arguments to find a Page
     * @example
     * // Get one Page
     * const page = await prisma.page.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PageFindFirstOrThrowArgs>(args?: SelectSubset<T, PageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Pages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pages
     * const pages = await prisma.page.findMany()
     * 
     * // Get first 10 Pages
     * const pages = await prisma.page.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pageWithIdOnly = await prisma.page.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PageFindManyArgs>(args?: SelectSubset<T, PageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Page.
     * @param {PageCreateArgs} args - Arguments to create a Page.
     * @example
     * // Create one Page
     * const Page = await prisma.page.create({
     *   data: {
     *     // ... data to create a Page
     *   }
     * })
     * 
     */
    create<T extends PageCreateArgs>(args: SelectSubset<T, PageCreateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Pages.
     * @param {PageCreateManyArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PageCreateManyArgs>(args?: SelectSubset<T, PageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pages and returns the data saved in the database.
     * @param {PageCreateManyAndReturnArgs} args - Arguments to create many Pages.
     * @example
     * // Create many Pages
     * const page = await prisma.page.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PageCreateManyAndReturnArgs>(args?: SelectSubset<T, PageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Page.
     * @param {PageDeleteArgs} args - Arguments to delete one Page.
     * @example
     * // Delete one Page
     * const Page = await prisma.page.delete({
     *   where: {
     *     // ... filter to delete one Page
     *   }
     * })
     * 
     */
    delete<T extends PageDeleteArgs>(args: SelectSubset<T, PageDeleteArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Page.
     * @param {PageUpdateArgs} args - Arguments to update one Page.
     * @example
     * // Update one Page
     * const page = await prisma.page.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PageUpdateArgs>(args: SelectSubset<T, PageUpdateArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Pages.
     * @param {PageDeleteManyArgs} args - Arguments to filter Pages to delete.
     * @example
     * // Delete a few Pages
     * const { count } = await prisma.page.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PageDeleteManyArgs>(args?: SelectSubset<T, PageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PageUpdateManyArgs>(args: SelectSubset<T, PageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pages and returns the data updated in the database.
     * @param {PageUpdateManyAndReturnArgs} args - Arguments to update many Pages.
     * @example
     * // Update many Pages
     * const page = await prisma.page.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pages and only return the `id`
     * const pageWithIdOnly = await prisma.page.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PageUpdateManyAndReturnArgs>(args: SelectSubset<T, PageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Page.
     * @param {PageUpsertArgs} args - Arguments to update or create a Page.
     * @example
     * // Update or create a Page
     * const page = await prisma.page.upsert({
     *   create: {
     *     // ... data to create a Page
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Page we want to update
     *   }
     * })
     */
    upsert<T extends PageUpsertArgs>(args: SelectSubset<T, PageUpsertArgs<ExtArgs>>): Prisma__PageClient<$Result.GetResult<Prisma.$PagePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Pages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageCountArgs} args - Arguments to filter Pages to count.
     * @example
     * // Count the number of Pages
     * const count = await prisma.page.count({
     *   where: {
     *     // ... the filter for the Pages we want to count
     *   }
     * })
    **/
    count<T extends PageCountArgs>(
      args?: Subset<T, PageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PageAggregateArgs>(args: Subset<T, PageAggregateArgs>): Prisma.PrismaPromise<GetPageAggregateType<T>>

    /**
     * Group by Page.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PageGroupByArgs['orderBy'] }
        : { orderBy?: PageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Page model
   */
  readonly fields: PageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Page.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Page model
   */ 
  interface PageFieldRefs {
    readonly id: FieldRef<"Page", 'Int'>
    readonly name: FieldRef<"Page", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Page findUnique
   */
  export type PageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findUniqueOrThrow
   */
  export type PageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page findFirst
   */
  export type PageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findFirstOrThrow
   */
  export type PageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Page to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pages.
     */
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page findMany
   */
  export type PageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter, which Pages to fetch.
     */
    where?: PageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pages to fetch.
     */
    orderBy?: PageOrderByWithRelationInput | PageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pages.
     */
    cursor?: PageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pages.
     */
    skip?: number
    distinct?: PageScalarFieldEnum | PageScalarFieldEnum[]
  }

  /**
   * Page create
   */
  export type PageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data needed to create a Page.
     */
    data: XOR<PageCreateInput, PageUncheckedCreateInput>
  }

  /**
   * Page createMany
   */
  export type PageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page createManyAndReturn
   */
  export type PageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to create many Pages.
     */
    data: PageCreateManyInput | PageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Page update
   */
  export type PageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data needed to update a Page.
     */
    data: XOR<PageUpdateInput, PageUncheckedUpdateInput>
    /**
     * Choose, which Page to update.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page updateMany
   */
  export type PageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page updateManyAndReturn
   */
  export type PageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The data used to update Pages.
     */
    data: XOR<PageUpdateManyMutationInput, PageUncheckedUpdateManyInput>
    /**
     * Filter which Pages to update
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to update.
     */
    limit?: number
  }

  /**
   * Page upsert
   */
  export type PageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * The filter to search for the Page to update in case it exists.
     */
    where: PageWhereUniqueInput
    /**
     * In case the Page found by the `where` argument doesn't exist, create a new Page with this data.
     */
    create: XOR<PageCreateInput, PageUncheckedCreateInput>
    /**
     * In case the Page was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PageUpdateInput, PageUncheckedUpdateInput>
  }

  /**
   * Page delete
   */
  export type PageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
    /**
     * Filter which Page to delete.
     */
    where: PageWhereUniqueInput
  }

  /**
   * Page deleteMany
   */
  export type PageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pages to delete
     */
    where?: PageWhereInput
    /**
     * Limit how many Pages to delete.
     */
    limit?: number
  }

  /**
   * Page without action
   */
  export type PageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Page
     */
    select?: PageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Page
     */
    omit?: PageOmit<ExtArgs> | null
  }


  /**
   * Model UserPreferences
   */

  export type AggregateUserPreferences = {
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  export type UserPreferencesAvgAggregateOutputType = {
    maxBudget: number | null
    travelFlexibility: number | null
  }

  export type UserPreferencesSumAggregateOutputType = {
    maxBudget: number | null
    travelFlexibility: number | null
  }

  export type UserPreferencesMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deliveryFrequency: string | null
    maxBudget: number | null
    travelFlexibility: number | null
    currency: string | null
    headerImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deliveryFrequency: string | null
    maxBudget: number | null
    travelFlexibility: number | null
    currency: string | null
    headerImageUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPreferencesCountAggregateOutputType = {
    id: number
    userId: number
    homeAirports: number
    dreamDestinations: number
    deliveryFrequency: number
    maxBudget: number
    preferredAirlines: number
    travelFlexibility: number
    currency: number
    headerImageUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPreferencesAvgAggregateInputType = {
    maxBudget?: true
    travelFlexibility?: true
  }

  export type UserPreferencesSumAggregateInputType = {
    maxBudget?: true
    travelFlexibility?: true
  }

  export type UserPreferencesMinAggregateInputType = {
    id?: true
    userId?: true
    deliveryFrequency?: true
    maxBudget?: true
    travelFlexibility?: true
    currency?: true
    headerImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesMaxAggregateInputType = {
    id?: true
    userId?: true
    deliveryFrequency?: true
    maxBudget?: true
    travelFlexibility?: true
    currency?: true
    headerImageUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPreferencesCountAggregateInputType = {
    id?: true
    userId?: true
    homeAirports?: true
    dreamDestinations?: true
    deliveryFrequency?: true
    maxBudget?: true
    preferredAirlines?: true
    travelFlexibility?: true
    currency?: true
    headerImageUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPreferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to aggregate.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPreferences
    **/
    _count?: true | UserPreferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserPreferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserPreferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPreferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type GetUserPreferencesAggregateType<T extends UserPreferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPreferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPreferences[P]>
      : GetScalarType<T[P], AggregateUserPreferences[P]>
  }




  export type UserPreferencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPreferencesWhereInput
    orderBy?: UserPreferencesOrderByWithAggregationInput | UserPreferencesOrderByWithAggregationInput[]
    by: UserPreferencesScalarFieldEnum[] | UserPreferencesScalarFieldEnum
    having?: UserPreferencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPreferencesCountAggregateInputType | true
    _avg?: UserPreferencesAvgAggregateInputType
    _sum?: UserPreferencesSumAggregateInputType
    _min?: UserPreferencesMinAggregateInputType
    _max?: UserPreferencesMaxAggregateInputType
  }

  export type UserPreferencesGroupByOutputType = {
    id: string
    userId: string
    homeAirports: JsonValue
    dreamDestinations: JsonValue
    deliveryFrequency: string
    maxBudget: number | null
    preferredAirlines: JsonValue | null
    travelFlexibility: number
    currency: string
    headerImageUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserPreferencesCountAggregateOutputType | null
    _avg: UserPreferencesAvgAggregateOutputType | null
    _sum: UserPreferencesSumAggregateOutputType | null
    _min: UserPreferencesMinAggregateOutputType | null
    _max: UserPreferencesMaxAggregateOutputType | null
  }

  type GetUserPreferencesGroupByPayload<T extends UserPreferencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPreferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPreferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserPreferencesGroupByOutputType[P]>
        }
      >
    >


  export type UserPreferencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    homeAirports?: boolean
    dreamDestinations?: boolean
    deliveryFrequency?: boolean
    maxBudget?: boolean
    preferredAirlines?: boolean
    travelFlexibility?: boolean
    currency?: boolean
    headerImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    homeAirports?: boolean
    dreamDestinations?: boolean
    deliveryFrequency?: boolean
    maxBudget?: boolean
    preferredAirlines?: boolean
    travelFlexibility?: boolean
    currency?: boolean
    headerImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    homeAirports?: boolean
    dreamDestinations?: boolean
    deliveryFrequency?: boolean
    maxBudget?: boolean
    preferredAirlines?: boolean
    travelFlexibility?: boolean
    currency?: boolean
    headerImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userPreferences"]>

  export type UserPreferencesSelectScalar = {
    id?: boolean
    userId?: boolean
    homeAirports?: boolean
    dreamDestinations?: boolean
    deliveryFrequency?: boolean
    maxBudget?: boolean
    preferredAirlines?: boolean
    travelFlexibility?: boolean
    currency?: boolean
    headerImageUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPreferencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "homeAirports" | "dreamDestinations" | "deliveryFrequency" | "maxBudget" | "preferredAirlines" | "travelFlexibility" | "currency" | "headerImageUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["userPreferences"]>
  export type UserPreferencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserPreferencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserPreferencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPreferences"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      homeAirports: Prisma.JsonValue
      dreamDestinations: Prisma.JsonValue
      deliveryFrequency: string
      maxBudget: number | null
      preferredAirlines: Prisma.JsonValue | null
      travelFlexibility: number
      currency: string
      headerImageUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPreferences"]>
    composites: {}
  }

  type UserPreferencesGetPayload<S extends boolean | null | undefined | UserPreferencesDefaultArgs> = $Result.GetResult<Prisma.$UserPreferencesPayload, S>

  type UserPreferencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPreferencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPreferencesCountAggregateInputType | true
    }

  export interface UserPreferencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPreferences'], meta: { name: 'UserPreferences' } }
    /**
     * Find zero or one UserPreferences that matches the filter.
     * @param {UserPreferencesFindUniqueArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPreferencesFindUniqueArgs>(args: SelectSubset<T, UserPreferencesFindUniqueArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one UserPreferences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPreferencesFindUniqueOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPreferencesFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPreferencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPreferencesFindFirstArgs>(args?: SelectSubset<T, UserPreferencesFindFirstArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first UserPreferences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindFirstOrThrowArgs} args - Arguments to find a UserPreferences
     * @example
     * // Get one UserPreferences
     * const userPreferences = await prisma.userPreferences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPreferencesFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPreferencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more UserPreferences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany()
     * 
     * // Get first 10 UserPreferences
     * const userPreferences = await prisma.userPreferences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPreferencesFindManyArgs>(args?: SelectSubset<T, UserPreferencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a UserPreferences.
     * @param {UserPreferencesCreateArgs} args - Arguments to create a UserPreferences.
     * @example
     * // Create one UserPreferences
     * const UserPreferences = await prisma.userPreferences.create({
     *   data: {
     *     // ... data to create a UserPreferences
     *   }
     * })
     * 
     */
    create<T extends UserPreferencesCreateArgs>(args: SelectSubset<T, UserPreferencesCreateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many UserPreferences.
     * @param {UserPreferencesCreateManyArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPreferencesCreateManyArgs>(args?: SelectSubset<T, UserPreferencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPreferences and returns the data saved in the database.
     * @param {UserPreferencesCreateManyAndReturnArgs} args - Arguments to create many UserPreferences.
     * @example
     * // Create many UserPreferences
     * const userPreferences = await prisma.userPreferences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPreferencesCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPreferencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a UserPreferences.
     * @param {UserPreferencesDeleteArgs} args - Arguments to delete one UserPreferences.
     * @example
     * // Delete one UserPreferences
     * const UserPreferences = await prisma.userPreferences.delete({
     *   where: {
     *     // ... filter to delete one UserPreferences
     *   }
     * })
     * 
     */
    delete<T extends UserPreferencesDeleteArgs>(args: SelectSubset<T, UserPreferencesDeleteArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one UserPreferences.
     * @param {UserPreferencesUpdateArgs} args - Arguments to update one UserPreferences.
     * @example
     * // Update one UserPreferences
     * const userPreferences = await prisma.userPreferences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPreferencesUpdateArgs>(args: SelectSubset<T, UserPreferencesUpdateArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more UserPreferences.
     * @param {UserPreferencesDeleteManyArgs} args - Arguments to filter UserPreferences to delete.
     * @example
     * // Delete a few UserPreferences
     * const { count } = await prisma.userPreferences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPreferencesDeleteManyArgs>(args?: SelectSubset<T, UserPreferencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPreferencesUpdateManyArgs>(args: SelectSubset<T, UserPreferencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPreferences and returns the data updated in the database.
     * @param {UserPreferencesUpdateManyAndReturnArgs} args - Arguments to update many UserPreferences.
     * @example
     * // Update many UserPreferences
     * const userPreferences = await prisma.userPreferences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPreferences and only return the `id`
     * const userPreferencesWithIdOnly = await prisma.userPreferences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPreferencesUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPreferencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one UserPreferences.
     * @param {UserPreferencesUpsertArgs} args - Arguments to update or create a UserPreferences.
     * @example
     * // Update or create a UserPreferences
     * const userPreferences = await prisma.userPreferences.upsert({
     *   create: {
     *     // ... data to create a UserPreferences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPreferences we want to update
     *   }
     * })
     */
    upsert<T extends UserPreferencesUpsertArgs>(args: SelectSubset<T, UserPreferencesUpsertArgs<ExtArgs>>): Prisma__UserPreferencesClient<$Result.GetResult<Prisma.$UserPreferencesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesCountArgs} args - Arguments to filter UserPreferences to count.
     * @example
     * // Count the number of UserPreferences
     * const count = await prisma.userPreferences.count({
     *   where: {
     *     // ... the filter for the UserPreferences we want to count
     *   }
     * })
    **/
    count<T extends UserPreferencesCountArgs>(
      args?: Subset<T, UserPreferencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPreferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPreferencesAggregateArgs>(args: Subset<T, UserPreferencesAggregateArgs>): Prisma.PrismaPromise<GetUserPreferencesAggregateType<T>>

    /**
     * Group by UserPreferences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPreferencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPreferencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPreferencesGroupByArgs['orderBy'] }
        : { orderBy?: UserPreferencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPreferencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPreferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPreferences model
   */
  readonly fields: UserPreferencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPreferences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPreferencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPreferences model
   */ 
  interface UserPreferencesFieldRefs {
    readonly id: FieldRef<"UserPreferences", 'String'>
    readonly userId: FieldRef<"UserPreferences", 'String'>
    readonly homeAirports: FieldRef<"UserPreferences", 'Json'>
    readonly dreamDestinations: FieldRef<"UserPreferences", 'Json'>
    readonly deliveryFrequency: FieldRef<"UserPreferences", 'String'>
    readonly maxBudget: FieldRef<"UserPreferences", 'Float'>
    readonly preferredAirlines: FieldRef<"UserPreferences", 'Json'>
    readonly travelFlexibility: FieldRef<"UserPreferences", 'Int'>
    readonly currency: FieldRef<"UserPreferences", 'String'>
    readonly headerImageUrl: FieldRef<"UserPreferences", 'String'>
    readonly createdAt: FieldRef<"UserPreferences", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPreferences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPreferences findUnique
   */
  export type UserPreferencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findUniqueOrThrow
   */
  export type UserPreferencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences findFirst
   */
  export type UserPreferencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findFirstOrThrow
   */
  export type UserPreferencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPreferences.
     */
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences findMany
   */
  export type UserPreferencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter, which UserPreferences to fetch.
     */
    where?: UserPreferencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPreferences to fetch.
     */
    orderBy?: UserPreferencesOrderByWithRelationInput | UserPreferencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPreferences.
     */
    cursor?: UserPreferencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPreferences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPreferences.
     */
    skip?: number
    distinct?: UserPreferencesScalarFieldEnum | UserPreferencesScalarFieldEnum[]
  }

  /**
   * UserPreferences create
   */
  export type UserPreferencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserPreferences.
     */
    data: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
  }

  /**
   * UserPreferences createMany
   */
  export type UserPreferencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPreferences createManyAndReturn
   */
  export type UserPreferencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to create many UserPreferences.
     */
    data: UserPreferencesCreateManyInput | UserPreferencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences update
   */
  export type UserPreferencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserPreferences.
     */
    data: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
    /**
     * Choose, which UserPreferences to update.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences updateMany
   */
  export type UserPreferencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
  }

  /**
   * UserPreferences updateManyAndReturn
   */
  export type UserPreferencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * The data used to update UserPreferences.
     */
    data: XOR<UserPreferencesUpdateManyMutationInput, UserPreferencesUncheckedUpdateManyInput>
    /**
     * Filter which UserPreferences to update
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserPreferences upsert
   */
  export type UserPreferencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserPreferences to update in case it exists.
     */
    where: UserPreferencesWhereUniqueInput
    /**
     * In case the UserPreferences found by the `where` argument doesn't exist, create a new UserPreferences with this data.
     */
    create: XOR<UserPreferencesCreateInput, UserPreferencesUncheckedCreateInput>
    /**
     * In case the UserPreferences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPreferencesUpdateInput, UserPreferencesUncheckedUpdateInput>
  }

  /**
   * UserPreferences delete
   */
  export type UserPreferencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
    /**
     * Filter which UserPreferences to delete.
     */
    where: UserPreferencesWhereUniqueInput
  }

  /**
   * UserPreferences deleteMany
   */
  export type UserPreferencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPreferences to delete
     */
    where?: UserPreferencesWhereInput
    /**
     * Limit how many UserPreferences to delete.
     */
    limit?: number
  }

  /**
   * UserPreferences without action
   */
  export type UserPreferencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPreferences
     */
    select?: UserPreferencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPreferences
     */
    omit?: UserPreferencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserPreferencesInclude<ExtArgs> | null
  }


  /**
   * Model FlightRecommendation
   */

  export type AggregateFlightRecommendation = {
    _count: FlightRecommendationCountAggregateOutputType | null
    _avg: FlightRecommendationAvgAggregateOutputType | null
    _sum: FlightRecommendationSumAggregateOutputType | null
    _min: FlightRecommendationMinAggregateOutputType | null
    _max: FlightRecommendationMaxAggregateOutputType | null
  }

  export type FlightRecommendationAvgAggregateOutputType = {
    price: number | null
    confidenceScore: number | null
  }

  export type FlightRecommendationSumAggregateOutputType = {
    price: number | null
    confidenceScore: number | null
  }

  export type FlightRecommendationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    origin: string | null
    destination: string | null
    departureDate: Date | null
    returnDate: Date | null
    price: number | null
    currency: string | null
    airline: string | null
    flightNumber: string | null
    duration: string | null
    aiSummary: string | null
    confidenceScore: number | null
    dealQuality: string | null
    bookingUrl: string | null
    otaUrl: string | null
    cityImageUrl: string | null
    searchDate: Date | null
    isActive: boolean | null
    isWatched: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightRecommendationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    origin: string | null
    destination: string | null
    departureDate: Date | null
    returnDate: Date | null
    price: number | null
    currency: string | null
    airline: string | null
    flightNumber: string | null
    duration: string | null
    aiSummary: string | null
    confidenceScore: number | null
    dealQuality: string | null
    bookingUrl: string | null
    otaUrl: string | null
    cityImageUrl: string | null
    searchDate: Date | null
    isActive: boolean | null
    isWatched: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlightRecommendationCountAggregateOutputType = {
    id: number
    userId: number
    origin: number
    destination: number
    departureDate: number
    returnDate: number
    price: number
    currency: number
    airline: number
    flightNumber: number
    layovers: number
    duration: number
    baggageInfo: number
    aiSummary: number
    confidenceScore: number
    dealQuality: number
    bookingUrl: number
    otaUrl: number
    cityImageUrl: number
    cityActivities: number
    searchDate: number
    isActive: number
    isWatched: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlightRecommendationAvgAggregateInputType = {
    price?: true
    confidenceScore?: true
  }

  export type FlightRecommendationSumAggregateInputType = {
    price?: true
    confidenceScore?: true
  }

  export type FlightRecommendationMinAggregateInputType = {
    id?: true
    userId?: true
    origin?: true
    destination?: true
    departureDate?: true
    returnDate?: true
    price?: true
    currency?: true
    airline?: true
    flightNumber?: true
    duration?: true
    aiSummary?: true
    confidenceScore?: true
    dealQuality?: true
    bookingUrl?: true
    otaUrl?: true
    cityImageUrl?: true
    searchDate?: true
    isActive?: true
    isWatched?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightRecommendationMaxAggregateInputType = {
    id?: true
    userId?: true
    origin?: true
    destination?: true
    departureDate?: true
    returnDate?: true
    price?: true
    currency?: true
    airline?: true
    flightNumber?: true
    duration?: true
    aiSummary?: true
    confidenceScore?: true
    dealQuality?: true
    bookingUrl?: true
    otaUrl?: true
    cityImageUrl?: true
    searchDate?: true
    isActive?: true
    isWatched?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlightRecommendationCountAggregateInputType = {
    id?: true
    userId?: true
    origin?: true
    destination?: true
    departureDate?: true
    returnDate?: true
    price?: true
    currency?: true
    airline?: true
    flightNumber?: true
    layovers?: true
    duration?: true
    baggageInfo?: true
    aiSummary?: true
    confidenceScore?: true
    dealQuality?: true
    bookingUrl?: true
    otaUrl?: true
    cityImageUrl?: true
    cityActivities?: true
    searchDate?: true
    isActive?: true
    isWatched?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlightRecommendationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightRecommendation to aggregate.
     */
    where?: FlightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRecommendations to fetch.
     */
    orderBy?: FlightRecommendationOrderByWithRelationInput | FlightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FlightRecommendations
    **/
    _count?: true | FlightRecommendationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FlightRecommendationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FlightRecommendationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlightRecommendationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlightRecommendationMaxAggregateInputType
  }

  export type GetFlightRecommendationAggregateType<T extends FlightRecommendationAggregateArgs> = {
        [P in keyof T & keyof AggregateFlightRecommendation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlightRecommendation[P]>
      : GetScalarType<T[P], AggregateFlightRecommendation[P]>
  }




  export type FlightRecommendationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlightRecommendationWhereInput
    orderBy?: FlightRecommendationOrderByWithAggregationInput | FlightRecommendationOrderByWithAggregationInput[]
    by: FlightRecommendationScalarFieldEnum[] | FlightRecommendationScalarFieldEnum
    having?: FlightRecommendationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlightRecommendationCountAggregateInputType | true
    _avg?: FlightRecommendationAvgAggregateInputType
    _sum?: FlightRecommendationSumAggregateInputType
    _min?: FlightRecommendationMinAggregateInputType
    _max?: FlightRecommendationMaxAggregateInputType
  }

  export type FlightRecommendationGroupByOutputType = {
    id: string
    userId: string
    origin: string
    destination: string
    departureDate: Date
    returnDate: Date | null
    price: number
    currency: string
    airline: string
    flightNumber: string | null
    layovers: JsonValue | null
    duration: string | null
    baggageInfo: JsonValue | null
    aiSummary: string | null
    confidenceScore: number | null
    dealQuality: string | null
    bookingUrl: string | null
    otaUrl: string | null
    cityImageUrl: string | null
    cityActivities: JsonValue | null
    searchDate: Date
    isActive: boolean
    isWatched: boolean
    createdAt: Date
    updatedAt: Date
    _count: FlightRecommendationCountAggregateOutputType | null
    _avg: FlightRecommendationAvgAggregateOutputType | null
    _sum: FlightRecommendationSumAggregateOutputType | null
    _min: FlightRecommendationMinAggregateOutputType | null
    _max: FlightRecommendationMaxAggregateOutputType | null
  }

  type GetFlightRecommendationGroupByPayload<T extends FlightRecommendationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlightRecommendationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlightRecommendationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlightRecommendationGroupByOutputType[P]>
            : GetScalarType<T[P], FlightRecommendationGroupByOutputType[P]>
        }
      >
    >


  export type FlightRecommendationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    origin?: boolean
    destination?: boolean
    departureDate?: boolean
    returnDate?: boolean
    price?: boolean
    currency?: boolean
    airline?: boolean
    flightNumber?: boolean
    layovers?: boolean
    duration?: boolean
    baggageInfo?: boolean
    aiSummary?: boolean
    confidenceScore?: boolean
    dealQuality?: boolean
    bookingUrl?: boolean
    otaUrl?: boolean
    cityImageUrl?: boolean
    cityActivities?: boolean
    searchDate?: boolean
    isActive?: boolean
    isWatched?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightRecommendation"]>

  export type FlightRecommendationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    origin?: boolean
    destination?: boolean
    departureDate?: boolean
    returnDate?: boolean
    price?: boolean
    currency?: boolean
    airline?: boolean
    flightNumber?: boolean
    layovers?: boolean
    duration?: boolean
    baggageInfo?: boolean
    aiSummary?: boolean
    confidenceScore?: boolean
    dealQuality?: boolean
    bookingUrl?: boolean
    otaUrl?: boolean
    cityImageUrl?: boolean
    cityActivities?: boolean
    searchDate?: boolean
    isActive?: boolean
    isWatched?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightRecommendation"]>

  export type FlightRecommendationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    origin?: boolean
    destination?: boolean
    departureDate?: boolean
    returnDate?: boolean
    price?: boolean
    currency?: boolean
    airline?: boolean
    flightNumber?: boolean
    layovers?: boolean
    duration?: boolean
    baggageInfo?: boolean
    aiSummary?: boolean
    confidenceScore?: boolean
    dealQuality?: boolean
    bookingUrl?: boolean
    otaUrl?: boolean
    cityImageUrl?: boolean
    cityActivities?: boolean
    searchDate?: boolean
    isActive?: boolean
    isWatched?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["flightRecommendation"]>

  export type FlightRecommendationSelectScalar = {
    id?: boolean
    userId?: boolean
    origin?: boolean
    destination?: boolean
    departureDate?: boolean
    returnDate?: boolean
    price?: boolean
    currency?: boolean
    airline?: boolean
    flightNumber?: boolean
    layovers?: boolean
    duration?: boolean
    baggageInfo?: boolean
    aiSummary?: boolean
    confidenceScore?: boolean
    dealQuality?: boolean
    bookingUrl?: boolean
    otaUrl?: boolean
    cityImageUrl?: boolean
    cityActivities?: boolean
    searchDate?: boolean
    isActive?: boolean
    isWatched?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlightRecommendationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "origin" | "destination" | "departureDate" | "returnDate" | "price" | "currency" | "airline" | "flightNumber" | "layovers" | "duration" | "baggageInfo" | "aiSummary" | "confidenceScore" | "dealQuality" | "bookingUrl" | "otaUrl" | "cityImageUrl" | "cityActivities" | "searchDate" | "isActive" | "isWatched" | "createdAt" | "updatedAt", ExtArgs["result"]["flightRecommendation"]>
  export type FlightRecommendationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlightRecommendationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FlightRecommendationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FlightRecommendationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FlightRecommendation"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      origin: string
      destination: string
      departureDate: Date
      returnDate: Date | null
      price: number
      currency: string
      airline: string
      flightNumber: string | null
      layovers: Prisma.JsonValue | null
      duration: string | null
      baggageInfo: Prisma.JsonValue | null
      aiSummary: string | null
      confidenceScore: number | null
      dealQuality: string | null
      bookingUrl: string | null
      otaUrl: string | null
      cityImageUrl: string | null
      cityActivities: Prisma.JsonValue | null
      searchDate: Date
      isActive: boolean
      isWatched: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flightRecommendation"]>
    composites: {}
  }

  type FlightRecommendationGetPayload<S extends boolean | null | undefined | FlightRecommendationDefaultArgs> = $Result.GetResult<Prisma.$FlightRecommendationPayload, S>

  type FlightRecommendationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FlightRecommendationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FlightRecommendationCountAggregateInputType | true
    }

  export interface FlightRecommendationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FlightRecommendation'], meta: { name: 'FlightRecommendation' } }
    /**
     * Find zero or one FlightRecommendation that matches the filter.
     * @param {FlightRecommendationFindUniqueArgs} args - Arguments to find a FlightRecommendation
     * @example
     * // Get one FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlightRecommendationFindUniqueArgs>(args: SelectSubset<T, FlightRecommendationFindUniqueArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one FlightRecommendation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FlightRecommendationFindUniqueOrThrowArgs} args - Arguments to find a FlightRecommendation
     * @example
     * // Get one FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlightRecommendationFindUniqueOrThrowArgs>(args: SelectSubset<T, FlightRecommendationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first FlightRecommendation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationFindFirstArgs} args - Arguments to find a FlightRecommendation
     * @example
     * // Get one FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlightRecommendationFindFirstArgs>(args?: SelectSubset<T, FlightRecommendationFindFirstArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first FlightRecommendation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationFindFirstOrThrowArgs} args - Arguments to find a FlightRecommendation
     * @example
     * // Get one FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlightRecommendationFindFirstOrThrowArgs>(args?: SelectSubset<T, FlightRecommendationFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more FlightRecommendations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FlightRecommendations
     * const flightRecommendations = await prisma.flightRecommendation.findMany()
     * 
     * // Get first 10 FlightRecommendations
     * const flightRecommendations = await prisma.flightRecommendation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flightRecommendationWithIdOnly = await prisma.flightRecommendation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlightRecommendationFindManyArgs>(args?: SelectSubset<T, FlightRecommendationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a FlightRecommendation.
     * @param {FlightRecommendationCreateArgs} args - Arguments to create a FlightRecommendation.
     * @example
     * // Create one FlightRecommendation
     * const FlightRecommendation = await prisma.flightRecommendation.create({
     *   data: {
     *     // ... data to create a FlightRecommendation
     *   }
     * })
     * 
     */
    create<T extends FlightRecommendationCreateArgs>(args: SelectSubset<T, FlightRecommendationCreateArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many FlightRecommendations.
     * @param {FlightRecommendationCreateManyArgs} args - Arguments to create many FlightRecommendations.
     * @example
     * // Create many FlightRecommendations
     * const flightRecommendation = await prisma.flightRecommendation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlightRecommendationCreateManyArgs>(args?: SelectSubset<T, FlightRecommendationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FlightRecommendations and returns the data saved in the database.
     * @param {FlightRecommendationCreateManyAndReturnArgs} args - Arguments to create many FlightRecommendations.
     * @example
     * // Create many FlightRecommendations
     * const flightRecommendation = await prisma.flightRecommendation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FlightRecommendations and only return the `id`
     * const flightRecommendationWithIdOnly = await prisma.flightRecommendation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlightRecommendationCreateManyAndReturnArgs>(args?: SelectSubset<T, FlightRecommendationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a FlightRecommendation.
     * @param {FlightRecommendationDeleteArgs} args - Arguments to delete one FlightRecommendation.
     * @example
     * // Delete one FlightRecommendation
     * const FlightRecommendation = await prisma.flightRecommendation.delete({
     *   where: {
     *     // ... filter to delete one FlightRecommendation
     *   }
     * })
     * 
     */
    delete<T extends FlightRecommendationDeleteArgs>(args: SelectSubset<T, FlightRecommendationDeleteArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one FlightRecommendation.
     * @param {FlightRecommendationUpdateArgs} args - Arguments to update one FlightRecommendation.
     * @example
     * // Update one FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlightRecommendationUpdateArgs>(args: SelectSubset<T, FlightRecommendationUpdateArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more FlightRecommendations.
     * @param {FlightRecommendationDeleteManyArgs} args - Arguments to filter FlightRecommendations to delete.
     * @example
     * // Delete a few FlightRecommendations
     * const { count } = await prisma.flightRecommendation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlightRecommendationDeleteManyArgs>(args?: SelectSubset<T, FlightRecommendationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FlightRecommendations
     * const flightRecommendation = await prisma.flightRecommendation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlightRecommendationUpdateManyArgs>(args: SelectSubset<T, FlightRecommendationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FlightRecommendations and returns the data updated in the database.
     * @param {FlightRecommendationUpdateManyAndReturnArgs} args - Arguments to update many FlightRecommendations.
     * @example
     * // Update many FlightRecommendations
     * const flightRecommendation = await prisma.flightRecommendation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FlightRecommendations and only return the `id`
     * const flightRecommendationWithIdOnly = await prisma.flightRecommendation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FlightRecommendationUpdateManyAndReturnArgs>(args: SelectSubset<T, FlightRecommendationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one FlightRecommendation.
     * @param {FlightRecommendationUpsertArgs} args - Arguments to update or create a FlightRecommendation.
     * @example
     * // Update or create a FlightRecommendation
     * const flightRecommendation = await prisma.flightRecommendation.upsert({
     *   create: {
     *     // ... data to create a FlightRecommendation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FlightRecommendation we want to update
     *   }
     * })
     */
    upsert<T extends FlightRecommendationUpsertArgs>(args: SelectSubset<T, FlightRecommendationUpsertArgs<ExtArgs>>): Prisma__FlightRecommendationClient<$Result.GetResult<Prisma.$FlightRecommendationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of FlightRecommendations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationCountArgs} args - Arguments to filter FlightRecommendations to count.
     * @example
     * // Count the number of FlightRecommendations
     * const count = await prisma.flightRecommendation.count({
     *   where: {
     *     // ... the filter for the FlightRecommendations we want to count
     *   }
     * })
    **/
    count<T extends FlightRecommendationCountArgs>(
      args?: Subset<T, FlightRecommendationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlightRecommendationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FlightRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlightRecommendationAggregateArgs>(args: Subset<T, FlightRecommendationAggregateArgs>): Prisma.PrismaPromise<GetFlightRecommendationAggregateType<T>>

    /**
     * Group by FlightRecommendation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlightRecommendationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlightRecommendationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlightRecommendationGroupByArgs['orderBy'] }
        : { orderBy?: FlightRecommendationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlightRecommendationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlightRecommendationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FlightRecommendation model
   */
  readonly fields: FlightRecommendationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FlightRecommendation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlightRecommendationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FlightRecommendation model
   */ 
  interface FlightRecommendationFieldRefs {
    readonly id: FieldRef<"FlightRecommendation", 'String'>
    readonly userId: FieldRef<"FlightRecommendation", 'String'>
    readonly origin: FieldRef<"FlightRecommendation", 'String'>
    readonly destination: FieldRef<"FlightRecommendation", 'String'>
    readonly departureDate: FieldRef<"FlightRecommendation", 'DateTime'>
    readonly returnDate: FieldRef<"FlightRecommendation", 'DateTime'>
    readonly price: FieldRef<"FlightRecommendation", 'Float'>
    readonly currency: FieldRef<"FlightRecommendation", 'String'>
    readonly airline: FieldRef<"FlightRecommendation", 'String'>
    readonly flightNumber: FieldRef<"FlightRecommendation", 'String'>
    readonly layovers: FieldRef<"FlightRecommendation", 'Json'>
    readonly duration: FieldRef<"FlightRecommendation", 'String'>
    readonly baggageInfo: FieldRef<"FlightRecommendation", 'Json'>
    readonly aiSummary: FieldRef<"FlightRecommendation", 'String'>
    readonly confidenceScore: FieldRef<"FlightRecommendation", 'Float'>
    readonly dealQuality: FieldRef<"FlightRecommendation", 'String'>
    readonly bookingUrl: FieldRef<"FlightRecommendation", 'String'>
    readonly otaUrl: FieldRef<"FlightRecommendation", 'String'>
    readonly cityImageUrl: FieldRef<"FlightRecommendation", 'String'>
    readonly cityActivities: FieldRef<"FlightRecommendation", 'Json'>
    readonly searchDate: FieldRef<"FlightRecommendation", 'DateTime'>
    readonly isActive: FieldRef<"FlightRecommendation", 'Boolean'>
    readonly isWatched: FieldRef<"FlightRecommendation", 'Boolean'>
    readonly createdAt: FieldRef<"FlightRecommendation", 'DateTime'>
    readonly updatedAt: FieldRef<"FlightRecommendation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FlightRecommendation findUnique
   */
  export type FlightRecommendationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which FlightRecommendation to fetch.
     */
    where: FlightRecommendationWhereUniqueInput
  }

  /**
   * FlightRecommendation findUniqueOrThrow
   */
  export type FlightRecommendationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which FlightRecommendation to fetch.
     */
    where: FlightRecommendationWhereUniqueInput
  }

  /**
   * FlightRecommendation findFirst
   */
  export type FlightRecommendationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which FlightRecommendation to fetch.
     */
    where?: FlightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRecommendations to fetch.
     */
    orderBy?: FlightRecommendationOrderByWithRelationInput | FlightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightRecommendations.
     */
    cursor?: FlightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightRecommendations.
     */
    distinct?: FlightRecommendationScalarFieldEnum | FlightRecommendationScalarFieldEnum[]
  }

  /**
   * FlightRecommendation findFirstOrThrow
   */
  export type FlightRecommendationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which FlightRecommendation to fetch.
     */
    where?: FlightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRecommendations to fetch.
     */
    orderBy?: FlightRecommendationOrderByWithRelationInput | FlightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FlightRecommendations.
     */
    cursor?: FlightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRecommendations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FlightRecommendations.
     */
    distinct?: FlightRecommendationScalarFieldEnum | FlightRecommendationScalarFieldEnum[]
  }

  /**
   * FlightRecommendation findMany
   */
  export type FlightRecommendationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter, which FlightRecommendations to fetch.
     */
    where?: FlightRecommendationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FlightRecommendations to fetch.
     */
    orderBy?: FlightRecommendationOrderByWithRelationInput | FlightRecommendationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FlightRecommendations.
     */
    cursor?: FlightRecommendationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FlightRecommendations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FlightRecommendations.
     */
    skip?: number
    distinct?: FlightRecommendationScalarFieldEnum | FlightRecommendationScalarFieldEnum[]
  }

  /**
   * FlightRecommendation create
   */
  export type FlightRecommendationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to create a FlightRecommendation.
     */
    data: XOR<FlightRecommendationCreateInput, FlightRecommendationUncheckedCreateInput>
  }

  /**
   * FlightRecommendation createMany
   */
  export type FlightRecommendationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FlightRecommendations.
     */
    data: FlightRecommendationCreateManyInput | FlightRecommendationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FlightRecommendation createManyAndReturn
   */
  export type FlightRecommendationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * The data used to create many FlightRecommendations.
     */
    data: FlightRecommendationCreateManyInput | FlightRecommendationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlightRecommendation update
   */
  export type FlightRecommendationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * The data needed to update a FlightRecommendation.
     */
    data: XOR<FlightRecommendationUpdateInput, FlightRecommendationUncheckedUpdateInput>
    /**
     * Choose, which FlightRecommendation to update.
     */
    where: FlightRecommendationWhereUniqueInput
  }

  /**
   * FlightRecommendation updateMany
   */
  export type FlightRecommendationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FlightRecommendations.
     */
    data: XOR<FlightRecommendationUpdateManyMutationInput, FlightRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which FlightRecommendations to update
     */
    where?: FlightRecommendationWhereInput
    /**
     * Limit how many FlightRecommendations to update.
     */
    limit?: number
  }

  /**
   * FlightRecommendation updateManyAndReturn
   */
  export type FlightRecommendationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * The data used to update FlightRecommendations.
     */
    data: XOR<FlightRecommendationUpdateManyMutationInput, FlightRecommendationUncheckedUpdateManyInput>
    /**
     * Filter which FlightRecommendations to update
     */
    where?: FlightRecommendationWhereInput
    /**
     * Limit how many FlightRecommendations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FlightRecommendation upsert
   */
  export type FlightRecommendationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * The filter to search for the FlightRecommendation to update in case it exists.
     */
    where: FlightRecommendationWhereUniqueInput
    /**
     * In case the FlightRecommendation found by the `where` argument doesn't exist, create a new FlightRecommendation with this data.
     */
    create: XOR<FlightRecommendationCreateInput, FlightRecommendationUncheckedCreateInput>
    /**
     * In case the FlightRecommendation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlightRecommendationUpdateInput, FlightRecommendationUncheckedUpdateInput>
  }

  /**
   * FlightRecommendation delete
   */
  export type FlightRecommendationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
    /**
     * Filter which FlightRecommendation to delete.
     */
    where: FlightRecommendationWhereUniqueInput
  }

  /**
   * FlightRecommendation deleteMany
   */
  export type FlightRecommendationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FlightRecommendations to delete
     */
    where?: FlightRecommendationWhereInput
    /**
     * Limit how many FlightRecommendations to delete.
     */
    limit?: number
  }

  /**
   * FlightRecommendation without action
   */
  export type FlightRecommendationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FlightRecommendation
     */
    select?: FlightRecommendationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FlightRecommendation
     */
    omit?: FlightRecommendationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlightRecommendationInclude<ExtArgs> | null
  }


  /**
   * Model StripeSubscription
   */

  export type AggregateStripeSubscription = {
    _count: StripeSubscriptionCountAggregateOutputType | null
    _avg: StripeSubscriptionAvgAggregateOutputType | null
    _sum: StripeSubscriptionSumAggregateOutputType | null
    _min: StripeSubscriptionMinAggregateOutputType | null
    _max: StripeSubscriptionMaxAggregateOutputType | null
  }

  export type StripeSubscriptionAvgAggregateOutputType = {
    amount: number | null
  }

  export type StripeSubscriptionSumAggregateOutputType = {
    amount: number | null
  }

  export type StripeSubscriptionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    amount: number | null
    currency: string | null
    interval: string | null
    trialEnd: Date | null
    canceledAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeSubscriptionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    stripeCustomerId: string | null
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    status: string | null
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean | null
    amount: number | null
    currency: string | null
    interval: string | null
    trialEnd: Date | null
    canceledAt: Date | null
    endedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StripeSubscriptionCountAggregateOutputType = {
    id: number
    userId: number
    stripeCustomerId: number
    stripeSubscriptionId: number
    stripePriceId: number
    status: number
    currentPeriodStart: number
    currentPeriodEnd: number
    cancelAtPeriodEnd: number
    amount: number
    currency: number
    interval: number
    trialEnd: number
    canceledAt: number
    endedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StripeSubscriptionAvgAggregateInputType = {
    amount?: true
  }

  export type StripeSubscriptionSumAggregateInputType = {
    amount?: true
  }

  export type StripeSubscriptionMinAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    trialEnd?: true
    canceledAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeSubscriptionMaxAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    trialEnd?: true
    canceledAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StripeSubscriptionCountAggregateInputType = {
    id?: true
    userId?: true
    stripeCustomerId?: true
    stripeSubscriptionId?: true
    stripePriceId?: true
    status?: true
    currentPeriodStart?: true
    currentPeriodEnd?: true
    cancelAtPeriodEnd?: true
    amount?: true
    currency?: true
    interval?: true
    trialEnd?: true
    canceledAt?: true
    endedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StripeSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeSubscription to aggregate.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StripeSubscriptions
    **/
    _count?: true | StripeSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StripeSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StripeSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StripeSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StripeSubscriptionMaxAggregateInputType
  }

  export type GetStripeSubscriptionAggregateType<T extends StripeSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateStripeSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStripeSubscription[P]>
      : GetScalarType<T[P], AggregateStripeSubscription[P]>
  }




  export type StripeSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StripeSubscriptionWhereInput
    orderBy?: StripeSubscriptionOrderByWithAggregationInput | StripeSubscriptionOrderByWithAggregationInput[]
    by: StripeSubscriptionScalarFieldEnum[] | StripeSubscriptionScalarFieldEnum
    having?: StripeSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StripeSubscriptionCountAggregateInputType | true
    _avg?: StripeSubscriptionAvgAggregateInputType
    _sum?: StripeSubscriptionSumAggregateInputType
    _min?: StripeSubscriptionMinAggregateInputType
    _max?: StripeSubscriptionMaxAggregateInputType
  }

  export type StripeSubscriptionGroupByOutputType = {
    id: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId: string | null
    stripePriceId: string | null
    status: string
    currentPeriodStart: Date | null
    currentPeriodEnd: Date | null
    cancelAtPeriodEnd: boolean
    amount: number
    currency: string
    interval: string
    trialEnd: Date | null
    canceledAt: Date | null
    endedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: StripeSubscriptionCountAggregateOutputType | null
    _avg: StripeSubscriptionAvgAggregateOutputType | null
    _sum: StripeSubscriptionSumAggregateOutputType | null
    _min: StripeSubscriptionMinAggregateOutputType | null
    _max: StripeSubscriptionMaxAggregateOutputType | null
  }

  type GetStripeSubscriptionGroupByPayload<T extends StripeSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StripeSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StripeSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StripeSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], StripeSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type StripeSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    trialEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeSubscription"]>

  export type StripeSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    trialEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeSubscription"]>

  export type StripeSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    trialEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stripeSubscription"]>

  export type StripeSubscriptionSelectScalar = {
    id?: boolean
    userId?: boolean
    stripeCustomerId?: boolean
    stripeSubscriptionId?: boolean
    stripePriceId?: boolean
    status?: boolean
    currentPeriodStart?: boolean
    currentPeriodEnd?: boolean
    cancelAtPeriodEnd?: boolean
    amount?: boolean
    currency?: boolean
    interval?: boolean
    trialEnd?: boolean
    canceledAt?: boolean
    endedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StripeSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId" | "stripePriceId" | "status" | "currentPeriodStart" | "currentPeriodEnd" | "cancelAtPeriodEnd" | "amount" | "currency" | "interval" | "trialEnd" | "canceledAt" | "endedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["stripeSubscription"]>
  export type StripeSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StripeSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type StripeSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $StripeSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StripeSubscription"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      stripeCustomerId: string
      stripeSubscriptionId: string | null
      stripePriceId: string | null
      status: string
      currentPeriodStart: Date | null
      currentPeriodEnd: Date | null
      cancelAtPeriodEnd: boolean
      amount: number
      currency: string
      interval: string
      trialEnd: Date | null
      canceledAt: Date | null
      endedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stripeSubscription"]>
    composites: {}
  }

  type StripeSubscriptionGetPayload<S extends boolean | null | undefined | StripeSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$StripeSubscriptionPayload, S>

  type StripeSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StripeSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StripeSubscriptionCountAggregateInputType | true
    }

  export interface StripeSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StripeSubscription'], meta: { name: 'StripeSubscription' } }
    /**
     * Find zero or one StripeSubscription that matches the filter.
     * @param {StripeSubscriptionFindUniqueArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StripeSubscriptionFindUniqueArgs>(args: SelectSubset<T, StripeSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one StripeSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StripeSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StripeSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first StripeSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindFirstArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StripeSubscriptionFindFirstArgs>(args?: SelectSubset<T, StripeSubscriptionFindFirstArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first StripeSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindFirstOrThrowArgs} args - Arguments to find a StripeSubscription
     * @example
     * // Get one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StripeSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, StripeSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more StripeSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StripeSubscriptions
     * const stripeSubscriptions = await prisma.stripeSubscription.findMany()
     * 
     * // Get first 10 StripeSubscriptions
     * const stripeSubscriptions = await prisma.stripeSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stripeSubscriptionWithIdOnly = await prisma.stripeSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StripeSubscriptionFindManyArgs>(args?: SelectSubset<T, StripeSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a StripeSubscription.
     * @param {StripeSubscriptionCreateArgs} args - Arguments to create a StripeSubscription.
     * @example
     * // Create one StripeSubscription
     * const StripeSubscription = await prisma.stripeSubscription.create({
     *   data: {
     *     // ... data to create a StripeSubscription
     *   }
     * })
     * 
     */
    create<T extends StripeSubscriptionCreateArgs>(args: SelectSubset<T, StripeSubscriptionCreateArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many StripeSubscriptions.
     * @param {StripeSubscriptionCreateManyArgs} args - Arguments to create many StripeSubscriptions.
     * @example
     * // Create many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StripeSubscriptionCreateManyArgs>(args?: SelectSubset<T, StripeSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StripeSubscriptions and returns the data saved in the database.
     * @param {StripeSubscriptionCreateManyAndReturnArgs} args - Arguments to create many StripeSubscriptions.
     * @example
     * // Create many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StripeSubscriptions and only return the `id`
     * const stripeSubscriptionWithIdOnly = await prisma.stripeSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StripeSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, StripeSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a StripeSubscription.
     * @param {StripeSubscriptionDeleteArgs} args - Arguments to delete one StripeSubscription.
     * @example
     * // Delete one StripeSubscription
     * const StripeSubscription = await prisma.stripeSubscription.delete({
     *   where: {
     *     // ... filter to delete one StripeSubscription
     *   }
     * })
     * 
     */
    delete<T extends StripeSubscriptionDeleteArgs>(args: SelectSubset<T, StripeSubscriptionDeleteArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one StripeSubscription.
     * @param {StripeSubscriptionUpdateArgs} args - Arguments to update one StripeSubscription.
     * @example
     * // Update one StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StripeSubscriptionUpdateArgs>(args: SelectSubset<T, StripeSubscriptionUpdateArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more StripeSubscriptions.
     * @param {StripeSubscriptionDeleteManyArgs} args - Arguments to filter StripeSubscriptions to delete.
     * @example
     * // Delete a few StripeSubscriptions
     * const { count } = await prisma.stripeSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StripeSubscriptionDeleteManyArgs>(args?: SelectSubset<T, StripeSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StripeSubscriptionUpdateManyArgs>(args: SelectSubset<T, StripeSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StripeSubscriptions and returns the data updated in the database.
     * @param {StripeSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many StripeSubscriptions.
     * @example
     * // Update many StripeSubscriptions
     * const stripeSubscription = await prisma.stripeSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StripeSubscriptions and only return the `id`
     * const stripeSubscriptionWithIdOnly = await prisma.stripeSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StripeSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, StripeSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one StripeSubscription.
     * @param {StripeSubscriptionUpsertArgs} args - Arguments to update or create a StripeSubscription.
     * @example
     * // Update or create a StripeSubscription
     * const stripeSubscription = await prisma.stripeSubscription.upsert({
     *   create: {
     *     // ... data to create a StripeSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StripeSubscription we want to update
     *   }
     * })
     */
    upsert<T extends StripeSubscriptionUpsertArgs>(args: SelectSubset<T, StripeSubscriptionUpsertArgs<ExtArgs>>): Prisma__StripeSubscriptionClient<$Result.GetResult<Prisma.$StripeSubscriptionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of StripeSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionCountArgs} args - Arguments to filter StripeSubscriptions to count.
     * @example
     * // Count the number of StripeSubscriptions
     * const count = await prisma.stripeSubscription.count({
     *   where: {
     *     // ... the filter for the StripeSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends StripeSubscriptionCountArgs>(
      args?: Subset<T, StripeSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StripeSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StripeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StripeSubscriptionAggregateArgs>(args: Subset<T, StripeSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetStripeSubscriptionAggregateType<T>>

    /**
     * Group by StripeSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StripeSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StripeSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StripeSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: StripeSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StripeSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStripeSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StripeSubscription model
   */
  readonly fields: StripeSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StripeSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StripeSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StripeSubscription model
   */ 
  interface StripeSubscriptionFieldRefs {
    readonly id: FieldRef<"StripeSubscription", 'String'>
    readonly userId: FieldRef<"StripeSubscription", 'String'>
    readonly stripeCustomerId: FieldRef<"StripeSubscription", 'String'>
    readonly stripeSubscriptionId: FieldRef<"StripeSubscription", 'String'>
    readonly stripePriceId: FieldRef<"StripeSubscription", 'String'>
    readonly status: FieldRef<"StripeSubscription", 'String'>
    readonly currentPeriodStart: FieldRef<"StripeSubscription", 'DateTime'>
    readonly currentPeriodEnd: FieldRef<"StripeSubscription", 'DateTime'>
    readonly cancelAtPeriodEnd: FieldRef<"StripeSubscription", 'Boolean'>
    readonly amount: FieldRef<"StripeSubscription", 'Float'>
    readonly currency: FieldRef<"StripeSubscription", 'String'>
    readonly interval: FieldRef<"StripeSubscription", 'String'>
    readonly trialEnd: FieldRef<"StripeSubscription", 'DateTime'>
    readonly canceledAt: FieldRef<"StripeSubscription", 'DateTime'>
    readonly endedAt: FieldRef<"StripeSubscription", 'DateTime'>
    readonly createdAt: FieldRef<"StripeSubscription", 'DateTime'>
    readonly updatedAt: FieldRef<"StripeSubscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StripeSubscription findUnique
   */
  export type StripeSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription findUniqueOrThrow
   */
  export type StripeSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription findFirst
   */
  export type StripeSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeSubscriptions.
     */
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription findFirstOrThrow
   */
  export type StripeSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscription to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StripeSubscriptions.
     */
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription findMany
   */
  export type StripeSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which StripeSubscriptions to fetch.
     */
    where?: StripeSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StripeSubscriptions to fetch.
     */
    orderBy?: StripeSubscriptionOrderByWithRelationInput | StripeSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StripeSubscriptions.
     */
    cursor?: StripeSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StripeSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StripeSubscriptions.
     */
    skip?: number
    distinct?: StripeSubscriptionScalarFieldEnum | StripeSubscriptionScalarFieldEnum[]
  }

  /**
   * StripeSubscription create
   */
  export type StripeSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a StripeSubscription.
     */
    data: XOR<StripeSubscriptionCreateInput, StripeSubscriptionUncheckedCreateInput>
  }

  /**
   * StripeSubscription createMany
   */
  export type StripeSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StripeSubscriptions.
     */
    data: StripeSubscriptionCreateManyInput | StripeSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StripeSubscription createManyAndReturn
   */
  export type StripeSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many StripeSubscriptions.
     */
    data: StripeSubscriptionCreateManyInput | StripeSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StripeSubscription update
   */
  export type StripeSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a StripeSubscription.
     */
    data: XOR<StripeSubscriptionUpdateInput, StripeSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which StripeSubscription to update.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription updateMany
   */
  export type StripeSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StripeSubscriptions.
     */
    data: XOR<StripeSubscriptionUpdateManyMutationInput, StripeSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which StripeSubscriptions to update
     */
    where?: StripeSubscriptionWhereInput
    /**
     * Limit how many StripeSubscriptions to update.
     */
    limit?: number
  }

  /**
   * StripeSubscription updateManyAndReturn
   */
  export type StripeSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update StripeSubscriptions.
     */
    data: XOR<StripeSubscriptionUpdateManyMutationInput, StripeSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which StripeSubscriptions to update
     */
    where?: StripeSubscriptionWhereInput
    /**
     * Limit how many StripeSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StripeSubscription upsert
   */
  export type StripeSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the StripeSubscription to update in case it exists.
     */
    where: StripeSubscriptionWhereUniqueInput
    /**
     * In case the StripeSubscription found by the `where` argument doesn't exist, create a new StripeSubscription with this data.
     */
    create: XOR<StripeSubscriptionCreateInput, StripeSubscriptionUncheckedCreateInput>
    /**
     * In case the StripeSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StripeSubscriptionUpdateInput, StripeSubscriptionUncheckedUpdateInput>
  }

  /**
   * StripeSubscription delete
   */
  export type StripeSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which StripeSubscription to delete.
     */
    where: StripeSubscriptionWhereUniqueInput
  }

  /**
   * StripeSubscription deleteMany
   */
  export type StripeSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StripeSubscriptions to delete
     */
    where?: StripeSubscriptionWhereInput
    /**
     * Limit how many StripeSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * StripeSubscription without action
   */
  export type StripeSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StripeSubscription
     */
    select?: StripeSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StripeSubscription
     */
    omit?: StripeSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StripeSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model EmailNotification
   */

  export type AggregateEmailNotification = {
    _count: EmailNotificationCountAggregateOutputType | null
    _avg: EmailNotificationAvgAggregateOutputType | null
    _sum: EmailNotificationSumAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  export type EmailNotificationAvgAggregateOutputType = {
    flightCount: number | null
  }

  export type EmailNotificationSumAggregateOutputType = {
    flightCount: number | null
  }

  export type EmailNotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    content: string | null
    recipientEmail: string | null
    notificationType: string | null
    flightCount: number | null
    status: string | null
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    sendGridMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailNotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    subject: string | null
    content: string | null
    recipientEmail: string | null
    notificationType: string | null
    flightCount: number | null
    status: string | null
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    sendGridMessageId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmailNotificationCountAggregateOutputType = {
    id: number
    userId: number
    subject: number
    content: number
    recipientEmail: number
    notificationType: number
    flightCount: number
    status: number
    sentAt: number
    failedAt: number
    errorMessage: number
    sendGridMessageId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmailNotificationAvgAggregateInputType = {
    flightCount?: true
  }

  export type EmailNotificationSumAggregateInputType = {
    flightCount?: true
  }

  export type EmailNotificationMinAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    content?: true
    recipientEmail?: true
    notificationType?: true
    flightCount?: true
    status?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    sendGridMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailNotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    content?: true
    recipientEmail?: true
    notificationType?: true
    flightCount?: true
    status?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    sendGridMessageId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmailNotificationCountAggregateInputType = {
    id?: true
    userId?: true
    subject?: true
    content?: true
    recipientEmail?: true
    notificationType?: true
    flightCount?: true
    status?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    sendGridMessageId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmailNotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotification to aggregate.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailNotifications
    **/
    _count?: true | EmailNotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailNotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailNotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailNotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type GetEmailNotificationAggregateType<T extends EmailNotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailNotification[P]>
      : GetScalarType<T[P], AggregateEmailNotification[P]>
  }




  export type EmailNotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailNotificationWhereInput
    orderBy?: EmailNotificationOrderByWithAggregationInput | EmailNotificationOrderByWithAggregationInput[]
    by: EmailNotificationScalarFieldEnum[] | EmailNotificationScalarFieldEnum
    having?: EmailNotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailNotificationCountAggregateInputType | true
    _avg?: EmailNotificationAvgAggregateInputType
    _sum?: EmailNotificationSumAggregateInputType
    _min?: EmailNotificationMinAggregateInputType
    _max?: EmailNotificationMaxAggregateInputType
  }

  export type EmailNotificationGroupByOutputType = {
    id: string
    userId: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount: number
    status: string
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    sendGridMessageId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmailNotificationCountAggregateOutputType | null
    _avg: EmailNotificationAvgAggregateOutputType | null
    _sum: EmailNotificationSumAggregateOutputType | null
    _min: EmailNotificationMinAggregateOutputType | null
    _max: EmailNotificationMaxAggregateOutputType | null
  }

  type GetEmailNotificationGroupByPayload<T extends EmailNotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailNotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailNotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
            : GetScalarType<T[P], EmailNotificationGroupByOutputType[P]>
        }
      >
    >


  export type EmailNotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    content?: boolean
    recipientEmail?: boolean
    notificationType?: boolean
    flightCount?: boolean
    status?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    sendGridMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    content?: boolean
    recipientEmail?: boolean
    notificationType?: boolean
    flightCount?: boolean
    status?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    sendGridMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    subject?: boolean
    content?: boolean
    recipientEmail?: boolean
    notificationType?: boolean
    flightCount?: boolean
    status?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    sendGridMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailNotification"]>

  export type EmailNotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    subject?: boolean
    content?: boolean
    recipientEmail?: boolean
    notificationType?: boolean
    flightCount?: boolean
    status?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    sendGridMessageId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmailNotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "subject" | "content" | "recipientEmail" | "notificationType" | "flightCount" | "status" | "sentAt" | "failedAt" | "errorMessage" | "sendGridMessageId" | "createdAt" | "updatedAt", ExtArgs["result"]["emailNotification"]>
  export type EmailNotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailNotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailNotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailNotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailNotification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      subject: string
      content: string
      recipientEmail: string
      notificationType: string
      flightCount: number
      status: string
      sentAt: Date | null
      failedAt: Date | null
      errorMessage: string | null
      sendGridMessageId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["emailNotification"]>
    composites: {}
  }

  type EmailNotificationGetPayload<S extends boolean | null | undefined | EmailNotificationDefaultArgs> = $Result.GetResult<Prisma.$EmailNotificationPayload, S>

  type EmailNotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailNotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailNotificationCountAggregateInputType | true
    }

  export interface EmailNotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailNotification'], meta: { name: 'EmailNotification' } }
    /**
     * Find zero or one EmailNotification that matches the filter.
     * @param {EmailNotificationFindUniqueArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailNotificationFindUniqueArgs>(args: SelectSubset<T, EmailNotificationFindUniqueArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one EmailNotification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailNotificationFindUniqueOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailNotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailNotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first EmailNotification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailNotificationFindFirstArgs>(args?: SelectSubset<T, EmailNotificationFindFirstArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first EmailNotification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindFirstOrThrowArgs} args - Arguments to find a EmailNotification
     * @example
     * // Get one EmailNotification
     * const emailNotification = await prisma.emailNotification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailNotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailNotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more EmailNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany()
     * 
     * // Get first 10 EmailNotifications
     * const emailNotifications = await prisma.emailNotification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailNotificationFindManyArgs>(args?: SelectSubset<T, EmailNotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a EmailNotification.
     * @param {EmailNotificationCreateArgs} args - Arguments to create a EmailNotification.
     * @example
     * // Create one EmailNotification
     * const EmailNotification = await prisma.emailNotification.create({
     *   data: {
     *     // ... data to create a EmailNotification
     *   }
     * })
     * 
     */
    create<T extends EmailNotificationCreateArgs>(args: SelectSubset<T, EmailNotificationCreateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many EmailNotifications.
     * @param {EmailNotificationCreateManyArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailNotificationCreateManyArgs>(args?: SelectSubset<T, EmailNotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailNotifications and returns the data saved in the database.
     * @param {EmailNotificationCreateManyAndReturnArgs} args - Arguments to create many EmailNotifications.
     * @example
     * // Create many EmailNotifications
     * const emailNotification = await prisma.emailNotification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailNotifications and only return the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailNotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailNotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a EmailNotification.
     * @param {EmailNotificationDeleteArgs} args - Arguments to delete one EmailNotification.
     * @example
     * // Delete one EmailNotification
     * const EmailNotification = await prisma.emailNotification.delete({
     *   where: {
     *     // ... filter to delete one EmailNotification
     *   }
     * })
     * 
     */
    delete<T extends EmailNotificationDeleteArgs>(args: SelectSubset<T, EmailNotificationDeleteArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one EmailNotification.
     * @param {EmailNotificationUpdateArgs} args - Arguments to update one EmailNotification.
     * @example
     * // Update one EmailNotification
     * const emailNotification = await prisma.emailNotification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailNotificationUpdateArgs>(args: SelectSubset<T, EmailNotificationUpdateArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more EmailNotifications.
     * @param {EmailNotificationDeleteManyArgs} args - Arguments to filter EmailNotifications to delete.
     * @example
     * // Delete a few EmailNotifications
     * const { count } = await prisma.emailNotification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailNotificationDeleteManyArgs>(args?: SelectSubset<T, EmailNotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailNotificationUpdateManyArgs>(args: SelectSubset<T, EmailNotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailNotifications and returns the data updated in the database.
     * @param {EmailNotificationUpdateManyAndReturnArgs} args - Arguments to update many EmailNotifications.
     * @example
     * // Update many EmailNotifications
     * const emailNotification = await prisma.emailNotification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailNotifications and only return the `id`
     * const emailNotificationWithIdOnly = await prisma.emailNotification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailNotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailNotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one EmailNotification.
     * @param {EmailNotificationUpsertArgs} args - Arguments to update or create a EmailNotification.
     * @example
     * // Update or create a EmailNotification
     * const emailNotification = await prisma.emailNotification.upsert({
     *   create: {
     *     // ... data to create a EmailNotification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailNotification we want to update
     *   }
     * })
     */
    upsert<T extends EmailNotificationUpsertArgs>(args: SelectSubset<T, EmailNotificationUpsertArgs<ExtArgs>>): Prisma__EmailNotificationClient<$Result.GetResult<Prisma.$EmailNotificationPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of EmailNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationCountArgs} args - Arguments to filter EmailNotifications to count.
     * @example
     * // Count the number of EmailNotifications
     * const count = await prisma.emailNotification.count({
     *   where: {
     *     // ... the filter for the EmailNotifications we want to count
     *   }
     * })
    **/
    count<T extends EmailNotificationCountArgs>(
      args?: Subset<T, EmailNotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailNotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailNotificationAggregateArgs>(args: Subset<T, EmailNotificationAggregateArgs>): Prisma.PrismaPromise<GetEmailNotificationAggregateType<T>>

    /**
     * Group by EmailNotification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailNotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailNotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailNotificationGroupByArgs['orderBy'] }
        : { orderBy?: EmailNotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailNotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailNotification model
   */
  readonly fields: EmailNotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailNotification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailNotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailNotification model
   */ 
  interface EmailNotificationFieldRefs {
    readonly id: FieldRef<"EmailNotification", 'String'>
    readonly userId: FieldRef<"EmailNotification", 'String'>
    readonly subject: FieldRef<"EmailNotification", 'String'>
    readonly content: FieldRef<"EmailNotification", 'String'>
    readonly recipientEmail: FieldRef<"EmailNotification", 'String'>
    readonly notificationType: FieldRef<"EmailNotification", 'String'>
    readonly flightCount: FieldRef<"EmailNotification", 'Int'>
    readonly status: FieldRef<"EmailNotification", 'String'>
    readonly sentAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly failedAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly errorMessage: FieldRef<"EmailNotification", 'String'>
    readonly sendGridMessageId: FieldRef<"EmailNotification", 'String'>
    readonly createdAt: FieldRef<"EmailNotification", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailNotification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailNotification findUnique
   */
  export type EmailNotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findUniqueOrThrow
   */
  export type EmailNotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification findFirst
   */
  export type EmailNotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findFirstOrThrow
   */
  export type EmailNotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotification to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailNotifications.
     */
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification findMany
   */
  export type EmailNotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter, which EmailNotifications to fetch.
     */
    where?: EmailNotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailNotifications to fetch.
     */
    orderBy?: EmailNotificationOrderByWithRelationInput | EmailNotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailNotifications.
     */
    cursor?: EmailNotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailNotifications.
     */
    skip?: number
    distinct?: EmailNotificationScalarFieldEnum | EmailNotificationScalarFieldEnum[]
  }

  /**
   * EmailNotification create
   */
  export type EmailNotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailNotification.
     */
    data: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
  }

  /**
   * EmailNotification createMany
   */
  export type EmailNotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailNotification createManyAndReturn
   */
  export type EmailNotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * The data used to create many EmailNotifications.
     */
    data: EmailNotificationCreateManyInput | EmailNotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailNotification update
   */
  export type EmailNotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailNotification.
     */
    data: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
    /**
     * Choose, which EmailNotification to update.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification updateMany
   */
  export type EmailNotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailNotifications.
     */
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to update.
     */
    limit?: number
  }

  /**
   * EmailNotification updateManyAndReturn
   */
  export type EmailNotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * The data used to update EmailNotifications.
     */
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyInput>
    /**
     * Filter which EmailNotifications to update
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailNotification upsert
   */
  export type EmailNotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailNotification to update in case it exists.
     */
    where: EmailNotificationWhereUniqueInput
    /**
     * In case the EmailNotification found by the `where` argument doesn't exist, create a new EmailNotification with this data.
     */
    create: XOR<EmailNotificationCreateInput, EmailNotificationUncheckedCreateInput>
    /**
     * In case the EmailNotification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailNotificationUpdateInput, EmailNotificationUncheckedUpdateInput>
  }

  /**
   * EmailNotification delete
   */
  export type EmailNotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
    /**
     * Filter which EmailNotification to delete.
     */
    where: EmailNotificationWhereUniqueInput
  }

  /**
   * EmailNotification deleteMany
   */
  export type EmailNotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailNotifications to delete
     */
    where?: EmailNotificationWhereInput
    /**
     * Limit how many EmailNotifications to delete.
     */
    limit?: number
  }

  /**
   * EmailNotification without action
   */
  export type EmailNotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailNotification
     */
    select?: EmailNotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailNotification
     */
    omit?: EmailNotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailNotificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    clerkId: 'clerkId',
    email: 'email',
    name: 'name',
    picture: 'picture',
    extensionApiKey: 'extensionApiKey',
    sessionToken: 'sessionToken',
    lastExtensionSync: 'lastExtensionSync',
    lastSettingsSync: 'lastSettingsSync',
    extensionEnabled: 'extensionEnabled',
    lastActiveAt: 'lastActiveAt',
    termsAccepted: 'termsAccepted',
    termsAcceptedAt: 'termsAcceptedAt',
    subscriptionTier: 'subscriptionTier',
    subscriptionStatus: 'subscriptionStatus',
    cubentUnitsUsed: 'cubentUnitsUsed',
    cubentUnitsLimit: 'cubentUnitsLimit',
    unitsResetDate: 'unitsResetDate',
    extensionSettings: 'extensionSettings',
    preferences: 'preferences',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ExtensionSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    sessionId: 'sessionId',
    isActive: 'isActive',
    lastActiveAt: 'lastActiveAt',
    extensionVersion: 'extensionVersion',
    vscodeVersion: 'vscodeVersion',
    platform: 'platform',
    metadata: 'metadata',
    tokensUsed: 'tokensUsed',
    requestsMade: 'requestsMade',
    createdAt: 'createdAt'
  };

  export type ExtensionSessionScalarFieldEnum = (typeof ExtensionSessionScalarFieldEnum)[keyof typeof ExtensionSessionScalarFieldEnum]


  export const UsageMetricsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tokensUsed: 'tokensUsed',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    cacheReadTokens: 'cacheReadTokens',
    cacheWriteTokens: 'cacheWriteTokens',
    cubentUnitsUsed: 'cubentUnitsUsed',
    requestsMade: 'requestsMade',
    costAccrued: 'costAccrued',
    date: 'date'
  };

  export type UsageMetricsScalarFieldEnum = (typeof UsageMetricsScalarFieldEnum)[keyof typeof UsageMetricsScalarFieldEnum]


  export const UsageAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    modelId: 'modelId',
    tokensUsed: 'tokensUsed',
    inputTokens: 'inputTokens',
    outputTokens: 'outputTokens',
    cacheReadTokens: 'cacheReadTokens',
    cacheWriteTokens: 'cacheWriteTokens',
    cubentUnitsUsed: 'cubentUnitsUsed',
    requestsMade: 'requestsMade',
    costAccrued: 'costAccrued',
    sessionId: 'sessionId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type UsageAnalyticsScalarFieldEnum = (typeof UsageAnalyticsScalarFieldEnum)[keyof typeof UsageAnalyticsScalarFieldEnum]


  export const AutocompleteAnalyticsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    modelId: 'modelId',
    provider: 'provider',
    completionsGenerated: 'completionsGenerated',
    completionsAccepted: 'completionsAccepted',
    linesAdded: 'linesAdded',
    charactersAdded: 'charactersAdded',
    language: 'language',
    filepath: 'filepath',
    sessionId: 'sessionId',
    avgLatency: 'avgLatency',
    successRate: 'successRate',
    acceptanceRate: 'acceptanceRate',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AutocompleteAnalyticsScalarFieldEnum = (typeof AutocompleteAnalyticsScalarFieldEnum)[keyof typeof AutocompleteAnalyticsScalarFieldEnum]


  export const AutocompleteMetricsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    completionsGenerated: 'completionsGenerated',
    completionsAccepted: 'completionsAccepted',
    linesAdded: 'linesAdded',
    charactersAdded: 'charactersAdded',
    avgLatency: 'avgLatency',
    avgSuccessRate: 'avgSuccessRate',
    avgAcceptanceRate: 'avgAcceptanceRate',
    modelBreakdown: 'modelBreakdown',
    date: 'date'
  };

  export type AutocompleteMetricsScalarFieldEnum = (typeof AutocompleteMetricsScalarFieldEnum)[keyof typeof AutocompleteMetricsScalarFieldEnum]


  export const ApiKeyScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    description: 'description',
    keyHash: 'keyHash',
    permissions: 'permissions',
    isActive: 'isActive',
    expiresAt: 'expiresAt',
    lastUsedAt: 'lastUsedAt',
    usageCount: 'usageCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ApiKeyScalarFieldEnum = (typeof ApiKeyScalarFieldEnum)[keyof typeof ApiKeyScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    name: 'name',
    subscriptionTier: 'subscriptionTier',
    subscriptionStatus: 'subscriptionStatus',
    termsAccepted: 'termsAccepted',
    extensionEnabled: 'extensionEnabled',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const PendingLoginScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    state: 'state',
    token: 'token',
    userId: 'userId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type PendingLoginScalarFieldEnum = (typeof PendingLoginScalarFieldEnum)[keyof typeof PendingLoginScalarFieldEnum]


  export const PageScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type PageScalarFieldEnum = (typeof PageScalarFieldEnum)[keyof typeof PageScalarFieldEnum]


  export const UserPreferencesScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    homeAirports: 'homeAirports',
    dreamDestinations: 'dreamDestinations',
    deliveryFrequency: 'deliveryFrequency',
    maxBudget: 'maxBudget',
    preferredAirlines: 'preferredAirlines',
    travelFlexibility: 'travelFlexibility',
    currency: 'currency',
    headerImageUrl: 'headerImageUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPreferencesScalarFieldEnum = (typeof UserPreferencesScalarFieldEnum)[keyof typeof UserPreferencesScalarFieldEnum]


  export const FlightRecommendationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    origin: 'origin',
    destination: 'destination',
    departureDate: 'departureDate',
    returnDate: 'returnDate',
    price: 'price',
    currency: 'currency',
    airline: 'airline',
    flightNumber: 'flightNumber',
    layovers: 'layovers',
    duration: 'duration',
    baggageInfo: 'baggageInfo',
    aiSummary: 'aiSummary',
    confidenceScore: 'confidenceScore',
    dealQuality: 'dealQuality',
    bookingUrl: 'bookingUrl',
    otaUrl: 'otaUrl',
    cityImageUrl: 'cityImageUrl',
    cityActivities: 'cityActivities',
    searchDate: 'searchDate',
    isActive: 'isActive',
    isWatched: 'isWatched',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlightRecommendationScalarFieldEnum = (typeof FlightRecommendationScalarFieldEnum)[keyof typeof FlightRecommendationScalarFieldEnum]


  export const StripeSubscriptionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    stripeCustomerId: 'stripeCustomerId',
    stripeSubscriptionId: 'stripeSubscriptionId',
    stripePriceId: 'stripePriceId',
    status: 'status',
    currentPeriodStart: 'currentPeriodStart',
    currentPeriodEnd: 'currentPeriodEnd',
    cancelAtPeriodEnd: 'cancelAtPeriodEnd',
    amount: 'amount',
    currency: 'currency',
    interval: 'interval',
    trialEnd: 'trialEnd',
    canceledAt: 'canceledAt',
    endedAt: 'endedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StripeSubscriptionScalarFieldEnum = (typeof StripeSubscriptionScalarFieldEnum)[keyof typeof StripeSubscriptionScalarFieldEnum]


  export const EmailNotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    subject: 'subject',
    content: 'content',
    recipientEmail: 'recipientEmail',
    notificationType: 'notificationType',
    flightCount: 'flightCount',
    status: 'status',
    sentAt: 'sentAt',
    failedAt: 'failedAt',
    errorMessage: 'errorMessage',
    sendGridMessageId: 'sendGridMessageId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmailNotificationScalarFieldEnum = (typeof EmailNotificationScalarFieldEnum)[keyof typeof EmailNotificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    clerkId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    picture?: StringNullableFilter<"User"> | string | null
    extensionApiKey?: StringNullableFilter<"User"> | string | null
    sessionToken?: StringNullableFilter<"User"> | string | null
    lastExtensionSync?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSettingsSync?: DateTimeNullableFilter<"User"> | Date | string | null
    extensionEnabled?: BoolFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    termsAccepted?: BoolFilter<"User"> | boolean
    termsAcceptedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionTier?: StringFilter<"User"> | string
    subscriptionStatus?: StringFilter<"User"> | string
    cubentUnitsUsed?: FloatFilter<"User"> | number
    cubentUnitsLimit?: FloatFilter<"User"> | number
    unitsResetDate?: DateTimeNullableFilter<"User"> | Date | string | null
    extensionSettings?: JsonNullableFilter<"User">
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    extensionSessions?: ExtensionSessionListRelationFilter
    usageMetrics?: UsageMetricsListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    usageAnalytics?: UsageAnalyticsListRelationFilter
    autocompleteAnalytics?: AutocompleteAnalyticsListRelationFilter
    autocompleteMetrics?: AutocompleteMetricsListRelationFilter
    travelPreferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    flightRecommendations?: FlightRecommendationListRelationFilter
    stripeSubscription?: XOR<StripeSubscriptionNullableScalarRelationFilter, StripeSubscriptionWhereInput> | null
    emailNotifications?: EmailNotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    extensionApiKey?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    lastExtensionSync?: SortOrderInput | SortOrder
    lastSettingsSync?: SortOrderInput | SortOrder
    extensionEnabled?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
    unitsResetDate?: SortOrderInput | SortOrder
    extensionSettings?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    extensionSessions?: ExtensionSessionOrderByRelationAggregateInput
    usageMetrics?: UsageMetricsOrderByRelationAggregateInput
    apiKeys?: ApiKeyOrderByRelationAggregateInput
    usageAnalytics?: UsageAnalyticsOrderByRelationAggregateInput
    autocompleteAnalytics?: AutocompleteAnalyticsOrderByRelationAggregateInput
    autocompleteMetrics?: AutocompleteMetricsOrderByRelationAggregateInput
    travelPreferences?: UserPreferencesOrderByWithRelationInput
    flightRecommendations?: FlightRecommendationOrderByRelationAggregateInput
    stripeSubscription?: StripeSubscriptionOrderByWithRelationInput
    emailNotifications?: EmailNotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clerkId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    picture?: StringNullableFilter<"User"> | string | null
    extensionApiKey?: StringNullableFilter<"User"> | string | null
    sessionToken?: StringNullableFilter<"User"> | string | null
    lastExtensionSync?: DateTimeNullableFilter<"User"> | Date | string | null
    lastSettingsSync?: DateTimeNullableFilter<"User"> | Date | string | null
    extensionEnabled?: BoolFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableFilter<"User"> | Date | string | null
    termsAccepted?: BoolFilter<"User"> | boolean
    termsAcceptedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    subscriptionTier?: StringFilter<"User"> | string
    subscriptionStatus?: StringFilter<"User"> | string
    cubentUnitsUsed?: FloatFilter<"User"> | number
    cubentUnitsLimit?: FloatFilter<"User"> | number
    unitsResetDate?: DateTimeNullableFilter<"User"> | Date | string | null
    extensionSettings?: JsonNullableFilter<"User">
    preferences?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    extensionSessions?: ExtensionSessionListRelationFilter
    usageMetrics?: UsageMetricsListRelationFilter
    apiKeys?: ApiKeyListRelationFilter
    usageAnalytics?: UsageAnalyticsListRelationFilter
    autocompleteAnalytics?: AutocompleteAnalyticsListRelationFilter
    autocompleteMetrics?: AutocompleteMetricsListRelationFilter
    travelPreferences?: XOR<UserPreferencesNullableScalarRelationFilter, UserPreferencesWhereInput> | null
    flightRecommendations?: FlightRecommendationListRelationFilter
    stripeSubscription?: XOR<StripeSubscriptionNullableScalarRelationFilter, StripeSubscriptionWhereInput> | null
    emailNotifications?: EmailNotificationListRelationFilter
  }, "id" | "clerkId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    extensionApiKey?: SortOrderInput | SortOrder
    sessionToken?: SortOrderInput | SortOrder
    lastExtensionSync?: SortOrderInput | SortOrder
    lastSettingsSync?: SortOrderInput | SortOrder
    extensionEnabled?: SortOrder
    lastActiveAt?: SortOrderInput | SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
    unitsResetDate?: SortOrderInput | SortOrder
    extensionSettings?: SortOrderInput | SortOrder
    preferences?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    clerkId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    picture?: StringNullableWithAggregatesFilter<"User"> | string | null
    extensionApiKey?: StringNullableWithAggregatesFilter<"User"> | string | null
    sessionToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastExtensionSync?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastSettingsSync?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    extensionEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    lastActiveAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    termsAccepted?: BoolWithAggregatesFilter<"User"> | boolean
    termsAcceptedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    subscriptionTier?: StringWithAggregatesFilter<"User"> | string
    subscriptionStatus?: StringWithAggregatesFilter<"User"> | string
    cubentUnitsUsed?: FloatWithAggregatesFilter<"User"> | number
    cubentUnitsLimit?: FloatWithAggregatesFilter<"User"> | number
    unitsResetDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    extensionSettings?: JsonNullableWithAggregatesFilter<"User">
    preferences?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ExtensionSessionWhereInput = {
    AND?: ExtensionSessionWhereInput | ExtensionSessionWhereInput[]
    OR?: ExtensionSessionWhereInput[]
    NOT?: ExtensionSessionWhereInput | ExtensionSessionWhereInput[]
    id?: StringFilter<"ExtensionSession"> | string
    userId?: StringFilter<"ExtensionSession"> | string
    sessionId?: StringFilter<"ExtensionSession"> | string
    isActive?: BoolFilter<"ExtensionSession"> | boolean
    lastActiveAt?: DateTimeFilter<"ExtensionSession"> | Date | string
    extensionVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    vscodeVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    platform?: StringNullableFilter<"ExtensionSession"> | string | null
    metadata?: JsonNullableFilter<"ExtensionSession">
    tokensUsed?: IntFilter<"ExtensionSession"> | number
    requestsMade?: IntFilter<"ExtensionSession"> | number
    createdAt?: DateTimeFilter<"ExtensionSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ExtensionSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    lastActiveAt?: SortOrder
    extensionVersion?: SortOrderInput | SortOrder
    vscodeVersion?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ExtensionSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_sessionId?: ExtensionSessionUserIdSessionIdCompoundUniqueInput
    AND?: ExtensionSessionWhereInput | ExtensionSessionWhereInput[]
    OR?: ExtensionSessionWhereInput[]
    NOT?: ExtensionSessionWhereInput | ExtensionSessionWhereInput[]
    userId?: StringFilter<"ExtensionSession"> | string
    sessionId?: StringFilter<"ExtensionSession"> | string
    isActive?: BoolFilter<"ExtensionSession"> | boolean
    lastActiveAt?: DateTimeFilter<"ExtensionSession"> | Date | string
    extensionVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    vscodeVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    platform?: StringNullableFilter<"ExtensionSession"> | string | null
    metadata?: JsonNullableFilter<"ExtensionSession">
    tokensUsed?: IntFilter<"ExtensionSession"> | number
    requestsMade?: IntFilter<"ExtensionSession"> | number
    createdAt?: DateTimeFilter<"ExtensionSession"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_sessionId">

  export type ExtensionSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    lastActiveAt?: SortOrder
    extensionVersion?: SortOrderInput | SortOrder
    vscodeVersion?: SortOrderInput | SortOrder
    platform?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
    createdAt?: SortOrder
    _count?: ExtensionSessionCountOrderByAggregateInput
    _avg?: ExtensionSessionAvgOrderByAggregateInput
    _max?: ExtensionSessionMaxOrderByAggregateInput
    _min?: ExtensionSessionMinOrderByAggregateInput
    _sum?: ExtensionSessionSumOrderByAggregateInput
  }

  export type ExtensionSessionScalarWhereWithAggregatesInput = {
    AND?: ExtensionSessionScalarWhereWithAggregatesInput | ExtensionSessionScalarWhereWithAggregatesInput[]
    OR?: ExtensionSessionScalarWhereWithAggregatesInput[]
    NOT?: ExtensionSessionScalarWhereWithAggregatesInput | ExtensionSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExtensionSession"> | string
    userId?: StringWithAggregatesFilter<"ExtensionSession"> | string
    sessionId?: StringWithAggregatesFilter<"ExtensionSession"> | string
    isActive?: BoolWithAggregatesFilter<"ExtensionSession"> | boolean
    lastActiveAt?: DateTimeWithAggregatesFilter<"ExtensionSession"> | Date | string
    extensionVersion?: StringNullableWithAggregatesFilter<"ExtensionSession"> | string | null
    vscodeVersion?: StringNullableWithAggregatesFilter<"ExtensionSession"> | string | null
    platform?: StringNullableWithAggregatesFilter<"ExtensionSession"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ExtensionSession">
    tokensUsed?: IntWithAggregatesFilter<"ExtensionSession"> | number
    requestsMade?: IntWithAggregatesFilter<"ExtensionSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ExtensionSession"> | Date | string
  }

  export type UsageMetricsWhereInput = {
    AND?: UsageMetricsWhereInput | UsageMetricsWhereInput[]
    OR?: UsageMetricsWhereInput[]
    NOT?: UsageMetricsWhereInput | UsageMetricsWhereInput[]
    id?: StringFilter<"UsageMetrics"> | string
    userId?: StringFilter<"UsageMetrics"> | string
    tokensUsed?: IntFilter<"UsageMetrics"> | number
    inputTokens?: IntFilter<"UsageMetrics"> | number
    outputTokens?: IntFilter<"UsageMetrics"> | number
    cacheReadTokens?: IntFilter<"UsageMetrics"> | number
    cacheWriteTokens?: IntFilter<"UsageMetrics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageMetrics"> | number
    requestsMade?: IntFilter<"UsageMetrics"> | number
    costAccrued?: FloatFilter<"UsageMetrics"> | number
    date?: DateTimeFilter<"UsageMetrics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UsageMetricsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageMetricsWhereInput | UsageMetricsWhereInput[]
    OR?: UsageMetricsWhereInput[]
    NOT?: UsageMetricsWhereInput | UsageMetricsWhereInput[]
    userId?: StringFilter<"UsageMetrics"> | string
    tokensUsed?: IntFilter<"UsageMetrics"> | number
    inputTokens?: IntFilter<"UsageMetrics"> | number
    outputTokens?: IntFilter<"UsageMetrics"> | number
    cacheReadTokens?: IntFilter<"UsageMetrics"> | number
    cacheWriteTokens?: IntFilter<"UsageMetrics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageMetrics"> | number
    requestsMade?: IntFilter<"UsageMetrics"> | number
    costAccrued?: FloatFilter<"UsageMetrics"> | number
    date?: DateTimeFilter<"UsageMetrics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UsageMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    date?: SortOrder
    _count?: UsageMetricsCountOrderByAggregateInput
    _avg?: UsageMetricsAvgOrderByAggregateInput
    _max?: UsageMetricsMaxOrderByAggregateInput
    _min?: UsageMetricsMinOrderByAggregateInput
    _sum?: UsageMetricsSumOrderByAggregateInput
  }

  export type UsageMetricsScalarWhereWithAggregatesInput = {
    AND?: UsageMetricsScalarWhereWithAggregatesInput | UsageMetricsScalarWhereWithAggregatesInput[]
    OR?: UsageMetricsScalarWhereWithAggregatesInput[]
    NOT?: UsageMetricsScalarWhereWithAggregatesInput | UsageMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageMetrics"> | string
    userId?: StringWithAggregatesFilter<"UsageMetrics"> | string
    tokensUsed?: IntWithAggregatesFilter<"UsageMetrics"> | number
    inputTokens?: IntWithAggregatesFilter<"UsageMetrics"> | number
    outputTokens?: IntWithAggregatesFilter<"UsageMetrics"> | number
    cacheReadTokens?: IntWithAggregatesFilter<"UsageMetrics"> | number
    cacheWriteTokens?: IntWithAggregatesFilter<"UsageMetrics"> | number
    cubentUnitsUsed?: FloatWithAggregatesFilter<"UsageMetrics"> | number
    requestsMade?: IntWithAggregatesFilter<"UsageMetrics"> | number
    costAccrued?: FloatWithAggregatesFilter<"UsageMetrics"> | number
    date?: DateTimeWithAggregatesFilter<"UsageMetrics"> | Date | string
  }

  export type UsageAnalyticsWhereInput = {
    AND?: UsageAnalyticsWhereInput | UsageAnalyticsWhereInput[]
    OR?: UsageAnalyticsWhereInput[]
    NOT?: UsageAnalyticsWhereInput | UsageAnalyticsWhereInput[]
    id?: StringFilter<"UsageAnalytics"> | string
    userId?: StringFilter<"UsageAnalytics"> | string
    modelId?: StringFilter<"UsageAnalytics"> | string
    tokensUsed?: IntFilter<"UsageAnalytics"> | number
    inputTokens?: IntFilter<"UsageAnalytics"> | number
    outputTokens?: IntFilter<"UsageAnalytics"> | number
    cacheReadTokens?: IntFilter<"UsageAnalytics"> | number
    cacheWriteTokens?: IntFilter<"UsageAnalytics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageAnalytics"> | number
    requestsMade?: IntFilter<"UsageAnalytics"> | number
    costAccrued?: FloatFilter<"UsageAnalytics"> | number
    sessionId?: StringNullableFilter<"UsageAnalytics"> | string | null
    metadata?: JsonNullableFilter<"UsageAnalytics">
    createdAt?: DateTimeFilter<"UsageAnalytics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UsageAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UsageAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UsageAnalyticsWhereInput | UsageAnalyticsWhereInput[]
    OR?: UsageAnalyticsWhereInput[]
    NOT?: UsageAnalyticsWhereInput | UsageAnalyticsWhereInput[]
    userId?: StringFilter<"UsageAnalytics"> | string
    modelId?: StringFilter<"UsageAnalytics"> | string
    tokensUsed?: IntFilter<"UsageAnalytics"> | number
    inputTokens?: IntFilter<"UsageAnalytics"> | number
    outputTokens?: IntFilter<"UsageAnalytics"> | number
    cacheReadTokens?: IntFilter<"UsageAnalytics"> | number
    cacheWriteTokens?: IntFilter<"UsageAnalytics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageAnalytics"> | number
    requestsMade?: IntFilter<"UsageAnalytics"> | number
    costAccrued?: FloatFilter<"UsageAnalytics"> | number
    sessionId?: StringNullableFilter<"UsageAnalytics"> | string | null
    metadata?: JsonNullableFilter<"UsageAnalytics">
    createdAt?: DateTimeFilter<"UsageAnalytics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type UsageAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    sessionId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: UsageAnalyticsCountOrderByAggregateInput
    _avg?: UsageAnalyticsAvgOrderByAggregateInput
    _max?: UsageAnalyticsMaxOrderByAggregateInput
    _min?: UsageAnalyticsMinOrderByAggregateInput
    _sum?: UsageAnalyticsSumOrderByAggregateInput
  }

  export type UsageAnalyticsScalarWhereWithAggregatesInput = {
    AND?: UsageAnalyticsScalarWhereWithAggregatesInput | UsageAnalyticsScalarWhereWithAggregatesInput[]
    OR?: UsageAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: UsageAnalyticsScalarWhereWithAggregatesInput | UsageAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageAnalytics"> | string
    userId?: StringWithAggregatesFilter<"UsageAnalytics"> | string
    modelId?: StringWithAggregatesFilter<"UsageAnalytics"> | string
    tokensUsed?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    inputTokens?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    outputTokens?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    cacheReadTokens?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    cacheWriteTokens?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    cubentUnitsUsed?: FloatWithAggregatesFilter<"UsageAnalytics"> | number
    requestsMade?: IntWithAggregatesFilter<"UsageAnalytics"> | number
    costAccrued?: FloatWithAggregatesFilter<"UsageAnalytics"> | number
    sessionId?: StringNullableWithAggregatesFilter<"UsageAnalytics"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"UsageAnalytics">
    createdAt?: DateTimeWithAggregatesFilter<"UsageAnalytics"> | Date | string
  }

  export type AutocompleteAnalyticsWhereInput = {
    AND?: AutocompleteAnalyticsWhereInput | AutocompleteAnalyticsWhereInput[]
    OR?: AutocompleteAnalyticsWhereInput[]
    NOT?: AutocompleteAnalyticsWhereInput | AutocompleteAnalyticsWhereInput[]
    id?: StringFilter<"AutocompleteAnalytics"> | string
    userId?: StringFilter<"AutocompleteAnalytics"> | string
    modelId?: StringFilter<"AutocompleteAnalytics"> | string
    provider?: StringFilter<"AutocompleteAnalytics"> | string
    completionsGenerated?: IntFilter<"AutocompleteAnalytics"> | number
    completionsAccepted?: IntFilter<"AutocompleteAnalytics"> | number
    linesAdded?: IntFilter<"AutocompleteAnalytics"> | number
    charactersAdded?: IntFilter<"AutocompleteAnalytics"> | number
    language?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    filepath?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    sessionId?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    avgLatency?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    successRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    acceptanceRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    metadata?: JsonNullableFilter<"AutocompleteAnalytics">
    createdAt?: DateTimeFilter<"AutocompleteAnalytics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AutocompleteAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    provider?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    language?: SortOrderInput | SortOrder
    filepath?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    avgLatency?: SortOrderInput | SortOrder
    successRate?: SortOrderInput | SortOrder
    acceptanceRate?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AutocompleteAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutocompleteAnalyticsWhereInput | AutocompleteAnalyticsWhereInput[]
    OR?: AutocompleteAnalyticsWhereInput[]
    NOT?: AutocompleteAnalyticsWhereInput | AutocompleteAnalyticsWhereInput[]
    userId?: StringFilter<"AutocompleteAnalytics"> | string
    modelId?: StringFilter<"AutocompleteAnalytics"> | string
    provider?: StringFilter<"AutocompleteAnalytics"> | string
    completionsGenerated?: IntFilter<"AutocompleteAnalytics"> | number
    completionsAccepted?: IntFilter<"AutocompleteAnalytics"> | number
    linesAdded?: IntFilter<"AutocompleteAnalytics"> | number
    charactersAdded?: IntFilter<"AutocompleteAnalytics"> | number
    language?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    filepath?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    sessionId?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    avgLatency?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    successRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    acceptanceRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    metadata?: JsonNullableFilter<"AutocompleteAnalytics">
    createdAt?: DateTimeFilter<"AutocompleteAnalytics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AutocompleteAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    provider?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    language?: SortOrderInput | SortOrder
    filepath?: SortOrderInput | SortOrder
    sessionId?: SortOrderInput | SortOrder
    avgLatency?: SortOrderInput | SortOrder
    successRate?: SortOrderInput | SortOrder
    acceptanceRate?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AutocompleteAnalyticsCountOrderByAggregateInput
    _avg?: AutocompleteAnalyticsAvgOrderByAggregateInput
    _max?: AutocompleteAnalyticsMaxOrderByAggregateInput
    _min?: AutocompleteAnalyticsMinOrderByAggregateInput
    _sum?: AutocompleteAnalyticsSumOrderByAggregateInput
  }

  export type AutocompleteAnalyticsScalarWhereWithAggregatesInput = {
    AND?: AutocompleteAnalyticsScalarWhereWithAggregatesInput | AutocompleteAnalyticsScalarWhereWithAggregatesInput[]
    OR?: AutocompleteAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: AutocompleteAnalyticsScalarWhereWithAggregatesInput | AutocompleteAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutocompleteAnalytics"> | string
    userId?: StringWithAggregatesFilter<"AutocompleteAnalytics"> | string
    modelId?: StringWithAggregatesFilter<"AutocompleteAnalytics"> | string
    provider?: StringWithAggregatesFilter<"AutocompleteAnalytics"> | string
    completionsGenerated?: IntWithAggregatesFilter<"AutocompleteAnalytics"> | number
    completionsAccepted?: IntWithAggregatesFilter<"AutocompleteAnalytics"> | number
    linesAdded?: IntWithAggregatesFilter<"AutocompleteAnalytics"> | number
    charactersAdded?: IntWithAggregatesFilter<"AutocompleteAnalytics"> | number
    language?: StringNullableWithAggregatesFilter<"AutocompleteAnalytics"> | string | null
    filepath?: StringNullableWithAggregatesFilter<"AutocompleteAnalytics"> | string | null
    sessionId?: StringNullableWithAggregatesFilter<"AutocompleteAnalytics"> | string | null
    avgLatency?: FloatNullableWithAggregatesFilter<"AutocompleteAnalytics"> | number | null
    successRate?: FloatNullableWithAggregatesFilter<"AutocompleteAnalytics"> | number | null
    acceptanceRate?: FloatNullableWithAggregatesFilter<"AutocompleteAnalytics"> | number | null
    metadata?: JsonNullableWithAggregatesFilter<"AutocompleteAnalytics">
    createdAt?: DateTimeWithAggregatesFilter<"AutocompleteAnalytics"> | Date | string
  }

  export type AutocompleteMetricsWhereInput = {
    AND?: AutocompleteMetricsWhereInput | AutocompleteMetricsWhereInput[]
    OR?: AutocompleteMetricsWhereInput[]
    NOT?: AutocompleteMetricsWhereInput | AutocompleteMetricsWhereInput[]
    id?: StringFilter<"AutocompleteMetrics"> | string
    userId?: StringFilter<"AutocompleteMetrics"> | string
    completionsGenerated?: IntFilter<"AutocompleteMetrics"> | number
    completionsAccepted?: IntFilter<"AutocompleteMetrics"> | number
    linesAdded?: IntFilter<"AutocompleteMetrics"> | number
    charactersAdded?: IntFilter<"AutocompleteMetrics"> | number
    avgLatency?: FloatFilter<"AutocompleteMetrics"> | number
    avgSuccessRate?: FloatFilter<"AutocompleteMetrics"> | number
    avgAcceptanceRate?: FloatFilter<"AutocompleteMetrics"> | number
    modelBreakdown?: JsonNullableFilter<"AutocompleteMetrics">
    date?: DateTimeFilter<"AutocompleteMetrics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AutocompleteMetricsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
    modelBreakdown?: SortOrderInput | SortOrder
    date?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AutocompleteMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AutocompleteMetricsWhereInput | AutocompleteMetricsWhereInput[]
    OR?: AutocompleteMetricsWhereInput[]
    NOT?: AutocompleteMetricsWhereInput | AutocompleteMetricsWhereInput[]
    userId?: StringFilter<"AutocompleteMetrics"> | string
    completionsGenerated?: IntFilter<"AutocompleteMetrics"> | number
    completionsAccepted?: IntFilter<"AutocompleteMetrics"> | number
    linesAdded?: IntFilter<"AutocompleteMetrics"> | number
    charactersAdded?: IntFilter<"AutocompleteMetrics"> | number
    avgLatency?: FloatFilter<"AutocompleteMetrics"> | number
    avgSuccessRate?: FloatFilter<"AutocompleteMetrics"> | number
    avgAcceptanceRate?: FloatFilter<"AutocompleteMetrics"> | number
    modelBreakdown?: JsonNullableFilter<"AutocompleteMetrics">
    date?: DateTimeFilter<"AutocompleteMetrics"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AutocompleteMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
    modelBreakdown?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: AutocompleteMetricsCountOrderByAggregateInput
    _avg?: AutocompleteMetricsAvgOrderByAggregateInput
    _max?: AutocompleteMetricsMaxOrderByAggregateInput
    _min?: AutocompleteMetricsMinOrderByAggregateInput
    _sum?: AutocompleteMetricsSumOrderByAggregateInput
  }

  export type AutocompleteMetricsScalarWhereWithAggregatesInput = {
    AND?: AutocompleteMetricsScalarWhereWithAggregatesInput | AutocompleteMetricsScalarWhereWithAggregatesInput[]
    OR?: AutocompleteMetricsScalarWhereWithAggregatesInput[]
    NOT?: AutocompleteMetricsScalarWhereWithAggregatesInput | AutocompleteMetricsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AutocompleteMetrics"> | string
    userId?: StringWithAggregatesFilter<"AutocompleteMetrics"> | string
    completionsGenerated?: IntWithAggregatesFilter<"AutocompleteMetrics"> | number
    completionsAccepted?: IntWithAggregatesFilter<"AutocompleteMetrics"> | number
    linesAdded?: IntWithAggregatesFilter<"AutocompleteMetrics"> | number
    charactersAdded?: IntWithAggregatesFilter<"AutocompleteMetrics"> | number
    avgLatency?: FloatWithAggregatesFilter<"AutocompleteMetrics"> | number
    avgSuccessRate?: FloatWithAggregatesFilter<"AutocompleteMetrics"> | number
    avgAcceptanceRate?: FloatWithAggregatesFilter<"AutocompleteMetrics"> | number
    modelBreakdown?: JsonNullableWithAggregatesFilter<"AutocompleteMetrics">
    date?: DateTimeWithAggregatesFilter<"AutocompleteMetrics"> | Date | string
  }

  export type ApiKeyWhereInput = {
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    description?: StringNullableFilter<"ApiKey"> | string | null
    keyHash?: StringFilter<"ApiKey"> | string
    permissions?: JsonFilter<"ApiKey">
    isActive?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ApiKeyOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ApiKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    keyHash?: string
    AND?: ApiKeyWhereInput | ApiKeyWhereInput[]
    OR?: ApiKeyWhereInput[]
    NOT?: ApiKeyWhereInput | ApiKeyWhereInput[]
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    description?: StringNullableFilter<"ApiKey"> | string | null
    permissions?: JsonFilter<"ApiKey">
    isActive?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "keyHash">

  export type ApiKeyOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ApiKeyCountOrderByAggregateInput
    _avg?: ApiKeyAvgOrderByAggregateInput
    _max?: ApiKeyMaxOrderByAggregateInput
    _min?: ApiKeyMinOrderByAggregateInput
    _sum?: ApiKeySumOrderByAggregateInput
  }

  export type ApiKeyScalarWhereWithAggregatesInput = {
    AND?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    OR?: ApiKeyScalarWhereWithAggregatesInput[]
    NOT?: ApiKeyScalarWhereWithAggregatesInput | ApiKeyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ApiKey"> | string
    userId?: StringWithAggregatesFilter<"ApiKey"> | string
    name?: StringWithAggregatesFilter<"ApiKey"> | string
    description?: StringNullableWithAggregatesFilter<"ApiKey"> | string | null
    keyHash?: StringWithAggregatesFilter<"ApiKey"> | string
    permissions?: JsonWithAggregatesFilter<"ApiKey">
    isActive?: BoolWithAggregatesFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ApiKey"> | Date | string | null
    usageCount?: IntWithAggregatesFilter<"ApiKey"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ApiKey"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    email?: StringFilter<"UserProfile"> | string
    name?: StringNullableFilter<"UserProfile"> | string | null
    subscriptionTier?: StringFilter<"UserProfile"> | string
    subscriptionStatus?: StringFilter<"UserProfile"> | string
    termsAccepted?: BoolFilter<"UserProfile"> | boolean
    extensionEnabled?: BoolFilter<"UserProfile"> | boolean
    settings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    termsAccepted?: SortOrder
    extensionEnabled?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    email?: StringFilter<"UserProfile"> | string
    name?: StringNullableFilter<"UserProfile"> | string | null
    subscriptionTier?: StringFilter<"UserProfile"> | string
    subscriptionStatus?: StringFilter<"UserProfile"> | string
    termsAccepted?: BoolFilter<"UserProfile"> | boolean
    extensionEnabled?: BoolFilter<"UserProfile"> | boolean
    settings?: JsonNullableFilter<"UserProfile">
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    termsAccepted?: SortOrder
    extensionEnabled?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    email?: StringWithAggregatesFilter<"UserProfile"> | string
    name?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    subscriptionTier?: StringWithAggregatesFilter<"UserProfile"> | string
    subscriptionStatus?: StringWithAggregatesFilter<"UserProfile"> | string
    termsAccepted?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    extensionEnabled?: BoolWithAggregatesFilter<"UserProfile"> | boolean
    settings?: JsonNullableWithAggregatesFilter<"UserProfile">
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type PendingLoginWhereInput = {
    AND?: PendingLoginWhereInput | PendingLoginWhereInput[]
    OR?: PendingLoginWhereInput[]
    NOT?: PendingLoginWhereInput | PendingLoginWhereInput[]
    id?: StringFilter<"PendingLogin"> | string
    deviceId?: StringFilter<"PendingLogin"> | string
    state?: StringFilter<"PendingLogin"> | string
    token?: StringFilter<"PendingLogin"> | string
    userId?: StringFilter<"PendingLogin"> | string
    createdAt?: DateTimeFilter<"PendingLogin"> | Date | string
    expiresAt?: DateTimeFilter<"PendingLogin"> | Date | string
  }

  export type PendingLoginOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    state?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PendingLoginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PendingLoginWhereInput | PendingLoginWhereInput[]
    OR?: PendingLoginWhereInput[]
    NOT?: PendingLoginWhereInput | PendingLoginWhereInput[]
    deviceId?: StringFilter<"PendingLogin"> | string
    state?: StringFilter<"PendingLogin"> | string
    token?: StringFilter<"PendingLogin"> | string
    userId?: StringFilter<"PendingLogin"> | string
    createdAt?: DateTimeFilter<"PendingLogin"> | Date | string
    expiresAt?: DateTimeFilter<"PendingLogin"> | Date | string
  }, "id">

  export type PendingLoginOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    state?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: PendingLoginCountOrderByAggregateInput
    _max?: PendingLoginMaxOrderByAggregateInput
    _min?: PendingLoginMinOrderByAggregateInput
  }

  export type PendingLoginScalarWhereWithAggregatesInput = {
    AND?: PendingLoginScalarWhereWithAggregatesInput | PendingLoginScalarWhereWithAggregatesInput[]
    OR?: PendingLoginScalarWhereWithAggregatesInput[]
    NOT?: PendingLoginScalarWhereWithAggregatesInput | PendingLoginScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PendingLogin"> | string
    deviceId?: StringWithAggregatesFilter<"PendingLogin"> | string
    state?: StringWithAggregatesFilter<"PendingLogin"> | string
    token?: StringWithAggregatesFilter<"PendingLogin"> | string
    userId?: StringWithAggregatesFilter<"PendingLogin"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PendingLogin"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"PendingLogin"> | Date | string
  }

  export type PageWhereInput = {
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    id?: IntFilter<"Page"> | number
    name?: StringFilter<"Page"> | string
  }

  export type PageOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PageWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PageWhereInput | PageWhereInput[]
    OR?: PageWhereInput[]
    NOT?: PageWhereInput | PageWhereInput[]
    name?: StringFilter<"Page"> | string
  }, "id">

  export type PageOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: PageCountOrderByAggregateInput
    _avg?: PageAvgOrderByAggregateInput
    _max?: PageMaxOrderByAggregateInput
    _min?: PageMinOrderByAggregateInput
    _sum?: PageSumOrderByAggregateInput
  }

  export type PageScalarWhereWithAggregatesInput = {
    AND?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    OR?: PageScalarWhereWithAggregatesInput[]
    NOT?: PageScalarWhereWithAggregatesInput | PageScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Page"> | number
    name?: StringWithAggregatesFilter<"Page"> | string
  }

  export type UserPreferencesWhereInput = {
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    id?: StringFilter<"UserPreferences"> | string
    userId?: StringFilter<"UserPreferences"> | string
    homeAirports?: JsonFilter<"UserPreferences">
    dreamDestinations?: JsonFilter<"UserPreferences">
    deliveryFrequency?: StringFilter<"UserPreferences"> | string
    maxBudget?: FloatNullableFilter<"UserPreferences"> | number | null
    preferredAirlines?: JsonNullableFilter<"UserPreferences">
    travelFlexibility?: IntFilter<"UserPreferences"> | number
    currency?: StringFilter<"UserPreferences"> | string
    headerImageUrl?: StringNullableFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserPreferencesOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    homeAirports?: SortOrder
    dreamDestinations?: SortOrder
    deliveryFrequency?: SortOrder
    maxBudget?: SortOrderInput | SortOrder
    preferredAirlines?: SortOrderInput | SortOrder
    travelFlexibility?: SortOrder
    currency?: SortOrder
    headerImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserPreferencesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    OR?: UserPreferencesWhereInput[]
    NOT?: UserPreferencesWhereInput | UserPreferencesWhereInput[]
    homeAirports?: JsonFilter<"UserPreferences">
    dreamDestinations?: JsonFilter<"UserPreferences">
    deliveryFrequency?: StringFilter<"UserPreferences"> | string
    maxBudget?: FloatNullableFilter<"UserPreferences"> | number | null
    preferredAirlines?: JsonNullableFilter<"UserPreferences">
    travelFlexibility?: IntFilter<"UserPreferences"> | number
    currency?: StringFilter<"UserPreferences"> | string
    headerImageUrl?: StringNullableFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeFilter<"UserPreferences"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserPreferencesOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    homeAirports?: SortOrder
    dreamDestinations?: SortOrder
    deliveryFrequency?: SortOrder
    maxBudget?: SortOrderInput | SortOrder
    preferredAirlines?: SortOrderInput | SortOrder
    travelFlexibility?: SortOrder
    currency?: SortOrder
    headerImageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPreferencesCountOrderByAggregateInput
    _avg?: UserPreferencesAvgOrderByAggregateInput
    _max?: UserPreferencesMaxOrderByAggregateInput
    _min?: UserPreferencesMinOrderByAggregateInput
    _sum?: UserPreferencesSumOrderByAggregateInput
  }

  export type UserPreferencesScalarWhereWithAggregatesInput = {
    AND?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    OR?: UserPreferencesScalarWhereWithAggregatesInput[]
    NOT?: UserPreferencesScalarWhereWithAggregatesInput | UserPreferencesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPreferences"> | string
    userId?: StringWithAggregatesFilter<"UserPreferences"> | string
    homeAirports?: JsonWithAggregatesFilter<"UserPreferences">
    dreamDestinations?: JsonWithAggregatesFilter<"UserPreferences">
    deliveryFrequency?: StringWithAggregatesFilter<"UserPreferences"> | string
    maxBudget?: FloatNullableWithAggregatesFilter<"UserPreferences"> | number | null
    preferredAirlines?: JsonNullableWithAggregatesFilter<"UserPreferences">
    travelFlexibility?: IntWithAggregatesFilter<"UserPreferences"> | number
    currency?: StringWithAggregatesFilter<"UserPreferences"> | string
    headerImageUrl?: StringNullableWithAggregatesFilter<"UserPreferences"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPreferences"> | Date | string
  }

  export type FlightRecommendationWhereInput = {
    AND?: FlightRecommendationWhereInput | FlightRecommendationWhereInput[]
    OR?: FlightRecommendationWhereInput[]
    NOT?: FlightRecommendationWhereInput | FlightRecommendationWhereInput[]
    id?: StringFilter<"FlightRecommendation"> | string
    userId?: StringFilter<"FlightRecommendation"> | string
    origin?: StringFilter<"FlightRecommendation"> | string
    destination?: StringFilter<"FlightRecommendation"> | string
    departureDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightRecommendation"> | Date | string | null
    price?: FloatFilter<"FlightRecommendation"> | number
    currency?: StringFilter<"FlightRecommendation"> | string
    airline?: StringFilter<"FlightRecommendation"> | string
    flightNumber?: StringNullableFilter<"FlightRecommendation"> | string | null
    layovers?: JsonNullableFilter<"FlightRecommendation">
    duration?: StringNullableFilter<"FlightRecommendation"> | string | null
    baggageInfo?: JsonNullableFilter<"FlightRecommendation">
    aiSummary?: StringNullableFilter<"FlightRecommendation"> | string | null
    confidenceScore?: FloatNullableFilter<"FlightRecommendation"> | number | null
    dealQuality?: StringNullableFilter<"FlightRecommendation"> | string | null
    bookingUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    otaUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityImageUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityActivities?: JsonNullableFilter<"FlightRecommendation">
    searchDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    isActive?: BoolFilter<"FlightRecommendation"> | boolean
    isWatched?: BoolFilter<"FlightRecommendation"> | boolean
    createdAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type FlightRecommendationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    airline?: SortOrder
    flightNumber?: SortOrderInput | SortOrder
    layovers?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    baggageInfo?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    dealQuality?: SortOrderInput | SortOrder
    bookingUrl?: SortOrderInput | SortOrder
    otaUrl?: SortOrderInput | SortOrder
    cityImageUrl?: SortOrderInput | SortOrder
    cityActivities?: SortOrderInput | SortOrder
    searchDate?: SortOrder
    isActive?: SortOrder
    isWatched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FlightRecommendationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlightRecommendationWhereInput | FlightRecommendationWhereInput[]
    OR?: FlightRecommendationWhereInput[]
    NOT?: FlightRecommendationWhereInput | FlightRecommendationWhereInput[]
    userId?: StringFilter<"FlightRecommendation"> | string
    origin?: StringFilter<"FlightRecommendation"> | string
    destination?: StringFilter<"FlightRecommendation"> | string
    departureDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightRecommendation"> | Date | string | null
    price?: FloatFilter<"FlightRecommendation"> | number
    currency?: StringFilter<"FlightRecommendation"> | string
    airline?: StringFilter<"FlightRecommendation"> | string
    flightNumber?: StringNullableFilter<"FlightRecommendation"> | string | null
    layovers?: JsonNullableFilter<"FlightRecommendation">
    duration?: StringNullableFilter<"FlightRecommendation"> | string | null
    baggageInfo?: JsonNullableFilter<"FlightRecommendation">
    aiSummary?: StringNullableFilter<"FlightRecommendation"> | string | null
    confidenceScore?: FloatNullableFilter<"FlightRecommendation"> | number | null
    dealQuality?: StringNullableFilter<"FlightRecommendation"> | string | null
    bookingUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    otaUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityImageUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityActivities?: JsonNullableFilter<"FlightRecommendation">
    searchDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    isActive?: BoolFilter<"FlightRecommendation"> | boolean
    isWatched?: BoolFilter<"FlightRecommendation"> | boolean
    createdAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type FlightRecommendationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrderInput | SortOrder
    price?: SortOrder
    currency?: SortOrder
    airline?: SortOrder
    flightNumber?: SortOrderInput | SortOrder
    layovers?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    baggageInfo?: SortOrderInput | SortOrder
    aiSummary?: SortOrderInput | SortOrder
    confidenceScore?: SortOrderInput | SortOrder
    dealQuality?: SortOrderInput | SortOrder
    bookingUrl?: SortOrderInput | SortOrder
    otaUrl?: SortOrderInput | SortOrder
    cityImageUrl?: SortOrderInput | SortOrder
    cityActivities?: SortOrderInput | SortOrder
    searchDate?: SortOrder
    isActive?: SortOrder
    isWatched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlightRecommendationCountOrderByAggregateInput
    _avg?: FlightRecommendationAvgOrderByAggregateInput
    _max?: FlightRecommendationMaxOrderByAggregateInput
    _min?: FlightRecommendationMinOrderByAggregateInput
    _sum?: FlightRecommendationSumOrderByAggregateInput
  }

  export type FlightRecommendationScalarWhereWithAggregatesInput = {
    AND?: FlightRecommendationScalarWhereWithAggregatesInput | FlightRecommendationScalarWhereWithAggregatesInput[]
    OR?: FlightRecommendationScalarWhereWithAggregatesInput[]
    NOT?: FlightRecommendationScalarWhereWithAggregatesInput | FlightRecommendationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    userId?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    origin?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    destination?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    departureDate?: DateTimeWithAggregatesFilter<"FlightRecommendation"> | Date | string
    returnDate?: DateTimeNullableWithAggregatesFilter<"FlightRecommendation"> | Date | string | null
    price?: FloatWithAggregatesFilter<"FlightRecommendation"> | number
    currency?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    airline?: StringWithAggregatesFilter<"FlightRecommendation"> | string
    flightNumber?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    layovers?: JsonNullableWithAggregatesFilter<"FlightRecommendation">
    duration?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    baggageInfo?: JsonNullableWithAggregatesFilter<"FlightRecommendation">
    aiSummary?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    confidenceScore?: FloatNullableWithAggregatesFilter<"FlightRecommendation"> | number | null
    dealQuality?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    bookingUrl?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    otaUrl?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    cityImageUrl?: StringNullableWithAggregatesFilter<"FlightRecommendation"> | string | null
    cityActivities?: JsonNullableWithAggregatesFilter<"FlightRecommendation">
    searchDate?: DateTimeWithAggregatesFilter<"FlightRecommendation"> | Date | string
    isActive?: BoolWithAggregatesFilter<"FlightRecommendation"> | boolean
    isWatched?: BoolWithAggregatesFilter<"FlightRecommendation"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FlightRecommendation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FlightRecommendation"> | Date | string
  }

  export type StripeSubscriptionWhereInput = {
    AND?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    OR?: StripeSubscriptionWhereInput[]
    NOT?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    id?: StringFilter<"StripeSubscription"> | string
    userId?: StringFilter<"StripeSubscription"> | string
    stripeCustomerId?: StringFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringNullableFilter<"StripeSubscription"> | string | null
    stripePriceId?: StringNullableFilter<"StripeSubscription"> | string | null
    status?: StringFilter<"StripeSubscription"> | string
    currentPeriodStart?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"StripeSubscription"> | boolean
    amount?: FloatFilter<"StripeSubscription"> | number
    currency?: StringFilter<"StripeSubscription"> | string
    interval?: StringFilter<"StripeSubscription"> | string
    trialEnd?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type StripeSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trialEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type StripeSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    stripeCustomerId?: string
    stripeSubscriptionId?: string
    AND?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    OR?: StripeSubscriptionWhereInput[]
    NOT?: StripeSubscriptionWhereInput | StripeSubscriptionWhereInput[]
    stripePriceId?: StringNullableFilter<"StripeSubscription"> | string | null
    status?: StringFilter<"StripeSubscription"> | string
    currentPeriodStart?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolFilter<"StripeSubscription"> | boolean
    amount?: FloatFilter<"StripeSubscription"> | number
    currency?: StringFilter<"StripeSubscription"> | string
    interval?: StringFilter<"StripeSubscription"> | string
    trialEnd?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"StripeSubscription"> | Date | string | null
    createdAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeFilter<"StripeSubscription"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId" | "stripeCustomerId" | "stripeSubscriptionId">

  export type StripeSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrderInput | SortOrder
    stripePriceId?: SortOrderInput | SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrderInput | SortOrder
    currentPeriodEnd?: SortOrderInput | SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trialEnd?: SortOrderInput | SortOrder
    canceledAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StripeSubscriptionCountOrderByAggregateInput
    _avg?: StripeSubscriptionAvgOrderByAggregateInput
    _max?: StripeSubscriptionMaxOrderByAggregateInput
    _min?: StripeSubscriptionMinOrderByAggregateInput
    _sum?: StripeSubscriptionSumOrderByAggregateInput
  }

  export type StripeSubscriptionScalarWhereWithAggregatesInput = {
    AND?: StripeSubscriptionScalarWhereWithAggregatesInput | StripeSubscriptionScalarWhereWithAggregatesInput[]
    OR?: StripeSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: StripeSubscriptionScalarWhereWithAggregatesInput | StripeSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StripeSubscription"> | string
    userId?: StringWithAggregatesFilter<"StripeSubscription"> | string
    stripeCustomerId?: StringWithAggregatesFilter<"StripeSubscription"> | string
    stripeSubscriptionId?: StringNullableWithAggregatesFilter<"StripeSubscription"> | string | null
    stripePriceId?: StringNullableWithAggregatesFilter<"StripeSubscription"> | string | null
    status?: StringWithAggregatesFilter<"StripeSubscription"> | string
    currentPeriodStart?: DateTimeNullableWithAggregatesFilter<"StripeSubscription"> | Date | string | null
    currentPeriodEnd?: DateTimeNullableWithAggregatesFilter<"StripeSubscription"> | Date | string | null
    cancelAtPeriodEnd?: BoolWithAggregatesFilter<"StripeSubscription"> | boolean
    amount?: FloatWithAggregatesFilter<"StripeSubscription"> | number
    currency?: StringWithAggregatesFilter<"StripeSubscription"> | string
    interval?: StringWithAggregatesFilter<"StripeSubscription"> | string
    trialEnd?: DateTimeNullableWithAggregatesFilter<"StripeSubscription"> | Date | string | null
    canceledAt?: DateTimeNullableWithAggregatesFilter<"StripeSubscription"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"StripeSubscription"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StripeSubscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StripeSubscription"> | Date | string
  }

  export type EmailNotificationWhereInput = {
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    id?: StringFilter<"EmailNotification"> | string
    userId?: StringFilter<"EmailNotification"> | string
    subject?: StringFilter<"EmailNotification"> | string
    content?: StringFilter<"EmailNotification"> | string
    recipientEmail?: StringFilter<"EmailNotification"> | string
    notificationType?: StringFilter<"EmailNotification"> | string
    flightCount?: IntFilter<"EmailNotification"> | number
    status?: StringFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    errorMessage?: StringNullableFilter<"EmailNotification"> | string | null
    sendGridMessageId?: StringNullableFilter<"EmailNotification"> | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailNotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientEmail?: SortOrder
    notificationType?: SortOrder
    flightCount?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sendGridMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailNotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    OR?: EmailNotificationWhereInput[]
    NOT?: EmailNotificationWhereInput | EmailNotificationWhereInput[]
    userId?: StringFilter<"EmailNotification"> | string
    subject?: StringFilter<"EmailNotification"> | string
    content?: StringFilter<"EmailNotification"> | string
    recipientEmail?: StringFilter<"EmailNotification"> | string
    notificationType?: StringFilter<"EmailNotification"> | string
    flightCount?: IntFilter<"EmailNotification"> | number
    status?: StringFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    errorMessage?: StringNullableFilter<"EmailNotification"> | string | null
    sendGridMessageId?: StringNullableFilter<"EmailNotification"> | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EmailNotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientEmail?: SortOrder
    notificationType?: SortOrder
    flightCount?: SortOrder
    status?: SortOrder
    sentAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    sendGridMessageId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmailNotificationCountOrderByAggregateInput
    _avg?: EmailNotificationAvgOrderByAggregateInput
    _max?: EmailNotificationMaxOrderByAggregateInput
    _min?: EmailNotificationMinOrderByAggregateInput
    _sum?: EmailNotificationSumOrderByAggregateInput
  }

  export type EmailNotificationScalarWhereWithAggregatesInput = {
    AND?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    OR?: EmailNotificationScalarWhereWithAggregatesInput[]
    NOT?: EmailNotificationScalarWhereWithAggregatesInput | EmailNotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailNotification"> | string
    userId?: StringWithAggregatesFilter<"EmailNotification"> | string
    subject?: StringWithAggregatesFilter<"EmailNotification"> | string
    content?: StringWithAggregatesFilter<"EmailNotification"> | string
    recipientEmail?: StringWithAggregatesFilter<"EmailNotification"> | string
    notificationType?: StringWithAggregatesFilter<"EmailNotification"> | string
    flightCount?: IntWithAggregatesFilter<"EmailNotification"> | number
    status?: StringWithAggregatesFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"EmailNotification"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"EmailNotification"> | string | null
    sendGridMessageId?: StringNullableWithAggregatesFilter<"EmailNotification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailNotification"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtensionSessionCreateInput = {
    id?: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutExtensionSessionsInput
  }

  export type ExtensionSessionUncheckedCreateInput = {
    id?: string
    userId: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
  }

  export type ExtensionSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutExtensionSessionsNestedInput
  }

  export type ExtensionSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtensionSessionCreateManyInput = {
    id?: string
    userId: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
  }

  export type ExtensionSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtensionSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsCreateInput = {
    id?: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
    user: UserCreateNestedOneWithoutUsageMetricsInput
  }

  export type UsageMetricsUncheckedCreateInput = {
    id?: string
    userId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
  }

  export type UsageMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageMetricsNestedInput
  }

  export type UsageMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsCreateManyInput = {
    id?: string
    userId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
  }

  export type UsageMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsCreateInput = {
    id?: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUsageAnalyticsInput
  }

  export type UsageAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUsageAnalyticsNestedInput
  }

  export type UsageAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsCreateManyInput = {
    id?: string
    userId: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsCreateInput = {
    id?: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAutocompleteAnalyticsInput
  }

  export type AutocompleteAnalyticsUncheckedCreateInput = {
    id?: string
    userId: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAutocompleteAnalyticsNestedInput
  }

  export type AutocompleteAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsCreateManyInput = {
    id?: string
    userId: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsCreateInput = {
    id?: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
    user: UserCreateNestedOneWithoutAutocompleteMetricsInput
  }

  export type AutocompleteMetricsUncheckedCreateInput = {
    id?: string
    userId: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
  }

  export type AutocompleteMetricsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAutocompleteMetricsNestedInput
  }

  export type AutocompleteMetricsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsCreateManyInput = {
    id?: string
    userId: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
  }

  export type AutocompleteMetricsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateInput = {
    id?: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutApiKeysInput
  }

  export type ApiKeyUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutApiKeysNestedInput
  }

  export type ApiKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyCreateManyInput = {
    id?: string
    userId: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    email: string
    name?: string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    termsAccepted?: boolean
    extensionEnabled?: boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingLoginCreateInput = {
    id?: string
    deviceId: string
    state: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PendingLoginUncheckedCreateInput = {
    id?: string
    deviceId: string
    state: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PendingLoginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingLoginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingLoginCreateManyInput = {
    id?: string
    deviceId: string
    state: string
    token: string
    userId: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type PendingLoginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PendingLoginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PageCreateInput = {
    name: string
  }

  export type PageUncheckedCreateInput = {
    id?: number
    name: string
  }

  export type PageUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PageUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PageCreateManyInput = {
    id?: number
    name: string
  }

  export type PageUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PageUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type UserPreferencesCreateInput = {
    id?: string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: string
    maxBudget?: number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: number
    currency?: string
    headerImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTravelPreferencesInput
  }

  export type UserPreferencesUncheckedCreateInput = {
    id?: string
    userId: string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: string
    maxBudget?: number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: number
    currency?: string
    headerImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTravelPreferencesNestedInput
  }

  export type UserPreferencesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesCreateManyInput = {
    id?: string
    userId: string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: string
    maxBudget?: number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: number
    currency?: string
    headerImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationCreateInput = {
    id?: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFlightRecommendationsInput
  }

  export type FlightRecommendationUncheckedCreateInput = {
    id?: string
    userId: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightRecommendationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFlightRecommendationsNestedInput
  }

  export type FlightRecommendationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationCreateManyInput = {
    id?: string
    userId: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightRecommendationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionCreateInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    status?: string
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    amount?: number
    currency?: string
    interval?: string
    trialEnd?: Date | string | null
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStripeSubscriptionInput
  }

  export type StripeSubscriptionUncheckedCreateInput = {
    id?: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    status?: string
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    amount?: number
    currency?: string
    interval?: string
    trialEnd?: Date | string | null
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStripeSubscriptionNestedInput
  }

  export type StripeSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionCreateManyInput = {
    id?: string
    userId: string
    stripeCustomerId: string
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    status?: string
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    amount?: number
    currency?: string
    interval?: string
    trialEnd?: Date | string | null
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateInput = {
    id?: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutEmailNotificationsInput
  }

  export type EmailNotificationUncheckedCreateInput = {
    id?: string
    userId: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutEmailNotificationsNestedInput
  }

  export type EmailNotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationCreateManyInput = {
    id?: string
    userId: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ExtensionSessionListRelationFilter = {
    every?: ExtensionSessionWhereInput
    some?: ExtensionSessionWhereInput
    none?: ExtensionSessionWhereInput
  }

  export type UsageMetricsListRelationFilter = {
    every?: UsageMetricsWhereInput
    some?: UsageMetricsWhereInput
    none?: UsageMetricsWhereInput
  }

  export type ApiKeyListRelationFilter = {
    every?: ApiKeyWhereInput
    some?: ApiKeyWhereInput
    none?: ApiKeyWhereInput
  }

  export type UsageAnalyticsListRelationFilter = {
    every?: UsageAnalyticsWhereInput
    some?: UsageAnalyticsWhereInput
    none?: UsageAnalyticsWhereInput
  }

  export type AutocompleteAnalyticsListRelationFilter = {
    every?: AutocompleteAnalyticsWhereInput
    some?: AutocompleteAnalyticsWhereInput
    none?: AutocompleteAnalyticsWhereInput
  }

  export type AutocompleteMetricsListRelationFilter = {
    every?: AutocompleteMetricsWhereInput
    some?: AutocompleteMetricsWhereInput
    none?: AutocompleteMetricsWhereInput
  }

  export type UserPreferencesNullableScalarRelationFilter = {
    is?: UserPreferencesWhereInput | null
    isNot?: UserPreferencesWhereInput | null
  }

  export type FlightRecommendationListRelationFilter = {
    every?: FlightRecommendationWhereInput
    some?: FlightRecommendationWhereInput
    none?: FlightRecommendationWhereInput
  }

  export type StripeSubscriptionNullableScalarRelationFilter = {
    is?: StripeSubscriptionWhereInput | null
    isNot?: StripeSubscriptionWhereInput | null
  }

  export type EmailNotificationListRelationFilter = {
    every?: EmailNotificationWhereInput
    some?: EmailNotificationWhereInput
    none?: EmailNotificationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ExtensionSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApiKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsageAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutocompleteAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AutocompleteMetricsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlightRecommendationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailNotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    extensionApiKey?: SortOrder
    sessionToken?: SortOrder
    lastExtensionSync?: SortOrder
    lastSettingsSync?: SortOrder
    extensionEnabled?: SortOrder
    lastActiveAt?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
    unitsResetDate?: SortOrder
    extensionSettings?: SortOrder
    preferences?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    extensionApiKey?: SortOrder
    sessionToken?: SortOrder
    lastExtensionSync?: SortOrder
    lastSettingsSync?: SortOrder
    extensionEnabled?: SortOrder
    lastActiveAt?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
    unitsResetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    clerkId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    extensionApiKey?: SortOrder
    sessionToken?: SortOrder
    lastExtensionSync?: SortOrder
    lastSettingsSync?: SortOrder
    extensionEnabled?: SortOrder
    lastActiveAt?: SortOrder
    termsAccepted?: SortOrder
    termsAcceptedAt?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
    unitsResetDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    cubentUnitsUsed?: SortOrder
    cubentUnitsLimit?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ExtensionSessionUserIdSessionIdCompoundUniqueInput = {
    userId: string
    sessionId: string
  }

  export type ExtensionSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    lastActiveAt?: SortOrder
    extensionVersion?: SortOrder
    vscodeVersion?: SortOrder
    platform?: SortOrder
    metadata?: SortOrder
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtensionSessionAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
  }

  export type ExtensionSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    lastActiveAt?: SortOrder
    extensionVersion?: SortOrder
    vscodeVersion?: SortOrder
    platform?: SortOrder
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtensionSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    sessionId?: SortOrder
    isActive?: SortOrder
    lastActiveAt?: SortOrder
    extensionVersion?: SortOrder
    vscodeVersion?: SortOrder
    platform?: SortOrder
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
    createdAt?: SortOrder
  }

  export type ExtensionSessionSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    requestsMade?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UsageMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    date?: SortOrder
  }

  export type UsageMetricsAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
  }

  export type UsageMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    date?: SortOrder
  }

  export type UsageMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    date?: SortOrder
  }

  export type UsageMetricsSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
  }

  export type UsageAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    sessionId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageAnalyticsAvgOrderByAggregateInput = {
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
  }

  export type UsageAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
    sessionId?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageAnalyticsSumOrderByAggregateInput = {
    tokensUsed?: SortOrder
    inputTokens?: SortOrder
    outputTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    cubentUnitsUsed?: SortOrder
    requestsMade?: SortOrder
    costAccrued?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type AutocompleteAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    provider?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    language?: SortOrder
    filepath?: SortOrder
    sessionId?: SortOrder
    avgLatency?: SortOrder
    successRate?: SortOrder
    acceptanceRate?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AutocompleteAnalyticsAvgOrderByAggregateInput = {
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    successRate?: SortOrder
    acceptanceRate?: SortOrder
  }

  export type AutocompleteAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    provider?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    language?: SortOrder
    filepath?: SortOrder
    sessionId?: SortOrder
    avgLatency?: SortOrder
    successRate?: SortOrder
    acceptanceRate?: SortOrder
    createdAt?: SortOrder
  }

  export type AutocompleteAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    modelId?: SortOrder
    provider?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    language?: SortOrder
    filepath?: SortOrder
    sessionId?: SortOrder
    avgLatency?: SortOrder
    successRate?: SortOrder
    acceptanceRate?: SortOrder
    createdAt?: SortOrder
  }

  export type AutocompleteAnalyticsSumOrderByAggregateInput = {
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    successRate?: SortOrder
    acceptanceRate?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type AutocompleteMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
    modelBreakdown?: SortOrder
    date?: SortOrder
  }

  export type AutocompleteMetricsAvgOrderByAggregateInput = {
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
  }

  export type AutocompleteMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
    date?: SortOrder
  }

  export type AutocompleteMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
    date?: SortOrder
  }

  export type AutocompleteMetricsSumOrderByAggregateInput = {
    completionsGenerated?: SortOrder
    completionsAccepted?: SortOrder
    linesAdded?: SortOrder
    charactersAdded?: SortOrder
    avgLatency?: SortOrder
    avgSuccessRate?: SortOrder
    avgAcceptanceRate?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ApiKeyCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keyHash?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyAvgOrderByAggregateInput = {
    usageCount?: SortOrder
  }

  export type ApiKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeyMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    keyHash?: SortOrder
    isActive?: SortOrder
    expiresAt?: SortOrder
    lastUsedAt?: SortOrder
    usageCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ApiKeySumOrderByAggregateInput = {
    usageCount?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    termsAccepted?: SortOrder
    extensionEnabled?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    termsAccepted?: SortOrder
    extensionEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    subscriptionTier?: SortOrder
    subscriptionStatus?: SortOrder
    termsAccepted?: SortOrder
    extensionEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PendingLoginCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    state?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PendingLoginMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    state?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PendingLoginMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    state?: SortOrder
    token?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type PageCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PageAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PageMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PageMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type PageSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserPreferencesCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    homeAirports?: SortOrder
    dreamDestinations?: SortOrder
    deliveryFrequency?: SortOrder
    maxBudget?: SortOrder
    preferredAirlines?: SortOrder
    travelFlexibility?: SortOrder
    currency?: SortOrder
    headerImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesAvgOrderByAggregateInput = {
    maxBudget?: SortOrder
    travelFlexibility?: SortOrder
  }

  export type UserPreferencesMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryFrequency?: SortOrder
    maxBudget?: SortOrder
    travelFlexibility?: SortOrder
    currency?: SortOrder
    headerImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deliveryFrequency?: SortOrder
    maxBudget?: SortOrder
    travelFlexibility?: SortOrder
    currency?: SortOrder
    headerImageUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPreferencesSumOrderByAggregateInput = {
    maxBudget?: SortOrder
    travelFlexibility?: SortOrder
  }

  export type FlightRecommendationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    airline?: SortOrder
    flightNumber?: SortOrder
    layovers?: SortOrder
    duration?: SortOrder
    baggageInfo?: SortOrder
    aiSummary?: SortOrder
    confidenceScore?: SortOrder
    dealQuality?: SortOrder
    bookingUrl?: SortOrder
    otaUrl?: SortOrder
    cityImageUrl?: SortOrder
    cityActivities?: SortOrder
    searchDate?: SortOrder
    isActive?: SortOrder
    isWatched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightRecommendationAvgOrderByAggregateInput = {
    price?: SortOrder
    confidenceScore?: SortOrder
  }

  export type FlightRecommendationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    airline?: SortOrder
    flightNumber?: SortOrder
    duration?: SortOrder
    aiSummary?: SortOrder
    confidenceScore?: SortOrder
    dealQuality?: SortOrder
    bookingUrl?: SortOrder
    otaUrl?: SortOrder
    cityImageUrl?: SortOrder
    searchDate?: SortOrder
    isActive?: SortOrder
    isWatched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightRecommendationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    origin?: SortOrder
    destination?: SortOrder
    departureDate?: SortOrder
    returnDate?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    airline?: SortOrder
    flightNumber?: SortOrder
    duration?: SortOrder
    aiSummary?: SortOrder
    confidenceScore?: SortOrder
    dealQuality?: SortOrder
    bookingUrl?: SortOrder
    otaUrl?: SortOrder
    cityImageUrl?: SortOrder
    searchDate?: SortOrder
    isActive?: SortOrder
    isWatched?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlightRecommendationSumOrderByAggregateInput = {
    price?: SortOrder
    confidenceScore?: SortOrder
  }

  export type StripeSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trialEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeSubscriptionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StripeSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trialEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    stripeCustomerId?: SortOrder
    stripeSubscriptionId?: SortOrder
    stripePriceId?: SortOrder
    status?: SortOrder
    currentPeriodStart?: SortOrder
    currentPeriodEnd?: SortOrder
    cancelAtPeriodEnd?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    interval?: SortOrder
    trialEnd?: SortOrder
    canceledAt?: SortOrder
    endedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StripeSubscriptionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EmailNotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientEmail?: SortOrder
    notificationType?: SortOrder
    flightCount?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    sendGridMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailNotificationAvgOrderByAggregateInput = {
    flightCount?: SortOrder
  }

  export type EmailNotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientEmail?: SortOrder
    notificationType?: SortOrder
    flightCount?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    sendGridMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailNotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientEmail?: SortOrder
    notificationType?: SortOrder
    flightCount?: SortOrder
    status?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    sendGridMessageId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmailNotificationSumOrderByAggregateInput = {
    flightCount?: SortOrder
  }

  export type ExtensionSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput> | ExtensionSessionCreateWithoutUserInput[] | ExtensionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExtensionSessionCreateOrConnectWithoutUserInput | ExtensionSessionCreateOrConnectWithoutUserInput[]
    createMany?: ExtensionSessionCreateManyUserInputEnvelope
    connect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
  }

  export type UsageMetricsCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput> | UsageMetricsCreateWithoutUserInput[] | UsageMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricsCreateOrConnectWithoutUserInput | UsageMetricsCreateOrConnectWithoutUserInput[]
    createMany?: UsageMetricsCreateManyUserInputEnvelope
    connect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
  }

  export type ApiKeyCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type UsageAnalyticsCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput> | UsageAnalyticsCreateWithoutUserInput[] | UsageAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageAnalyticsCreateOrConnectWithoutUserInput | UsageAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: UsageAnalyticsCreateManyUserInputEnvelope
    connect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
  }

  export type AutocompleteAnalyticsCreateNestedManyWithoutUserInput = {
    create?: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput> | AutocompleteAnalyticsCreateWithoutUserInput[] | AutocompleteAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteAnalyticsCreateOrConnectWithoutUserInput | AutocompleteAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: AutocompleteAnalyticsCreateManyUserInputEnvelope
    connect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
  }

  export type AutocompleteMetricsCreateNestedManyWithoutUserInput = {
    create?: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput> | AutocompleteMetricsCreateWithoutUserInput[] | AutocompleteMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteMetricsCreateOrConnectWithoutUserInput | AutocompleteMetricsCreateOrConnectWithoutUserInput[]
    createMany?: AutocompleteMetricsCreateManyUserInputEnvelope
    connect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
  }

  export type UserPreferencesCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type FlightRecommendationCreateNestedManyWithoutUserInput = {
    create?: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput> | FlightRecommendationCreateWithoutUserInput[] | FlightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlightRecommendationCreateOrConnectWithoutUserInput | FlightRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: FlightRecommendationCreateManyUserInputEnvelope
    connect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
  }

  export type StripeSubscriptionCreateNestedOneWithoutUserInput = {
    create?: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutUserInput
    connect?: StripeSubscriptionWhereUniqueInput
  }

  export type EmailNotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
  }

  export type ExtensionSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput> | ExtensionSessionCreateWithoutUserInput[] | ExtensionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExtensionSessionCreateOrConnectWithoutUserInput | ExtensionSessionCreateOrConnectWithoutUserInput[]
    createMany?: ExtensionSessionCreateManyUserInputEnvelope
    connect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
  }

  export type UsageMetricsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput> | UsageMetricsCreateWithoutUserInput[] | UsageMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricsCreateOrConnectWithoutUserInput | UsageMetricsCreateOrConnectWithoutUserInput[]
    createMany?: UsageMetricsCreateManyUserInputEnvelope
    connect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
  }

  export type ApiKeyUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
  }

  export type UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput> | UsageAnalyticsCreateWithoutUserInput[] | UsageAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageAnalyticsCreateOrConnectWithoutUserInput | UsageAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: UsageAnalyticsCreateManyUserInputEnvelope
    connect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
  }

  export type AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput> | AutocompleteAnalyticsCreateWithoutUserInput[] | AutocompleteAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteAnalyticsCreateOrConnectWithoutUserInput | AutocompleteAnalyticsCreateOrConnectWithoutUserInput[]
    createMany?: AutocompleteAnalyticsCreateManyUserInputEnvelope
    connect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
  }

  export type AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput> | AutocompleteMetricsCreateWithoutUserInput[] | AutocompleteMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteMetricsCreateOrConnectWithoutUserInput | AutocompleteMetricsCreateOrConnectWithoutUserInput[]
    createMany?: AutocompleteMetricsCreateManyUserInputEnvelope
    connect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
  }

  export type UserPreferencesUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    connect?: UserPreferencesWhereUniqueInput
  }

  export type FlightRecommendationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput> | FlightRecommendationCreateWithoutUserInput[] | FlightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlightRecommendationCreateOrConnectWithoutUserInput | FlightRecommendationCreateOrConnectWithoutUserInput[]
    createMany?: FlightRecommendationCreateManyUserInputEnvelope
    connect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
  }

  export type StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutUserInput
    connect?: StripeSubscriptionWhereUniqueInput
  }

  export type EmailNotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ExtensionSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput> | ExtensionSessionCreateWithoutUserInput[] | ExtensionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExtensionSessionCreateOrConnectWithoutUserInput | ExtensionSessionCreateOrConnectWithoutUserInput[]
    upsert?: ExtensionSessionUpsertWithWhereUniqueWithoutUserInput | ExtensionSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExtensionSessionCreateManyUserInputEnvelope
    set?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    disconnect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    delete?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    connect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    update?: ExtensionSessionUpdateWithWhereUniqueWithoutUserInput | ExtensionSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExtensionSessionUpdateManyWithWhereWithoutUserInput | ExtensionSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExtensionSessionScalarWhereInput | ExtensionSessionScalarWhereInput[]
  }

  export type UsageMetricsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput> | UsageMetricsCreateWithoutUserInput[] | UsageMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricsCreateOrConnectWithoutUserInput | UsageMetricsCreateOrConnectWithoutUserInput[]
    upsert?: UsageMetricsUpsertWithWhereUniqueWithoutUserInput | UsageMetricsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageMetricsCreateManyUserInputEnvelope
    set?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    disconnect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    delete?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    connect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    update?: UsageMetricsUpdateWithWhereUniqueWithoutUserInput | UsageMetricsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageMetricsUpdateManyWithWhereWithoutUserInput | UsageMetricsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageMetricsScalarWhereInput | UsageMetricsScalarWhereInput[]
  }

  export type ApiKeyUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UsageAnalyticsUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput> | UsageAnalyticsCreateWithoutUserInput[] | UsageAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageAnalyticsCreateOrConnectWithoutUserInput | UsageAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: UsageAnalyticsUpsertWithWhereUniqueWithoutUserInput | UsageAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageAnalyticsCreateManyUserInputEnvelope
    set?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    disconnect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    delete?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    connect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    update?: UsageAnalyticsUpdateWithWhereUniqueWithoutUserInput | UsageAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageAnalyticsUpdateManyWithWhereWithoutUserInput | UsageAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageAnalyticsScalarWhereInput | UsageAnalyticsScalarWhereInput[]
  }

  export type AutocompleteAnalyticsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput> | AutocompleteAnalyticsCreateWithoutUserInput[] | AutocompleteAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteAnalyticsCreateOrConnectWithoutUserInput | AutocompleteAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: AutocompleteAnalyticsUpsertWithWhereUniqueWithoutUserInput | AutocompleteAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutocompleteAnalyticsCreateManyUserInputEnvelope
    set?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    disconnect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    delete?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    connect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    update?: AutocompleteAnalyticsUpdateWithWhereUniqueWithoutUserInput | AutocompleteAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutocompleteAnalyticsUpdateManyWithWhereWithoutUserInput | AutocompleteAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutocompleteAnalyticsScalarWhereInput | AutocompleteAnalyticsScalarWhereInput[]
  }

  export type AutocompleteMetricsUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput> | AutocompleteMetricsCreateWithoutUserInput[] | AutocompleteMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteMetricsCreateOrConnectWithoutUserInput | AutocompleteMetricsCreateOrConnectWithoutUserInput[]
    upsert?: AutocompleteMetricsUpsertWithWhereUniqueWithoutUserInput | AutocompleteMetricsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutocompleteMetricsCreateManyUserInputEnvelope
    set?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    disconnect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    delete?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    connect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    update?: AutocompleteMetricsUpdateWithWhereUniqueWithoutUserInput | AutocompleteMetricsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutocompleteMetricsUpdateManyWithWhereWithoutUserInput | AutocompleteMetricsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutocompleteMetricsScalarWhereInput | AutocompleteMetricsScalarWhereInput[]
  }

  export type UserPreferencesUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type FlightRecommendationUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput> | FlightRecommendationCreateWithoutUserInput[] | FlightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlightRecommendationCreateOrConnectWithoutUserInput | FlightRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: FlightRecommendationUpsertWithWhereUniqueWithoutUserInput | FlightRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlightRecommendationCreateManyUserInputEnvelope
    set?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    disconnect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    delete?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    connect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    update?: FlightRecommendationUpdateWithWhereUniqueWithoutUserInput | FlightRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlightRecommendationUpdateManyWithWhereWithoutUserInput | FlightRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlightRecommendationScalarWhereInput | FlightRecommendationScalarWhereInput[]
  }

  export type StripeSubscriptionUpdateOneWithoutUserNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutUserInput
    upsert?: StripeSubscriptionUpsertWithoutUserInput
    disconnect?: StripeSubscriptionWhereInput | boolean
    delete?: StripeSubscriptionWhereInput | boolean
    connect?: StripeSubscriptionWhereUniqueInput
    update?: XOR<XOR<StripeSubscriptionUpdateToOneWithWhereWithoutUserInput, StripeSubscriptionUpdateWithoutUserInput>, StripeSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type EmailNotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailNotificationUpsertWithWhereUniqueWithoutUserInput | EmailNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    set?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    disconnect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    delete?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    update?: EmailNotificationUpdateWithWhereUniqueWithoutUserInput | EmailNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailNotificationUpdateManyWithWhereWithoutUserInput | EmailNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
  }

  export type ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput> | ExtensionSessionCreateWithoutUserInput[] | ExtensionSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ExtensionSessionCreateOrConnectWithoutUserInput | ExtensionSessionCreateOrConnectWithoutUserInput[]
    upsert?: ExtensionSessionUpsertWithWhereUniqueWithoutUserInput | ExtensionSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ExtensionSessionCreateManyUserInputEnvelope
    set?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    disconnect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    delete?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    connect?: ExtensionSessionWhereUniqueInput | ExtensionSessionWhereUniqueInput[]
    update?: ExtensionSessionUpdateWithWhereUniqueWithoutUserInput | ExtensionSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ExtensionSessionUpdateManyWithWhereWithoutUserInput | ExtensionSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ExtensionSessionScalarWhereInput | ExtensionSessionScalarWhereInput[]
  }

  export type UsageMetricsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput> | UsageMetricsCreateWithoutUserInput[] | UsageMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageMetricsCreateOrConnectWithoutUserInput | UsageMetricsCreateOrConnectWithoutUserInput[]
    upsert?: UsageMetricsUpsertWithWhereUniqueWithoutUserInput | UsageMetricsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageMetricsCreateManyUserInputEnvelope
    set?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    disconnect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    delete?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    connect?: UsageMetricsWhereUniqueInput | UsageMetricsWhereUniqueInput[]
    update?: UsageMetricsUpdateWithWhereUniqueWithoutUserInput | UsageMetricsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageMetricsUpdateManyWithWhereWithoutUserInput | UsageMetricsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageMetricsScalarWhereInput | UsageMetricsScalarWhereInput[]
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput> | ApiKeyCreateWithoutUserInput[] | ApiKeyUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ApiKeyCreateOrConnectWithoutUserInput | ApiKeyCreateOrConnectWithoutUserInput[]
    upsert?: ApiKeyUpsertWithWhereUniqueWithoutUserInput | ApiKeyUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ApiKeyCreateManyUserInputEnvelope
    set?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    disconnect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    delete?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    connect?: ApiKeyWhereUniqueInput | ApiKeyWhereUniqueInput[]
    update?: ApiKeyUpdateWithWhereUniqueWithoutUserInput | ApiKeyUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ApiKeyUpdateManyWithWhereWithoutUserInput | ApiKeyUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
  }

  export type UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput> | UsageAnalyticsCreateWithoutUserInput[] | UsageAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UsageAnalyticsCreateOrConnectWithoutUserInput | UsageAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: UsageAnalyticsUpsertWithWhereUniqueWithoutUserInput | UsageAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UsageAnalyticsCreateManyUserInputEnvelope
    set?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    disconnect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    delete?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    connect?: UsageAnalyticsWhereUniqueInput | UsageAnalyticsWhereUniqueInput[]
    update?: UsageAnalyticsUpdateWithWhereUniqueWithoutUserInput | UsageAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UsageAnalyticsUpdateManyWithWhereWithoutUserInput | UsageAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UsageAnalyticsScalarWhereInput | UsageAnalyticsScalarWhereInput[]
  }

  export type AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput> | AutocompleteAnalyticsCreateWithoutUserInput[] | AutocompleteAnalyticsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteAnalyticsCreateOrConnectWithoutUserInput | AutocompleteAnalyticsCreateOrConnectWithoutUserInput[]
    upsert?: AutocompleteAnalyticsUpsertWithWhereUniqueWithoutUserInput | AutocompleteAnalyticsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutocompleteAnalyticsCreateManyUserInputEnvelope
    set?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    disconnect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    delete?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    connect?: AutocompleteAnalyticsWhereUniqueInput | AutocompleteAnalyticsWhereUniqueInput[]
    update?: AutocompleteAnalyticsUpdateWithWhereUniqueWithoutUserInput | AutocompleteAnalyticsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutocompleteAnalyticsUpdateManyWithWhereWithoutUserInput | AutocompleteAnalyticsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutocompleteAnalyticsScalarWhereInput | AutocompleteAnalyticsScalarWhereInput[]
  }

  export type AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput> | AutocompleteMetricsCreateWithoutUserInput[] | AutocompleteMetricsUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AutocompleteMetricsCreateOrConnectWithoutUserInput | AutocompleteMetricsCreateOrConnectWithoutUserInput[]
    upsert?: AutocompleteMetricsUpsertWithWhereUniqueWithoutUserInput | AutocompleteMetricsUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AutocompleteMetricsCreateManyUserInputEnvelope
    set?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    disconnect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    delete?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    connect?: AutocompleteMetricsWhereUniqueInput | AutocompleteMetricsWhereUniqueInput[]
    update?: AutocompleteMetricsUpdateWithWhereUniqueWithoutUserInput | AutocompleteMetricsUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AutocompleteMetricsUpdateManyWithWhereWithoutUserInput | AutocompleteMetricsUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AutocompleteMetricsScalarWhereInput | AutocompleteMetricsScalarWhereInput[]
  }

  export type UserPreferencesUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserPreferencesCreateOrConnectWithoutUserInput
    upsert?: UserPreferencesUpsertWithoutUserInput
    disconnect?: UserPreferencesWhereInput | boolean
    delete?: UserPreferencesWhereInput | boolean
    connect?: UserPreferencesWhereUniqueInput
    update?: XOR<XOR<UserPreferencesUpdateToOneWithWhereWithoutUserInput, UserPreferencesUpdateWithoutUserInput>, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput> | FlightRecommendationCreateWithoutUserInput[] | FlightRecommendationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FlightRecommendationCreateOrConnectWithoutUserInput | FlightRecommendationCreateOrConnectWithoutUserInput[]
    upsert?: FlightRecommendationUpsertWithWhereUniqueWithoutUserInput | FlightRecommendationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FlightRecommendationCreateManyUserInputEnvelope
    set?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    disconnect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    delete?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    connect?: FlightRecommendationWhereUniqueInput | FlightRecommendationWhereUniqueInput[]
    update?: FlightRecommendationUpdateWithWhereUniqueWithoutUserInput | FlightRecommendationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FlightRecommendationUpdateManyWithWhereWithoutUserInput | FlightRecommendationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FlightRecommendationScalarWhereInput | FlightRecommendationScalarWhereInput[]
  }

  export type StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
    connectOrCreate?: StripeSubscriptionCreateOrConnectWithoutUserInput
    upsert?: StripeSubscriptionUpsertWithoutUserInput
    disconnect?: StripeSubscriptionWhereInput | boolean
    delete?: StripeSubscriptionWhereInput | boolean
    connect?: StripeSubscriptionWhereUniqueInput
    update?: XOR<XOR<StripeSubscriptionUpdateToOneWithWhereWithoutUserInput, StripeSubscriptionUpdateWithoutUserInput>, StripeSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type EmailNotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput> | EmailNotificationCreateWithoutUserInput[] | EmailNotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailNotificationCreateOrConnectWithoutUserInput | EmailNotificationCreateOrConnectWithoutUserInput[]
    upsert?: EmailNotificationUpsertWithWhereUniqueWithoutUserInput | EmailNotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailNotificationCreateManyUserInputEnvelope
    set?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    disconnect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    delete?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    connect?: EmailNotificationWhereUniqueInput | EmailNotificationWhereUniqueInput[]
    update?: EmailNotificationUpdateWithWhereUniqueWithoutUserInput | EmailNotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailNotificationUpdateManyWithWhereWithoutUserInput | EmailNotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutExtensionSessionsInput = {
    create?: XOR<UserCreateWithoutExtensionSessionsInput, UserUncheckedCreateWithoutExtensionSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExtensionSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutExtensionSessionsNestedInput = {
    create?: XOR<UserCreateWithoutExtensionSessionsInput, UserUncheckedCreateWithoutExtensionSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExtensionSessionsInput
    upsert?: UserUpsertWithoutExtensionSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExtensionSessionsInput, UserUpdateWithoutExtensionSessionsInput>, UserUncheckedUpdateWithoutExtensionSessionsInput>
  }

  export type UserCreateNestedOneWithoutUsageMetricsInput = {
    create?: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageMetricsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageMetricsNestedInput = {
    create?: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageMetricsInput
    upsert?: UserUpsertWithoutUsageMetricsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageMetricsInput, UserUpdateWithoutUsageMetricsInput>, UserUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type UserCreateNestedOneWithoutUsageAnalyticsInput = {
    create?: XOR<UserCreateWithoutUsageAnalyticsInput, UserUncheckedCreateWithoutUsageAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutUsageAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutUsageAnalyticsInput, UserUncheckedCreateWithoutUsageAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutUsageAnalyticsInput
    upsert?: UserUpsertWithoutUsageAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUsageAnalyticsInput, UserUpdateWithoutUsageAnalyticsInput>, UserUncheckedUpdateWithoutUsageAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutAutocompleteAnalyticsInput = {
    create?: XOR<UserCreateWithoutAutocompleteAnalyticsInput, UserUncheckedCreateWithoutAutocompleteAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutocompleteAnalyticsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAutocompleteAnalyticsNestedInput = {
    create?: XOR<UserCreateWithoutAutocompleteAnalyticsInput, UserUncheckedCreateWithoutAutocompleteAnalyticsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutocompleteAnalyticsInput
    upsert?: UserUpsertWithoutAutocompleteAnalyticsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutocompleteAnalyticsInput, UserUpdateWithoutAutocompleteAnalyticsInput>, UserUncheckedUpdateWithoutAutocompleteAnalyticsInput>
  }

  export type UserCreateNestedOneWithoutAutocompleteMetricsInput = {
    create?: XOR<UserCreateWithoutAutocompleteMetricsInput, UserUncheckedCreateWithoutAutocompleteMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutocompleteMetricsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAutocompleteMetricsNestedInput = {
    create?: XOR<UserCreateWithoutAutocompleteMetricsInput, UserUncheckedCreateWithoutAutocompleteMetricsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAutocompleteMetricsInput
    upsert?: UserUpsertWithoutAutocompleteMetricsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAutocompleteMetricsInput, UserUpdateWithoutAutocompleteMetricsInput>, UserUncheckedUpdateWithoutAutocompleteMetricsInput>
  }

  export type UserCreateNestedOneWithoutApiKeysInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutApiKeysNestedInput = {
    create?: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    connectOrCreate?: UserCreateOrConnectWithoutApiKeysInput
    upsert?: UserUpsertWithoutApiKeysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApiKeysInput, UserUpdateWithoutApiKeysInput>, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserCreateNestedOneWithoutTravelPreferencesInput = {
    create?: XOR<UserCreateWithoutTravelPreferencesInput, UserUncheckedCreateWithoutTravelPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTravelPreferencesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTravelPreferencesNestedInput = {
    create?: XOR<UserCreateWithoutTravelPreferencesInput, UserUncheckedCreateWithoutTravelPreferencesInput>
    connectOrCreate?: UserCreateOrConnectWithoutTravelPreferencesInput
    upsert?: UserUpsertWithoutTravelPreferencesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTravelPreferencesInput, UserUpdateWithoutTravelPreferencesInput>, UserUncheckedUpdateWithoutTravelPreferencesInput>
  }

  export type UserCreateNestedOneWithoutFlightRecommendationsInput = {
    create?: XOR<UserCreateWithoutFlightRecommendationsInput, UserUncheckedCreateWithoutFlightRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlightRecommendationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutFlightRecommendationsNestedInput = {
    create?: XOR<UserCreateWithoutFlightRecommendationsInput, UserUncheckedCreateWithoutFlightRecommendationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlightRecommendationsInput
    upsert?: UserUpsertWithoutFlightRecommendationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlightRecommendationsInput, UserUpdateWithoutFlightRecommendationsInput>, UserUncheckedUpdateWithoutFlightRecommendationsInput>
  }

  export type UserCreateNestedOneWithoutStripeSubscriptionInput = {
    create?: XOR<UserCreateWithoutStripeSubscriptionInput, UserUncheckedCreateWithoutStripeSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutStripeSubscriptionInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutStripeSubscriptionNestedInput = {
    create?: XOR<UserCreateWithoutStripeSubscriptionInput, UserUncheckedCreateWithoutStripeSubscriptionInput>
    connectOrCreate?: UserCreateOrConnectWithoutStripeSubscriptionInput
    upsert?: UserUpsertWithoutStripeSubscriptionInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStripeSubscriptionInput, UserUpdateWithoutStripeSubscriptionInput>, UserUncheckedUpdateWithoutStripeSubscriptionInput>
  }

  export type UserCreateNestedOneWithoutEmailNotificationsInput = {
    create?: XOR<UserCreateWithoutEmailNotificationsInput, UserUncheckedCreateWithoutEmailNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutEmailNotificationsInput, UserUncheckedCreateWithoutEmailNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailNotificationsInput
    upsert?: UserUpsertWithoutEmailNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailNotificationsInput, UserUpdateWithoutEmailNotificationsInput>, UserUncheckedUpdateWithoutEmailNotificationsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ExtensionSessionCreateWithoutUserInput = {
    id?: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
  }

  export type ExtensionSessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
  }

  export type ExtensionSessionCreateOrConnectWithoutUserInput = {
    where: ExtensionSessionWhereUniqueInput
    create: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput>
  }

  export type ExtensionSessionCreateManyUserInputEnvelope = {
    data: ExtensionSessionCreateManyUserInput | ExtensionSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageMetricsCreateWithoutUserInput = {
    id?: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
  }

  export type UsageMetricsUncheckedCreateWithoutUserInput = {
    id?: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
  }

  export type UsageMetricsCreateOrConnectWithoutUserInput = {
    where: UsageMetricsWhereUniqueInput
    create: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput>
  }

  export type UsageMetricsCreateManyUserInputEnvelope = {
    data: UsageMetricsCreateManyUserInput | UsageMetricsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ApiKeyCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ApiKeyCreateOrConnectWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyCreateManyUserInputEnvelope = {
    data: ApiKeyCreateManyUserInput | ApiKeyCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UsageAnalyticsCreateWithoutUserInput = {
    id?: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type UsageAnalyticsCreateOrConnectWithoutUserInput = {
    where: UsageAnalyticsWhereUniqueInput
    create: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type UsageAnalyticsCreateManyUserInputEnvelope = {
    data: UsageAnalyticsCreateManyUserInput | UsageAnalyticsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutocompleteAnalyticsCreateWithoutUserInput = {
    id?: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteAnalyticsUncheckedCreateWithoutUserInput = {
    id?: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteAnalyticsCreateOrConnectWithoutUserInput = {
    where: AutocompleteAnalyticsWhereUniqueInput
    create: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type AutocompleteAnalyticsCreateManyUserInputEnvelope = {
    data: AutocompleteAnalyticsCreateManyUserInput | AutocompleteAnalyticsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AutocompleteMetricsCreateWithoutUserInput = {
    id?: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
  }

  export type AutocompleteMetricsUncheckedCreateWithoutUserInput = {
    id?: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
  }

  export type AutocompleteMetricsCreateOrConnectWithoutUserInput = {
    where: AutocompleteMetricsWhereUniqueInput
    create: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput>
  }

  export type AutocompleteMetricsCreateManyUserInputEnvelope = {
    data: AutocompleteMetricsCreateManyUserInput | AutocompleteMetricsCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserPreferencesCreateWithoutUserInput = {
    id?: string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: string
    maxBudget?: number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: number
    currency?: string
    headerImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesUncheckedCreateWithoutUserInput = {
    id?: string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: string
    maxBudget?: number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: number
    currency?: string
    headerImageUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPreferencesCreateOrConnectWithoutUserInput = {
    where: UserPreferencesWhereUniqueInput
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
  }

  export type FlightRecommendationCreateWithoutUserInput = {
    id?: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightRecommendationUncheckedCreateWithoutUserInput = {
    id?: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlightRecommendationCreateOrConnectWithoutUserInput = {
    where: FlightRecommendationWhereUniqueInput
    create: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput>
  }

  export type FlightRecommendationCreateManyUserInputEnvelope = {
    data: FlightRecommendationCreateManyUserInput | FlightRecommendationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type StripeSubscriptionCreateWithoutUserInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    status?: string
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    amount?: number
    currency?: string
    interval?: string
    trialEnd?: Date | string | null
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string
    stripeCustomerId: string
    stripeSubscriptionId?: string | null
    stripePriceId?: string | null
    status?: string
    currentPeriodStart?: Date | string | null
    currentPeriodEnd?: Date | string | null
    cancelAtPeriodEnd?: boolean
    amount?: number
    currency?: string
    interval?: string
    trialEnd?: Date | string | null
    canceledAt?: Date | string | null
    endedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StripeSubscriptionCreateOrConnectWithoutUserInput = {
    where: StripeSubscriptionWhereUniqueInput
    create: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
  }

  export type EmailNotificationCreateWithoutUserInput = {
    id?: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationUncheckedCreateWithoutUserInput = {
    id?: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationCreateOrConnectWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    create: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput>
  }

  export type EmailNotificationCreateManyUserInputEnvelope = {
    data: EmailNotificationCreateManyUserInput | EmailNotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ExtensionSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: ExtensionSessionWhereUniqueInput
    update: XOR<ExtensionSessionUpdateWithoutUserInput, ExtensionSessionUncheckedUpdateWithoutUserInput>
    create: XOR<ExtensionSessionCreateWithoutUserInput, ExtensionSessionUncheckedCreateWithoutUserInput>
  }

  export type ExtensionSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: ExtensionSessionWhereUniqueInput
    data: XOR<ExtensionSessionUpdateWithoutUserInput, ExtensionSessionUncheckedUpdateWithoutUserInput>
  }

  export type ExtensionSessionUpdateManyWithWhereWithoutUserInput = {
    where: ExtensionSessionScalarWhereInput
    data: XOR<ExtensionSessionUpdateManyMutationInput, ExtensionSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type ExtensionSessionScalarWhereInput = {
    AND?: ExtensionSessionScalarWhereInput | ExtensionSessionScalarWhereInput[]
    OR?: ExtensionSessionScalarWhereInput[]
    NOT?: ExtensionSessionScalarWhereInput | ExtensionSessionScalarWhereInput[]
    id?: StringFilter<"ExtensionSession"> | string
    userId?: StringFilter<"ExtensionSession"> | string
    sessionId?: StringFilter<"ExtensionSession"> | string
    isActive?: BoolFilter<"ExtensionSession"> | boolean
    lastActiveAt?: DateTimeFilter<"ExtensionSession"> | Date | string
    extensionVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    vscodeVersion?: StringNullableFilter<"ExtensionSession"> | string | null
    platform?: StringNullableFilter<"ExtensionSession"> | string | null
    metadata?: JsonNullableFilter<"ExtensionSession">
    tokensUsed?: IntFilter<"ExtensionSession"> | number
    requestsMade?: IntFilter<"ExtensionSession"> | number
    createdAt?: DateTimeFilter<"ExtensionSession"> | Date | string
  }

  export type UsageMetricsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageMetricsWhereUniqueInput
    update: XOR<UsageMetricsUpdateWithoutUserInput, UsageMetricsUncheckedUpdateWithoutUserInput>
    create: XOR<UsageMetricsCreateWithoutUserInput, UsageMetricsUncheckedCreateWithoutUserInput>
  }

  export type UsageMetricsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageMetricsWhereUniqueInput
    data: XOR<UsageMetricsUpdateWithoutUserInput, UsageMetricsUncheckedUpdateWithoutUserInput>
  }

  export type UsageMetricsUpdateManyWithWhereWithoutUserInput = {
    where: UsageMetricsScalarWhereInput
    data: XOR<UsageMetricsUpdateManyMutationInput, UsageMetricsUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageMetricsScalarWhereInput = {
    AND?: UsageMetricsScalarWhereInput | UsageMetricsScalarWhereInput[]
    OR?: UsageMetricsScalarWhereInput[]
    NOT?: UsageMetricsScalarWhereInput | UsageMetricsScalarWhereInput[]
    id?: StringFilter<"UsageMetrics"> | string
    userId?: StringFilter<"UsageMetrics"> | string
    tokensUsed?: IntFilter<"UsageMetrics"> | number
    inputTokens?: IntFilter<"UsageMetrics"> | number
    outputTokens?: IntFilter<"UsageMetrics"> | number
    cacheReadTokens?: IntFilter<"UsageMetrics"> | number
    cacheWriteTokens?: IntFilter<"UsageMetrics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageMetrics"> | number
    requestsMade?: IntFilter<"UsageMetrics"> | number
    costAccrued?: FloatFilter<"UsageMetrics"> | number
    date?: DateTimeFilter<"UsageMetrics"> | Date | string
  }

  export type ApiKeyUpsertWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    update: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
    create: XOR<ApiKeyCreateWithoutUserInput, ApiKeyUncheckedCreateWithoutUserInput>
  }

  export type ApiKeyUpdateWithWhereUniqueWithoutUserInput = {
    where: ApiKeyWhereUniqueInput
    data: XOR<ApiKeyUpdateWithoutUserInput, ApiKeyUncheckedUpdateWithoutUserInput>
  }

  export type ApiKeyUpdateManyWithWhereWithoutUserInput = {
    where: ApiKeyScalarWhereInput
    data: XOR<ApiKeyUpdateManyMutationInput, ApiKeyUncheckedUpdateManyWithoutUserInput>
  }

  export type ApiKeyScalarWhereInput = {
    AND?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    OR?: ApiKeyScalarWhereInput[]
    NOT?: ApiKeyScalarWhereInput | ApiKeyScalarWhereInput[]
    id?: StringFilter<"ApiKey"> | string
    userId?: StringFilter<"ApiKey"> | string
    name?: StringFilter<"ApiKey"> | string
    description?: StringNullableFilter<"ApiKey"> | string | null
    keyHash?: StringFilter<"ApiKey"> | string
    permissions?: JsonFilter<"ApiKey">
    isActive?: BoolFilter<"ApiKey"> | boolean
    expiresAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ApiKey"> | Date | string | null
    usageCount?: IntFilter<"ApiKey"> | number
    createdAt?: DateTimeFilter<"ApiKey"> | Date | string
    updatedAt?: DateTimeFilter<"ApiKey"> | Date | string
  }

  export type UsageAnalyticsUpsertWithWhereUniqueWithoutUserInput = {
    where: UsageAnalyticsWhereUniqueInput
    update: XOR<UsageAnalyticsUpdateWithoutUserInput, UsageAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<UsageAnalyticsCreateWithoutUserInput, UsageAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type UsageAnalyticsUpdateWithWhereUniqueWithoutUserInput = {
    where: UsageAnalyticsWhereUniqueInput
    data: XOR<UsageAnalyticsUpdateWithoutUserInput, UsageAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type UsageAnalyticsUpdateManyWithWhereWithoutUserInput = {
    where: UsageAnalyticsScalarWhereInput
    data: XOR<UsageAnalyticsUpdateManyMutationInput, UsageAnalyticsUncheckedUpdateManyWithoutUserInput>
  }

  export type UsageAnalyticsScalarWhereInput = {
    AND?: UsageAnalyticsScalarWhereInput | UsageAnalyticsScalarWhereInput[]
    OR?: UsageAnalyticsScalarWhereInput[]
    NOT?: UsageAnalyticsScalarWhereInput | UsageAnalyticsScalarWhereInput[]
    id?: StringFilter<"UsageAnalytics"> | string
    userId?: StringFilter<"UsageAnalytics"> | string
    modelId?: StringFilter<"UsageAnalytics"> | string
    tokensUsed?: IntFilter<"UsageAnalytics"> | number
    inputTokens?: IntFilter<"UsageAnalytics"> | number
    outputTokens?: IntFilter<"UsageAnalytics"> | number
    cacheReadTokens?: IntFilter<"UsageAnalytics"> | number
    cacheWriteTokens?: IntFilter<"UsageAnalytics"> | number
    cubentUnitsUsed?: FloatFilter<"UsageAnalytics"> | number
    requestsMade?: IntFilter<"UsageAnalytics"> | number
    costAccrued?: FloatFilter<"UsageAnalytics"> | number
    sessionId?: StringNullableFilter<"UsageAnalytics"> | string | null
    metadata?: JsonNullableFilter<"UsageAnalytics">
    createdAt?: DateTimeFilter<"UsageAnalytics"> | Date | string
  }

  export type AutocompleteAnalyticsUpsertWithWhereUniqueWithoutUserInput = {
    where: AutocompleteAnalyticsWhereUniqueInput
    update: XOR<AutocompleteAnalyticsUpdateWithoutUserInput, AutocompleteAnalyticsUncheckedUpdateWithoutUserInput>
    create: XOR<AutocompleteAnalyticsCreateWithoutUserInput, AutocompleteAnalyticsUncheckedCreateWithoutUserInput>
  }

  export type AutocompleteAnalyticsUpdateWithWhereUniqueWithoutUserInput = {
    where: AutocompleteAnalyticsWhereUniqueInput
    data: XOR<AutocompleteAnalyticsUpdateWithoutUserInput, AutocompleteAnalyticsUncheckedUpdateWithoutUserInput>
  }

  export type AutocompleteAnalyticsUpdateManyWithWhereWithoutUserInput = {
    where: AutocompleteAnalyticsScalarWhereInput
    data: XOR<AutocompleteAnalyticsUpdateManyMutationInput, AutocompleteAnalyticsUncheckedUpdateManyWithoutUserInput>
  }

  export type AutocompleteAnalyticsScalarWhereInput = {
    AND?: AutocompleteAnalyticsScalarWhereInput | AutocompleteAnalyticsScalarWhereInput[]
    OR?: AutocompleteAnalyticsScalarWhereInput[]
    NOT?: AutocompleteAnalyticsScalarWhereInput | AutocompleteAnalyticsScalarWhereInput[]
    id?: StringFilter<"AutocompleteAnalytics"> | string
    userId?: StringFilter<"AutocompleteAnalytics"> | string
    modelId?: StringFilter<"AutocompleteAnalytics"> | string
    provider?: StringFilter<"AutocompleteAnalytics"> | string
    completionsGenerated?: IntFilter<"AutocompleteAnalytics"> | number
    completionsAccepted?: IntFilter<"AutocompleteAnalytics"> | number
    linesAdded?: IntFilter<"AutocompleteAnalytics"> | number
    charactersAdded?: IntFilter<"AutocompleteAnalytics"> | number
    language?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    filepath?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    sessionId?: StringNullableFilter<"AutocompleteAnalytics"> | string | null
    avgLatency?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    successRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    acceptanceRate?: FloatNullableFilter<"AutocompleteAnalytics"> | number | null
    metadata?: JsonNullableFilter<"AutocompleteAnalytics">
    createdAt?: DateTimeFilter<"AutocompleteAnalytics"> | Date | string
  }

  export type AutocompleteMetricsUpsertWithWhereUniqueWithoutUserInput = {
    where: AutocompleteMetricsWhereUniqueInput
    update: XOR<AutocompleteMetricsUpdateWithoutUserInput, AutocompleteMetricsUncheckedUpdateWithoutUserInput>
    create: XOR<AutocompleteMetricsCreateWithoutUserInput, AutocompleteMetricsUncheckedCreateWithoutUserInput>
  }

  export type AutocompleteMetricsUpdateWithWhereUniqueWithoutUserInput = {
    where: AutocompleteMetricsWhereUniqueInput
    data: XOR<AutocompleteMetricsUpdateWithoutUserInput, AutocompleteMetricsUncheckedUpdateWithoutUserInput>
  }

  export type AutocompleteMetricsUpdateManyWithWhereWithoutUserInput = {
    where: AutocompleteMetricsScalarWhereInput
    data: XOR<AutocompleteMetricsUpdateManyMutationInput, AutocompleteMetricsUncheckedUpdateManyWithoutUserInput>
  }

  export type AutocompleteMetricsScalarWhereInput = {
    AND?: AutocompleteMetricsScalarWhereInput | AutocompleteMetricsScalarWhereInput[]
    OR?: AutocompleteMetricsScalarWhereInput[]
    NOT?: AutocompleteMetricsScalarWhereInput | AutocompleteMetricsScalarWhereInput[]
    id?: StringFilter<"AutocompleteMetrics"> | string
    userId?: StringFilter<"AutocompleteMetrics"> | string
    completionsGenerated?: IntFilter<"AutocompleteMetrics"> | number
    completionsAccepted?: IntFilter<"AutocompleteMetrics"> | number
    linesAdded?: IntFilter<"AutocompleteMetrics"> | number
    charactersAdded?: IntFilter<"AutocompleteMetrics"> | number
    avgLatency?: FloatFilter<"AutocompleteMetrics"> | number
    avgSuccessRate?: FloatFilter<"AutocompleteMetrics"> | number
    avgAcceptanceRate?: FloatFilter<"AutocompleteMetrics"> | number
    modelBreakdown?: JsonNullableFilter<"AutocompleteMetrics">
    date?: DateTimeFilter<"AutocompleteMetrics"> | Date | string
  }

  export type UserPreferencesUpsertWithoutUserInput = {
    update: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserPreferencesCreateWithoutUserInput, UserPreferencesUncheckedCreateWithoutUserInput>
    where?: UserPreferencesWhereInput
  }

  export type UserPreferencesUpdateToOneWithWhereWithoutUserInput = {
    where?: UserPreferencesWhereInput
    data: XOR<UserPreferencesUpdateWithoutUserInput, UserPreferencesUncheckedUpdateWithoutUserInput>
  }

  export type UserPreferencesUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPreferencesUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeAirports?: JsonNullValueInput | InputJsonValue
    dreamDestinations?: JsonNullValueInput | InputJsonValue
    deliveryFrequency?: StringFieldUpdateOperationsInput | string
    maxBudget?: NullableFloatFieldUpdateOperationsInput | number | null
    preferredAirlines?: NullableJsonNullValueInput | InputJsonValue
    travelFlexibility?: IntFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    headerImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationUpsertWithWhereUniqueWithoutUserInput = {
    where: FlightRecommendationWhereUniqueInput
    update: XOR<FlightRecommendationUpdateWithoutUserInput, FlightRecommendationUncheckedUpdateWithoutUserInput>
    create: XOR<FlightRecommendationCreateWithoutUserInput, FlightRecommendationUncheckedCreateWithoutUserInput>
  }

  export type FlightRecommendationUpdateWithWhereUniqueWithoutUserInput = {
    where: FlightRecommendationWhereUniqueInput
    data: XOR<FlightRecommendationUpdateWithoutUserInput, FlightRecommendationUncheckedUpdateWithoutUserInput>
  }

  export type FlightRecommendationUpdateManyWithWhereWithoutUserInput = {
    where: FlightRecommendationScalarWhereInput
    data: XOR<FlightRecommendationUpdateManyMutationInput, FlightRecommendationUncheckedUpdateManyWithoutUserInput>
  }

  export type FlightRecommendationScalarWhereInput = {
    AND?: FlightRecommendationScalarWhereInput | FlightRecommendationScalarWhereInput[]
    OR?: FlightRecommendationScalarWhereInput[]
    NOT?: FlightRecommendationScalarWhereInput | FlightRecommendationScalarWhereInput[]
    id?: StringFilter<"FlightRecommendation"> | string
    userId?: StringFilter<"FlightRecommendation"> | string
    origin?: StringFilter<"FlightRecommendation"> | string
    destination?: StringFilter<"FlightRecommendation"> | string
    departureDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    returnDate?: DateTimeNullableFilter<"FlightRecommendation"> | Date | string | null
    price?: FloatFilter<"FlightRecommendation"> | number
    currency?: StringFilter<"FlightRecommendation"> | string
    airline?: StringFilter<"FlightRecommendation"> | string
    flightNumber?: StringNullableFilter<"FlightRecommendation"> | string | null
    layovers?: JsonNullableFilter<"FlightRecommendation">
    duration?: StringNullableFilter<"FlightRecommendation"> | string | null
    baggageInfo?: JsonNullableFilter<"FlightRecommendation">
    aiSummary?: StringNullableFilter<"FlightRecommendation"> | string | null
    confidenceScore?: FloatNullableFilter<"FlightRecommendation"> | number | null
    dealQuality?: StringNullableFilter<"FlightRecommendation"> | string | null
    bookingUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    otaUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityImageUrl?: StringNullableFilter<"FlightRecommendation"> | string | null
    cityActivities?: JsonNullableFilter<"FlightRecommendation">
    searchDate?: DateTimeFilter<"FlightRecommendation"> | Date | string
    isActive?: BoolFilter<"FlightRecommendation"> | boolean
    isWatched?: BoolFilter<"FlightRecommendation"> | boolean
    createdAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
    updatedAt?: DateTimeFilter<"FlightRecommendation"> | Date | string
  }

  export type StripeSubscriptionUpsertWithoutUserInput = {
    update: XOR<StripeSubscriptionUpdateWithoutUserInput, StripeSubscriptionUncheckedUpdateWithoutUserInput>
    create: XOR<StripeSubscriptionCreateWithoutUserInput, StripeSubscriptionUncheckedCreateWithoutUserInput>
    where?: StripeSubscriptionWhereInput
  }

  export type StripeSubscriptionUpdateToOneWithWhereWithoutUserInput = {
    where?: StripeSubscriptionWhereInput
    data: XOR<StripeSubscriptionUpdateWithoutUserInput, StripeSubscriptionUncheckedUpdateWithoutUserInput>
  }

  export type StripeSubscriptionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StripeSubscriptionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    stripeCustomerId?: StringFieldUpdateOperationsInput | string
    stripeSubscriptionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePriceId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    currentPeriodStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currentPeriodEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelAtPeriodEnd?: BoolFieldUpdateOperationsInput | boolean
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    interval?: StringFieldUpdateOperationsInput | string
    trialEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    canceledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    update: XOR<EmailNotificationUpdateWithoutUserInput, EmailNotificationUncheckedUpdateWithoutUserInput>
    create: XOR<EmailNotificationCreateWithoutUserInput, EmailNotificationUncheckedCreateWithoutUserInput>
  }

  export type EmailNotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailNotificationWhereUniqueInput
    data: XOR<EmailNotificationUpdateWithoutUserInput, EmailNotificationUncheckedUpdateWithoutUserInput>
  }

  export type EmailNotificationUpdateManyWithWhereWithoutUserInput = {
    where: EmailNotificationScalarWhereInput
    data: XOR<EmailNotificationUpdateManyMutationInput, EmailNotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailNotificationScalarWhereInput = {
    AND?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
    OR?: EmailNotificationScalarWhereInput[]
    NOT?: EmailNotificationScalarWhereInput | EmailNotificationScalarWhereInput[]
    id?: StringFilter<"EmailNotification"> | string
    userId?: StringFilter<"EmailNotification"> | string
    subject?: StringFilter<"EmailNotification"> | string
    content?: StringFilter<"EmailNotification"> | string
    recipientEmail?: StringFilter<"EmailNotification"> | string
    notificationType?: StringFilter<"EmailNotification"> | string
    flightCount?: IntFilter<"EmailNotification"> | number
    status?: StringFilter<"EmailNotification"> | string
    sentAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"EmailNotification"> | Date | string | null
    errorMessage?: StringNullableFilter<"EmailNotification"> | string | null
    sendGridMessageId?: StringNullableFilter<"EmailNotification"> | string | null
    createdAt?: DateTimeFilter<"EmailNotification"> | Date | string
    updatedAt?: DateTimeFilter<"EmailNotification"> | Date | string
  }

  export type UserCreateWithoutExtensionSessionsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutExtensionSessionsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutExtensionSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExtensionSessionsInput, UserUncheckedCreateWithoutExtensionSessionsInput>
  }

  export type UserUpsertWithoutExtensionSessionsInput = {
    update: XOR<UserUpdateWithoutExtensionSessionsInput, UserUncheckedUpdateWithoutExtensionSessionsInput>
    create: XOR<UserCreateWithoutExtensionSessionsInput, UserUncheckedCreateWithoutExtensionSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExtensionSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExtensionSessionsInput, UserUncheckedUpdateWithoutExtensionSessionsInput>
  }

  export type UserUpdateWithoutExtensionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutExtensionSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUsageMetricsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageMetricsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageMetricsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
  }

  export type UserUpsertWithoutUsageMetricsInput = {
    update: XOR<UserUpdateWithoutUsageMetricsInput, UserUncheckedUpdateWithoutUsageMetricsInput>
    create: XOR<UserCreateWithoutUsageMetricsInput, UserUncheckedCreateWithoutUsageMetricsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageMetricsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageMetricsInput, UserUncheckedUpdateWithoutUsageMetricsInput>
  }

  export type UserUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutUsageAnalyticsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUsageAnalyticsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUsageAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUsageAnalyticsInput, UserUncheckedCreateWithoutUsageAnalyticsInput>
  }

  export type UserUpsertWithoutUsageAnalyticsInput = {
    update: XOR<UserUpdateWithoutUsageAnalyticsInput, UserUncheckedUpdateWithoutUsageAnalyticsInput>
    create: XOR<UserCreateWithoutUsageAnalyticsInput, UserUncheckedCreateWithoutUsageAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUsageAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUsageAnalyticsInput, UserUncheckedUpdateWithoutUsageAnalyticsInput>
  }

  export type UserUpdateWithoutUsageAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUsageAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAutocompleteAnalyticsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutocompleteAnalyticsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutocompleteAnalyticsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutocompleteAnalyticsInput, UserUncheckedCreateWithoutAutocompleteAnalyticsInput>
  }

  export type UserUpsertWithoutAutocompleteAnalyticsInput = {
    update: XOR<UserUpdateWithoutAutocompleteAnalyticsInput, UserUncheckedUpdateWithoutAutocompleteAnalyticsInput>
    create: XOR<UserCreateWithoutAutocompleteAnalyticsInput, UserUncheckedCreateWithoutAutocompleteAnalyticsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutocompleteAnalyticsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutocompleteAnalyticsInput, UserUncheckedUpdateWithoutAutocompleteAnalyticsInput>
  }

  export type UserUpdateWithoutAutocompleteAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutocompleteAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAutocompleteMetricsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAutocompleteMetricsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAutocompleteMetricsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAutocompleteMetricsInput, UserUncheckedCreateWithoutAutocompleteMetricsInput>
  }

  export type UserUpsertWithoutAutocompleteMetricsInput = {
    update: XOR<UserUpdateWithoutAutocompleteMetricsInput, UserUncheckedUpdateWithoutAutocompleteMetricsInput>
    create: XOR<UserCreateWithoutAutocompleteMetricsInput, UserUncheckedCreateWithoutAutocompleteMetricsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAutocompleteMetricsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAutocompleteMetricsInput, UserUncheckedUpdateWithoutAutocompleteMetricsInput>
  }

  export type UserUpdateWithoutAutocompleteMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAutocompleteMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutApiKeysInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutApiKeysInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutApiKeysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
  }

  export type UserUpsertWithoutApiKeysInput = {
    update: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
    create: XOR<UserCreateWithoutApiKeysInput, UserUncheckedCreateWithoutApiKeysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApiKeysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApiKeysInput, UserUncheckedUpdateWithoutApiKeysInput>
  }

  export type UserUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutApiKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTravelPreferencesInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTravelPreferencesInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTravelPreferencesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTravelPreferencesInput, UserUncheckedCreateWithoutTravelPreferencesInput>
  }

  export type UserUpsertWithoutTravelPreferencesInput = {
    update: XOR<UserUpdateWithoutTravelPreferencesInput, UserUncheckedUpdateWithoutTravelPreferencesInput>
    create: XOR<UserCreateWithoutTravelPreferencesInput, UserUncheckedCreateWithoutTravelPreferencesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTravelPreferencesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTravelPreferencesInput, UserUncheckedUpdateWithoutTravelPreferencesInput>
  }

  export type UserUpdateWithoutTravelPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTravelPreferencesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFlightRecommendationsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlightRecommendationsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlightRecommendationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlightRecommendationsInput, UserUncheckedCreateWithoutFlightRecommendationsInput>
  }

  export type UserUpsertWithoutFlightRecommendationsInput = {
    update: XOR<UserUpdateWithoutFlightRecommendationsInput, UserUncheckedUpdateWithoutFlightRecommendationsInput>
    create: XOR<UserCreateWithoutFlightRecommendationsInput, UserUncheckedCreateWithoutFlightRecommendationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlightRecommendationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlightRecommendationsInput, UserUncheckedUpdateWithoutFlightRecommendationsInput>
  }

  export type UserUpdateWithoutFlightRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlightRecommendationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutStripeSubscriptionInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    emailNotifications?: EmailNotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStripeSubscriptionInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    emailNotifications?: EmailNotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStripeSubscriptionInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStripeSubscriptionInput, UserUncheckedCreateWithoutStripeSubscriptionInput>
  }

  export type UserUpsertWithoutStripeSubscriptionInput = {
    update: XOR<UserUpdateWithoutStripeSubscriptionInput, UserUncheckedUpdateWithoutStripeSubscriptionInput>
    create: XOR<UserCreateWithoutStripeSubscriptionInput, UserUncheckedCreateWithoutStripeSubscriptionInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStripeSubscriptionInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStripeSubscriptionInput, UserUncheckedUpdateWithoutStripeSubscriptionInput>
  }

  export type UserUpdateWithoutStripeSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    emailNotifications?: EmailNotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStripeSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    emailNotifications?: EmailNotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEmailNotificationsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailNotificationsInput = {
    id?: string
    clerkId: string
    email: string
    name?: string | null
    picture?: string | null
    extensionApiKey?: string | null
    sessionToken?: string | null
    lastExtensionSync?: Date | string | null
    lastSettingsSync?: Date | string | null
    extensionEnabled?: boolean
    lastActiveAt?: Date | string | null
    termsAccepted?: boolean
    termsAcceptedAt?: Date | string | null
    subscriptionTier?: string
    subscriptionStatus?: string
    cubentUnitsUsed?: number
    cubentUnitsLimit?: number
    unitsResetDate?: Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    extensionSessions?: ExtensionSessionUncheckedCreateNestedManyWithoutUserInput
    usageMetrics?: UsageMetricsUncheckedCreateNestedManyWithoutUserInput
    apiKeys?: ApiKeyUncheckedCreateNestedManyWithoutUserInput
    usageAnalytics?: UsageAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedCreateNestedManyWithoutUserInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedCreateNestedManyWithoutUserInput
    travelPreferences?: UserPreferencesUncheckedCreateNestedOneWithoutUserInput
    flightRecommendations?: FlightRecommendationUncheckedCreateNestedManyWithoutUserInput
    stripeSubscription?: StripeSubscriptionUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailNotificationsInput, UserUncheckedCreateWithoutEmailNotificationsInput>
  }

  export type UserUpsertWithoutEmailNotificationsInput = {
    update: XOR<UserUpdateWithoutEmailNotificationsInput, UserUncheckedUpdateWithoutEmailNotificationsInput>
    create: XOR<UserCreateWithoutEmailNotificationsInput, UserUncheckedCreateWithoutEmailNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailNotificationsInput, UserUncheckedUpdateWithoutEmailNotificationsInput>
  }

  export type UserUpdateWithoutEmailNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clerkId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    extensionApiKey?: NullableStringFieldUpdateOperationsInput | string | null
    sessionToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastExtensionSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSettingsSync?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionEnabled?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    termsAccepted?: BoolFieldUpdateOperationsInput | boolean
    termsAcceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptionTier?: StringFieldUpdateOperationsInput | string
    subscriptionStatus?: StringFieldUpdateOperationsInput | string
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    cubentUnitsLimit?: FloatFieldUpdateOperationsInput | number
    unitsResetDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    extensionSettings?: NullableJsonNullValueInput | InputJsonValue
    preferences?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionSessions?: ExtensionSessionUncheckedUpdateManyWithoutUserNestedInput
    usageMetrics?: UsageMetricsUncheckedUpdateManyWithoutUserNestedInput
    apiKeys?: ApiKeyUncheckedUpdateManyWithoutUserNestedInput
    usageAnalytics?: UsageAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteAnalytics?: AutocompleteAnalyticsUncheckedUpdateManyWithoutUserNestedInput
    autocompleteMetrics?: AutocompleteMetricsUncheckedUpdateManyWithoutUserNestedInput
    travelPreferences?: UserPreferencesUncheckedUpdateOneWithoutUserNestedInput
    flightRecommendations?: FlightRecommendationUncheckedUpdateManyWithoutUserNestedInput
    stripeSubscription?: StripeSubscriptionUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ExtensionSessionCreateManyUserInput = {
    id?: string
    sessionId: string
    isActive?: boolean
    lastActiveAt?: Date | string
    extensionVersion?: string | null
    vscodeVersion?: string | null
    platform?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: number
    requestsMade?: number
    createdAt?: Date | string
  }

  export type UsageMetricsCreateManyUserInput = {
    id?: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    date?: Date | string
  }

  export type ApiKeyCreateManyUserInput = {
    id?: string
    name: string
    description?: string | null
    keyHash: string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    expiresAt?: Date | string | null
    lastUsedAt?: Date | string | null
    usageCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UsageAnalyticsCreateManyUserInput = {
    id?: string
    modelId: string
    tokensUsed?: number
    inputTokens?: number
    outputTokens?: number
    cacheReadTokens?: number
    cacheWriteTokens?: number
    cubentUnitsUsed?: number
    requestsMade?: number
    costAccrued?: number
    sessionId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteAnalyticsCreateManyUserInput = {
    id?: string
    modelId: string
    provider: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    language?: string | null
    filepath?: string | null
    sessionId?: string | null
    avgLatency?: number | null
    successRate?: number | null
    acceptanceRate?: number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AutocompleteMetricsCreateManyUserInput = {
    id?: string
    completionsGenerated?: number
    completionsAccepted?: number
    linesAdded?: number
    charactersAdded?: number
    avgLatency?: number
    avgSuccessRate?: number
    avgAcceptanceRate?: number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: Date | string
  }

  export type FlightRecommendationCreateManyUserInput = {
    id?: string
    origin: string
    destination: string
    departureDate: Date | string
    returnDate?: Date | string | null
    price: number
    currency?: string
    airline: string
    flightNumber?: string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: string | null
    confidenceScore?: number | null
    dealQuality?: string | null
    bookingUrl?: string | null
    otaUrl?: string | null
    cityImageUrl?: string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: Date | string
    isActive?: boolean
    isWatched?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmailNotificationCreateManyUserInput = {
    id?: string
    subject: string
    content: string
    recipientEmail: string
    notificationType: string
    flightCount?: number
    status?: string
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    sendGridMessageId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExtensionSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtensionSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExtensionSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastActiveAt?: DateTimeFieldUpdateOperationsInput | Date | string
    extensionVersion?: NullableStringFieldUpdateOperationsInput | string | null
    vscodeVersion?: NullableStringFieldUpdateOperationsInput | string | null
    platform?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    tokensUsed?: IntFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageMetricsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApiKeyUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    keyHash?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageAnalyticsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    tokensUsed?: IntFieldUpdateOperationsInput | number
    inputTokens?: IntFieldUpdateOperationsInput | number
    outputTokens?: IntFieldUpdateOperationsInput | number
    cacheReadTokens?: IntFieldUpdateOperationsInput | number
    cacheWriteTokens?: IntFieldUpdateOperationsInput | number
    cubentUnitsUsed?: FloatFieldUpdateOperationsInput | number
    requestsMade?: IntFieldUpdateOperationsInput | number
    costAccrued?: FloatFieldUpdateOperationsInput | number
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteAnalyticsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    language?: NullableStringFieldUpdateOperationsInput | string | null
    filepath?: NullableStringFieldUpdateOperationsInput | string | null
    sessionId?: NullableStringFieldUpdateOperationsInput | string | null
    avgLatency?: NullableFloatFieldUpdateOperationsInput | number | null
    successRate?: NullableFloatFieldUpdateOperationsInput | number | null
    acceptanceRate?: NullableFloatFieldUpdateOperationsInput | number | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AutocompleteMetricsUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    completionsGenerated?: IntFieldUpdateOperationsInput | number
    completionsAccepted?: IntFieldUpdateOperationsInput | number
    linesAdded?: IntFieldUpdateOperationsInput | number
    charactersAdded?: IntFieldUpdateOperationsInput | number
    avgLatency?: FloatFieldUpdateOperationsInput | number
    avgSuccessRate?: FloatFieldUpdateOperationsInput | number
    avgAcceptanceRate?: FloatFieldUpdateOperationsInput | number
    modelBreakdown?: NullableJsonNullValueInput | InputJsonValue
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlightRecommendationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    origin?: StringFieldUpdateOperationsInput | string
    destination?: StringFieldUpdateOperationsInput | string
    departureDate?: DateTimeFieldUpdateOperationsInput | Date | string
    returnDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    price?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    airline?: StringFieldUpdateOperationsInput | string
    flightNumber?: NullableStringFieldUpdateOperationsInput | string | null
    layovers?: NullableJsonNullValueInput | InputJsonValue
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    baggageInfo?: NullableJsonNullValueInput | InputJsonValue
    aiSummary?: NullableStringFieldUpdateOperationsInput | string | null
    confidenceScore?: NullableFloatFieldUpdateOperationsInput | number | null
    dealQuality?: NullableStringFieldUpdateOperationsInput | string | null
    bookingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    otaUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    cityActivities?: NullableJsonNullValueInput | InputJsonValue
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isWatched?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailNotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    recipientEmail?: StringFieldUpdateOperationsInput | string
    notificationType?: StringFieldUpdateOperationsInput | string
    flightCount?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    sendGridMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}